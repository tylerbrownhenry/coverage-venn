
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/commander/lib/error.js
var require_error = __commonJS({
  "node_modules/commander/lib/error.js"(exports2) {
    var CommanderError2 = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @constructor
       */
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       * @constructor
       */
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
  }
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "node_modules/commander/lib/argument.js"(exports2) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      /**
       * Return argument name.
       *
       * @return {string}
       */
      name() {
        return this._name;
      }
      /**
       * @api private
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Argument}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Make argument required.
       */
      argRequired() {
        this.required = true;
        return this;
      }
      /**
       * Make argument optional.
       */
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports2.Argument = Argument2;
    exports2.humanReadableArgName = humanReadableArgName;
  }
});

// node_modules/commander/lib/help.js
var require_help = __commonJS({
  "node_modules/commander/lib/help.js"(exports2) {
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        if (cmd._hasImplicitHelpCommand()) {
          const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
          const helpCommand = cmd.createCommand(helpName).helpOption(false);
          helpCommand.description(cmd._helpCommandDescription);
          if (helpArgs) helpCommand.arguments(helpArgs);
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns number
       */
      compareOptions(a, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }
      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
        const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpOption;
          if (!showShortHelpFlag) {
            helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
          } else if (!showLongHelpFlag) {
            helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
          } else {
            helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
          }
          visibleOptions.push(helpOption);
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions) return [];
        const globalOptions = [];
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd.registeredArguments.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd.registeredArguments.find((argument) => argument.description)) {
          return cmd.registeredArguments;
        }
        return [];
      }
      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandTerm(cmd) {
        const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
        (args ? " " + args : "");
      }
      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */
      optionTerm(option) {
        return option.flags;
      }
      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */
      argumentTerm(argument) {
        return argument.name();
      }
      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let ancestorCmdNames = "";
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
        }
        return ancestorCmdNames + cmdName + " " + cmd.usage();
      }
      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandDescription(cmd) {
        return cmd.description();
      }
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([helper.wrap(commandDescription, helpWidth, 0), ""]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        if (this.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return formatItem(helper.optionTerm(option), helper.optionDescription(option));
          });
          if (globalOptionList.length > 0) {
            output = output.concat(["Global Options:", formatList(globalOptionList), ""]);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      /**
       * Wrap the given string to width characters per line, with lines after the first indented.
       * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
       *
       * @param {string} str
       * @param {number} width
       * @param {number} indent
       * @param {number} [minColumnWidth=40]
       * @return {string}
       *
       */
      wrap(str, width, indent, minColumnWidth = 40) {
        const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
        const manualIndent = new RegExp(`[\\n][${indents}]+`);
        if (str.match(manualIndent)) return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth) return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent).replace("\r\n", "\n");
        const indentString = " ".repeat(indent);
        const zeroWidthSpace = "\u200B";
        const breaks = `\\s${zeroWidthSpace}`;
        const regex = new RegExp(`
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, "g");
        const lines = columnText.match(regex) || [];
        return leadingStr + lines.map((line, i) => {
          if (line === "\n") return "";
          return (i > 0 ? indentString : "") + line.trimEnd();
        }).join("\n");
      }
    };
    exports2.Help = Help2;
  }
});

// node_modules/commander/lib/option.js
var require_option = __commonJS({
  "node_modules/commander/lib/option.js"(exports2) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Option}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {*} arg
       * @return {Option}
       */
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {string | string[]} names
       * @return {Option}
       */
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {Object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        let newImplied = impliedOptionValues;
        if (typeof impliedOptionValues === "string") {
          newImplied = { [impliedOptionValues]: true };
        }
        this.implied = Object.assign(this.implied || {}, newImplied);
        return this;
      }
      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */
      env(name) {
        this.envVar = name;
        return this;
      }
      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      /**
       * @api private
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Return option name.
       *
       * @return {string}
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as a object attribute key.
       *
       * @return {string}
       * @api private
       */
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @api private
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @api private
       */
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      /**
       * @param {Option[]} options
       */
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {*} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey)) return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports2.Option = Option2;
    exports2.splitOptionFlags = splitOptionFlags;
    exports2.DualOptions = DualOptions;
  }
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "node_modules/commander/lib/suggestSimilar.js"(exports2) {
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1,
            // deletion
            d[i][j - 1] + 1,
            // insertion
            d[i - 1][j - 1] + cost
            // substitution
          );
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0) return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1) return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports2.suggestSimilar = suggestSimilar;
  }
});

// node_modules/commander/lib/command.js
var require_command = __commonJS({
  "node_modules/commander/lib/command.js"(exports2) {
    var EventEmitter = require("events").EventEmitter;
    var childProcess = require("child_process");
    var path3 = require("path");
    var fs4 = require("fs");
    var process2 = require("process");
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, splitOptionFlags, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class _Command extends EventEmitter {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this.registeredArguments = [];
        this._args = this.registeredArguments;
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process2.stdout.write(str),
          writeErr: (str) => process2.stderr.write(str),
          getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
          getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = "-h, --help";
        this._helpDescription = "display help for command";
        this._helpShortFlag = "-h";
        this._helpLongFlag = "--help";
        this._addImplicitHelpCommand = void 0;
        this._helpCommandName = "help";
        this._helpCommandnameAndArgs = "help [command]";
        this._helpCommandDescription = "display help for command";
        this._helpConfiguration = {};
      }
      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._hasHelpOption = sourceCommand._hasHelpOption;
        this._helpFlags = sourceCommand._helpFlags;
        this._helpDescription = sourceCommand._helpDescription;
        this._helpShortFlag = sourceCommand._helpShortFlag;
        this._helpLongFlag = sourceCommand._helpLongFlag;
        this._helpCommandName = sourceCommand._helpCommandName;
        this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
        this._helpCommandDescription = sourceCommand._helpCommandDescription;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      /**
       * @returns {Command[]}
       * @api private
       */
      _getCommandAndAncestors() {
        const result = [];
        for (let command = this; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {Object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args) cmd.arguments(args);
        this.commands.push(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc) return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */
      createCommand(name) {
        return new _Command(name);
      }
      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {Object} [configuration] - configuration options
       * @return {Command|Object} `this` command for chaining, or stored configuration
       */
      configureHelp(configuration) {
        if (configuration === void 0) return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // functions to change where being written, stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // matching functions to specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // functions based on what is being written out
       *     outputError(str, write) // used for displaying errors, and not used for displaying help
       *
       * @param {Object} [configuration] - configuration options
       * @return {Command|Object} `this` command for chaining, or stored configuration
       */
      configureOutput(configuration) {
        if (configuration === void 0) return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {boolean|string} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string") displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {Object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden) cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {Function|*} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */
      arguments(names) {
        names.trim().split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this.registeredArguments.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this.registeredArguments.push(argument);
        return this;
      }
      /**
       * Override default decision whether to add implicit help command.
       *
       *    addHelpCommand() // force on
       *    addHelpCommand(false); // force off
       *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
       *
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._addImplicitHelpCommand = false;
        } else {
          this._addImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === "string") {
            this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription = description || this._helpCommandDescription;
        }
        return this;
      }
      /**
       * @return {boolean}
       * @api private
       */
      _hasImplicitHelpCommand() {
        if (this._addImplicitHelpCommand === void 0) {
          return this.commands.length && !this._actionHandler && !this._findCommand("help");
        }
        return this._addImplicitHelpCommand;
      }
      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @api private
       */
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process2.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this.registeredArguments.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      /**
       * Wrap parseArgs to catch 'commander.invalidArgument'.
       *
       * @param {Option | Argument} target
       * @param {string} value
       * @param {*} previous
       * @param {string} invalidArgumentMessage
       * @api private
       */
      _callParseArg(target, value, previous, invalidArgumentMessage) {
        try {
          return target.parseArg(value, previous);
        } catch (err) {
          if (err.code === "commander.invalidArgument") {
            const message = `${invalidArgumentMessage} ${err.message}`;
            this.error(message, { exitCode: err.exitCode, code: err.code });
          }
          throw err;
        }
      }
      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, "default");
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        this.options.push(option);
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            val = this._callParseArg(option, val, oldValue, invalidValueMessage);
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @api private
       */
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m = regex.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      /**
       * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
       * option-argument is indicated by `<>` and an optional option-argument by `[]`.
       *
       * See the README for more details, and see also addOption() and requiredOption().
       *
       * @example
       * program
       *     .option('-p, --pepper', 'add pepper')
       *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
       *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
       *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {Function|*} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      option(flags, description, parseArg, defaultValue) {
        return this._optionEx({}, flags, description, parseArg, defaultValue);
      }
      /**
      * Add a required option which must have a value after parsing. This usually means
      * the option must be specified on the command line. (Otherwise the same as .option().)
      *
      * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
      *
      * @param {string} flags
      * @param {string} [description]
      * @param {Function|*} [parseArg] - custom option processing function or default value
      * @param {*} [defaultValue]
      * @return {Command} `this` command for chaining
      */
      requiredOption(flags, description, parseArg, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
       * for unknown options.
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
       * for excess arguments.
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {Boolean} [positional=true]
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {Boolean} [passThrough=true]
       * for unknown options.
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
          throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
        }
        return this;
      }
      /**
        * Whether to store option values as properties on command object,
        * or store separately (specify false). In both cases the option values can be accessed using .opts().
        *
        * @param {boolean} [storeAsProperties=true]
        * @return {Command} `this` command for chaining
        */
      storeOptionsAsProperties(storeAsProperties = true) {
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        this._storeOptionsAsProperties = !!storeAsProperties;
        return this;
      }
      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {Object} value
       */
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Store option value.
       *
       * @param {string} key
       * @param {Object} value
       * @return {Command} `this` command for chaining
       */
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      /**
        * Store option value and where the value came from.
        *
        * @param {string} key
        * @param {Object} value
        * @param {string} source - expected values are default/config/env/cli/implied
        * @return {Command} `this` command for chaining
        */
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      /**
        * Get source of option value.
        * Expected values are default | config | env | cli | implied
        *
        * @param {string} key
        * @return {string}
        */
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      /**
        * Get source of option value. See also .optsWithGlobals().
        * Expected values are default | config | env | cli | implied
        *
        * @param {string} key
        * @return {string}
        */
      getOptionValueSourceWithGlobals(key) {
        let source;
        this._getCommandAndAncestors().forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @api private
       */
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0) {
          argv = process2.argv;
          if (process2.versions && process2.versions.electron) {
            parseOptions.from = "electron";
          }
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process2.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * @example
       * program.parse(process.argv);
       * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * @example
       * await program.parseAsync(process.argv);
       * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {Object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Execute a sub-command executable.
       *
       * @api private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path3.resolve(baseDir, baseName);
          if (fs4.existsSync(localBin)) return localBin;
          if (sourceExt.includes(path3.extname(baseName))) return void 0;
          const foundExt = sourceExt.find((ext) => fs4.existsSync(`${localBin}${ext}`));
          if (foundExt) return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs4.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path3.resolve(path3.dirname(resolvedScriptPath), executableDir);
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path3.basename(this._scriptPath, path3.extname(this._scriptPath));
            if (legacyName !== this._name) {
              localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path3.extname(executableFile));
        let proc;
        if (process2.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals.forEach((signal) => {
            process2.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on("close", process2.exit.bind(process2));
        } else {
          proc.on("close", () => {
            exitCallback(new CommanderError2(process2.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          });
        }
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process2.exit(1);
          } else {
            const wrappedError = new CommanderError2(1, "commander.executeSubCommandAsync", "(error)");
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @api private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand) this.help({ error: true });
        let promiseChain;
        promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
        promiseChain = this._chainOrCall(promiseChain, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return promiseChain;
      }
      /**
       * Invoke help directly if possible, or dispatch if necessary.
       * e.g. help foo
       *
       * @api private
       */
      _dispatchHelpCommand(subcommandName) {
        if (!subcommandName) {
          this.help();
        }
        const subCommand = this._findCommand(subcommandName);
        if (subCommand && !subCommand._executableHandler) {
          subCommand.help();
        }
        return this._dispatchSubcommand(subcommandName, [], [
          this._helpLongFlag || this._helpShortFlag
        ]);
      }
      /**
       * Check this.args against expected this.registeredArguments.
       *
       * @api private
       */
      _checkNumberOfArguments() {
        this.registeredArguments.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
          return;
        }
        if (this.args.length > this.registeredArguments.length) {
          this._excessArguments(this.args);
        }
      }
      /**
       * Process this.args using this.registeredArguments and save as this.processedArgs!
       *
       * @api private
       */
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
            parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this.registeredArguments.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {Promise|undefined} promise
       * @param {Function} fn
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      /**
       *
       * @param {Promise|undefined} promise
       * @param {string} event
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      /**
       *
       * @param {Promise|undefined} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @api private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
          return this._dispatchHelpCommand(operands[1]);
        }
        if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        outputHelpIfRequested(this, parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let promiseChain;
          promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
          promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
          if (this.parent) {
            promiseChain = this._chainOrCall(promiseChain, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
          return promiseChain;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      /**
       * Find matching command.
       *
       * @api private
       */
      _findCommand(name) {
        if (!name) return void 0;
        return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @api private
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @api private
       */
      _checkForMissingMandatoryOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        });
      }
      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @api private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter(
          (option) => {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0) {
              return false;
            }
            return this.getOptionValueSource(optionKey) !== "default";
          }
        );
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @api private
       */
      _checkForConflictingOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd._checkForConflictingLocalOptions();
        });
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {String[]} argv
       * @return {{operands: String[], unknown: String[]}}
       */
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown) dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0) this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
              operands.push(arg);
              if (args.length > 0) operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0) dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {Object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {Object}
       */
      optsWithGlobals() {
        return this._getCommandAndAncestors().reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {Object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @api private
       */
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process2.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @api private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter((option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
          });
        });
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @api private
       */
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @api private
       */
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @api private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @api private
       */
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
          const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @api private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption) return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @api private
       */
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments) return;
        const expected = this.registeredArguments.length;
        const s = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      /**
       * Unknown command.
       *
       * @api private
       */
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias()) candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      /**
       * Get or set the program version.
       *
       * This method auto-registers the "-V, --version" option which will print the version number.
       *
       * You can optionally supply the flags and description to override the defaults.
       *
       * @param {string} [str]
       * @param {string} [flags]
       * @param {string} [description]
       * @return {this | string | undefined} `this` command for chaining, or version string if no arguments
       */
      version(str, flags, description) {
        if (str === void 0) return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {Object} [argsDescription]
       * @return {string|Command}
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0) return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {string|Command}
       */
      summary(str) {
        if (str === void 0) return this._summary;
        this._summary = str;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {string|Command}
       */
      alias(alias) {
        if (alias === void 0) return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name) throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {string[]|Command}
       */
      aliases(aliases) {
        if (aliases === void 0) return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {String|Command}
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage) return this._usage;
          const args = this.registeredArguments.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._hasHelpOption ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this.registeredArguments.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {string|Command}
       */
      name(str) {
        if (str === void 0) return this._name;
        this._name = str;
        return this;
      }
      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */
      nameFromFilename(filename) {
        this._name = path3.basename(filename, path3.extname(filename));
        return this;
      }
      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {string|null|Command}
       */
      executableDir(path4) {
        if (path4 === void 0) return this._executableDir;
        this._executableDir = path4;
        return this;
      }
      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      /**
       * @api private
       */
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        if (this._helpLongFlag) {
          this.emit(this._helpLongFlag);
        }
        this.emit("afterHelp", context);
        this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", context));
      }
      /**
       * You can pass in flags and a description to override the help
       * flags and help description for your command. Pass in false to
       * disable the built-in help option.
       *
       * @param {string | boolean} [flags]
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = splitOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process2.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {string | Function} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
    };
    function outputHelpIfRequested(cmd, args) {
      const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    exports2.Command = Command2;
  }
});

// node_modules/commander/index.js
var require_commander = __commonJS({
  "node_modules/commander/index.js"(exports2, module2) {
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports2 = module2.exports = new Command2();
    exports2.program = exports2;
    exports2.Command = Command2;
    exports2.Option = Option2;
    exports2.Argument = Argument2;
    exports2.Help = Help2;
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
    exports2.InvalidOptionArgumentError = InvalidArgumentError2;
  }
});

// node_modules/@babel/parser/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/parser/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t3 = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t3[n] = r[n];
      }
      return t3;
    }
    var Position = class {
      constructor(line, col, index) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index;
      }
    };
    var SourceLocation = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position, columnOffset) {
      const {
        line,
        column,
        index
      } = position;
      return new Position(line, column + columnOffset, index + columnOffset);
    }
    var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
    var StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      DynamicImportPhaseRequiresImportExpressions: ({
        phase
      }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsOptionalChaining: ({
        ancestor
      }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key
      }) => `Duplicate key "${key}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword
      }) => `Unexpected keyword '${keyword}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationExport: "Using declaration cannot be exported.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var PipelineOperatorErrors = Object.assign({
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token
      }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`
    }, {
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    });
    var _excluded = ["message"];
    function defineHidden(obj, key, value) {
      Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value
      });
    }
    function toParseErrorConstructor({
      toMessage,
      code: code2,
      reasonCode,
      syntaxPlugin
    }) {
      const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
      {
        const oldReasonCodes = {
          AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
          AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
          ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
          SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
          SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
          SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
        };
        if (oldReasonCodes[reasonCode]) {
          reasonCode = oldReasonCodes[reasonCode];
        }
      }
      return function constructor(loc, details) {
        const error = new SyntaxError();
        error.code = code2;
        error.reasonCode = reasonCode;
        error.loc = loc;
        error.pos = loc.index;
        error.syntaxPlugin = syntaxPlugin;
        if (hasMissingPlugin) {
          error.missingPlugin = details.missingPlugin;
        }
        defineHidden(error, "clone", function clone(overrides = {}) {
          var _overrides$loc;
          const {
            line,
            column,
            index
          } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
          return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
        });
        defineHidden(error, "details", details);
        Object.defineProperty(error, "message", {
          configurable: true,
          get() {
            const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
            this.message = message;
            return message;
          },
          set(value) {
            Object.defineProperty(this, "message", {
              value,
              writable: true
            });
          }
        });
        return error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      }
      const ParseErrorConstructors = {};
      for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const _ref = typeof template === "string" ? {
          message: () => template
        } : typeof template === "function" ? {
          message: template
        } : template, {
          message
        } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
        const toMessage = typeof message === "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: "BABEL_PARSER_SYNTAX_ERROR",
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    function createDefaultOptions() {
      return {
        sourceType: "script",
        sourceFilename: void 0,
        startIndex: 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowNewTargetOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createImportExpressions: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true,
        annexB: true
      };
    }
    function getOptions(opts) {
      const options = createDefaultOptions();
      if (opts == null) {
        return options;
      }
      if (opts.annexB != null && opts.annexB !== false) {
        throw new Error("The `annexB` option can only be set to `false`.");
      }
      for (const key of Object.keys(options)) {
        if (opts[key] != null) options[key] = opts[key];
      }
      if (options.startLine === 1) {
        if (opts.startIndex == null && options.startColumn > 0) {
          options.startIndex = options.startColumn;
        } else if (opts.startColumn == null && options.startIndex > 0) {
          options.startColumn = options.startIndex;
        }
      } else if (opts.startColumn == null || opts.startIndex == null) {
        if (opts.startIndex != null) {
          throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
        }
      }
      return options;
    }
    var {
      defineProperty
    } = Object;
    var toUnenumerable = (object, key) => {
      if (object) {
        defineProperty(object, key, {
          enumerable: false,
          value: object[key]
        });
      }
    };
    function toESTreeLocation(node) {
      toUnenumerable(node.loc.start, "index");
      toUnenumerable(node.loc.end, "index");
      return node;
    }
    var estree = (superClass) => class ESTreeParserMixin extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.optionFlags & 128) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (_) {
        }
        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags
        };
        return node;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      directiveToStmt(directive) {
        const expression = directive.value;
        delete directive.value;
        expression.type = "Literal";
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        const stmt = directive;
        stmt.type = "ExpressionStatement";
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
      }
      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
      parsePrivateName() {
        const node = super.parsePrivateName();
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node);
      }
      convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        node = node;
        delete node.id;
        node.name = name;
        node.type = "PrivateIdentifier";
        return node;
      }
      isPrivateName(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.isPrivateName(node);
          }
        }
        return node.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.getPrivateNameSV(node);
          }
        }
        return node.name;
      }
      parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        const {
          typeParameters
        } = node;
        if (typeParameters) {
          delete node.typeParameters;
          funcNode.typeParameters = typeParameters;
          this.resetStartLocationFromNode(funcNode, typeParameters);
        }
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        return this.finishNode(node, "MethodDefinition");
      }
      nameIsConstructor(key) {
        if (key.type === "Literal") return key.value === "constructor";
        return super.nameIsConstructor(key);
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          propertyNode.type = "PropertyDefinition";
        }
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          propertyNode.type = "PropertyDefinition";
        }
        propertyNode.computed = false;
        return propertyNode;
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
        if (node) {
          node.type = "Property";
          if (node.kind === "method") {
            node.kind = "init";
          }
          node.shorthand = false;
        }
        return node;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          node.type = "Property";
        }
        return node;
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          const {
            key,
            value
          } = node;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
          this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === "Property" && prop.method) {
          this.raise(Errors.PatternHasMethod, prop.key);
        } else {
          super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
      }
      finishCallExpression(unfinished, optional) {
        const node = super.finishCallExpression(unfinished, optional);
        if (node.callee.type === "Import") {
          var _ref, _ref2;
          node.type = "ImportExpression";
          node.source = node.arguments[0];
          node.options = (_ref = node.arguments[1]) != null ? _ref : null;
          node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
          delete node.arguments;
          delete node.callee;
        }
        return node;
      }
      toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node);
      }
      parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node = super.parseExport(unfinished, decorators);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              const {
                declaration
              } = node;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                this.resetStartLocation(node, exportStartLoc);
              }
            }
            break;
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const node = super.parseSubscript(base, startLoc, noCalls, state);
        if (state.optionalChainMember) {
          if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
            node.type = node.type.substring(8);
          }
          if (state.stop) {
            const chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
          node.optional = false;
        }
        return node;
      }
      isOptionalMemberExpression(node) {
        if (node.type === "ChainExpression") {
          return node.expression.type === "MemberExpression";
        }
        return super.isOptionalMemberExpression(node);
      }
      hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return super.hasPropertyAsPrivateName(node);
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
      }
      finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
      }
      resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc);
        toESTreeLocation(node);
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
      }
    };
    var TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", true)
    };
    {
      types.template = new TokContext("`", true);
    }
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        {
          this.updateContext = null;
        }
      }
    };
    var keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name, options = {}) {
      options.keyword = name;
      const token = createToken(name, options);
      keywords$1.set(name, token);
      return token;
    }
    function createBinop(name, binop) {
      return createToken(name, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name);
      tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
      tokenTypes.push(new ExportedTokenType(name, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$1.set(name, tokenTypeCounter);
      tokenLabels.push(name);
      tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
      tokenTypes.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _defer: createKeywordLike("defer", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _source: createKeywordLike("source", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _using: createKeywordLike("using", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      placeholder: createToken("%%", {
        startsExpr: true
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr: true
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
      }),
      jsxTagEnd: createToken("jsxTagEnd")
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 133;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 133;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 137;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 129 && token <= 131;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 121 && token <= 123;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 124 && token <= 130;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes[token];
    }
    {
      tokenTypes[8].updateContext = (context) => {
        context.pop();
      };
      tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
        context.push(types.brace);
      };
      tokenTypes[22].updateContext = (context) => {
        if (context[context.length - 1] === types.template) {
          context.pop();
        } else {
          context.push(types.template);
        }
      };
      tokenTypes[143].updateContext = (context) => {
        context.push(types.j_expr, types.j_oTag);
      };
    }
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code2, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code2) return false;
        pos += set[i + 1];
        if (pos >= code2) return true;
      }
      return false;
    }
    function isIdentifierStart(code2) {
      if (code2 < 65) return code2 === 36;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code2) {
      if (code2 < 48) return code2 === 36;
      if (code2 < 58) return true;
      if (code2 < 65) return false;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var Scope = class {
      constructor(flags) {
        this.flags = 0;
        this.names = /* @__PURE__ */ new Map();
        this.firstLexicalName = "";
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(parser, inModule) {
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.parser = parser;
        this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 128) {
            return true;
          }
          if (flags & (387 | 64)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
      }
      declareName(name, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 8 || bindingType & 16) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          let type = scope.names.get(name) || 0;
          if (bindingType & 16) {
            type = type | 4;
          } else {
            if (!scope.firstLexicalName) {
              scope.firstLexicalName = name;
            }
            type = type | 2;
          }
          scope.names.set(name, type);
          if (bindingType & 8) {
            this.maybeExportDefined(scope, name);
          }
        } else if (bindingType & 4) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            scope.names.set(name, (scope.names.get(name) || 0) | 1);
            this.maybeExportDefined(scope, name);
            if (scope.flags & 387) break;
          }
        }
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name);
        }
      }
      maybeExportDefined(scope, name) {
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name);
        }
      }
      checkRedeclarationInScope(scope, name, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name, bindingType)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name
          });
        }
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & 1)) return false;
        if (bindingType & 8) {
          return scope.names.has(name);
        }
        const type = scope.names.get(name);
        if (bindingType & 16) {
          return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
        }
        return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.names.has(name)) {
          this.undefinedExports.set(name, id.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 387) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (387 | 64) && !(flags & 4)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & 2048) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
          scope.declareFunctions.add(name);
          return;
        }
        super.declareName(name, bindingType, loc);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (super.isRedeclaredInScope(scope, name, bindingType)) return true;
        if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
          const type = scope.names.get(name);
          return (type & 4) > 0 || (type & 2) > 0;
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      sourceToOffsetPos(sourcePos) {
        return sourcePos + this.startIndex;
      }
      offsetToSourcePos(offsetPos) {
        return offsetPos - this.startIndex;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin, name) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
      }
    };
    function setTrailingComments(node, comments) {
      if (node.trailingComments === void 0) {
        node.trailingComments = comments;
      } else {
        node.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node, comments) {
      if (node.leadingComments === void 0) {
        node.leadingComments = comments;
      } else {
        node.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node, comments) {
      if (node.innerComments === void 0) {
        node.innerComments = comments;
      } else {
        node.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        if (this.filename) comment.loc.filename = this.filename;
        const {
          commentsLen
        } = this.state;
        if (this.comments.length !== commentsLen) {
          this.comments.length = commentsLen;
        }
        this.comments.push(comment);
        this.state.commentsLen++;
      }
      processComment(node) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node.end) {
          lastCommentWS.leadingNode = node;
          i--;
        }
        const {
          start: nodeStart
        } = node;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const {
            containingNode: node,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              case "TSEnumDeclaration":
                {
                  adjustInnerComments(node, node.members, commentWS);
                }
                break;
              case "TSEnumBody":
                adjustInnerComments(node, node.members, commentWS);
                break;
              default: {
                setInnerComments(node, comments);
              }
            }
          } else {
            setInnerComments(node, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0) return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node) {
          commentWS.leadingNode = null;
        }
      }
      resetPreviousIdentifierLeadingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0) return;
        if (commentStack[length - 1].trailingNode === node) {
          commentStack[length - 1].trailingNode = null;
        } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
          commentStack[length - 2].trailingNode = null;
        }
      }
      takeSurroundingComments(node, start, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node;
          } else if (commentEnd === start) {
            commentWS.trailingNode = node;
          } else if (commentEnd < start) {
            break;
          }
        }
      }
    };
    var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code2) {
      switch (code2) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    function hasNewLine(input, start, end) {
      for (let i = start; i < end; i++) {
        if (isNewLine(input.charCodeAt(i))) {
          return true;
        }
      }
      return false;
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    function isWhitespace(code2) {
      switch (code2) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var State = class _State {
      constructor() {
        this.flags = 1024;
        this.startIndex = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.labels = [];
        this.commentsLen = 0;
        this.commentStack = [];
        this.pos = 0;
        this.type = 140;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.context = [types.brace];
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      get strict() {
        return (this.flags & 1) > 0;
      }
      set strict(v) {
        if (v) this.flags |= 1;
        else this.flags &= -2;
      }
      init({
        strictMode,
        sourceType,
        startIndex,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.startIndex = startIndex;
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
      }
      get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
      }
      set maybeInArrowParameters(v) {
        if (v) this.flags |= 2;
        else this.flags &= -3;
      }
      get inType() {
        return (this.flags & 4) > 0;
      }
      set inType(v) {
        if (v) this.flags |= 4;
        else this.flags &= -5;
      }
      get noAnonFunctionType() {
        return (this.flags & 8) > 0;
      }
      set noAnonFunctionType(v) {
        if (v) this.flags |= 8;
        else this.flags &= -9;
      }
      get hasFlowComment() {
        return (this.flags & 16) > 0;
      }
      set hasFlowComment(v) {
        if (v) this.flags |= 16;
        else this.flags &= -17;
      }
      get isAmbientContext() {
        return (this.flags & 32) > 0;
      }
      set isAmbientContext(v) {
        if (v) this.flags |= 32;
        else this.flags &= -33;
      }
      get inAbstractClass() {
        return (this.flags & 64) > 0;
      }
      set inAbstractClass(v) {
        if (v) this.flags |= 64;
        else this.flags &= -65;
      }
      get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
      }
      set inDisallowConditionalTypesContext(v) {
        if (v) this.flags |= 128;
        else this.flags &= -129;
      }
      get soloAwait() {
        return (this.flags & 256) > 0;
      }
      set soloAwait(v) {
        if (v) this.flags |= 256;
        else this.flags &= -257;
      }
      get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
      }
      set inFSharpPipelineDirectBody(v) {
        if (v) this.flags |= 512;
        else this.flags &= -513;
      }
      get canStartJSXElement() {
        return (this.flags & 1024) > 0;
      }
      set canStartJSXElement(v) {
        if (v) this.flags |= 1024;
        else this.flags &= -1025;
      }
      get containsEsc() {
        return (this.flags & 2048) > 0;
      }
      set containsEsc(v) {
        if (v) this.flags |= 2048;
        else this.flags &= -2049;
      }
      get hasTopLevelAwait() {
        return (this.flags & 4096) > 0;
      }
      set hasTopLevelAwait(v) {
        if (v) this.flags |= 4096;
        else this.flags &= -4097;
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
      }
      clone() {
        const state = new _State();
        state.flags = this.flags;
        state.startIndex = this.startIndex;
        state.curLine = this.curLine;
        state.lineStart = this.lineStart;
        state.startLoc = this.startLoc;
        state.endLoc = this.endLoc;
        state.errors = this.errors.slice();
        state.potentialArrowAt = this.potentialArrowAt;
        state.noArrowAt = this.noArrowAt.slice();
        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
        state.topicContext = this.topicContext;
        state.labels = this.labels.slice();
        state.commentsLen = this.commentsLen;
        state.commentStack = this.commentStack.slice();
        state.pos = this.pos;
        state.type = this.type;
        state.value = this.value;
        state.start = this.start;
        state.end = this.end;
        state.lastTokEndLoc = this.lastTokEndLoc;
        state.lastTokStartLoc = this.lastTokStartLoc;
        state.context = this.context.slice();
        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
        state.strictErrors = this.strictErrors;
        state.tokensLength = this.tokensLength;
        return state;
      }
    };
    var _isDigit = function isDigit(code2) {
      return code2 >= 48 && code2 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code2;
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCharCode(code2));
        }
        case 117: {
          let code2;
          ({
            code: code2,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCodePoint(code2));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        if (code2 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code2 >= 97) {
          val = code2 - 97 + 10;
        } else if (code2 >= 65) {
          val = code2 - 65 + 10;
        } else if (_isDigit(code2)) {
          val = code2 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code2;
      if (ch === 123) {
        ++pos;
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code2 !== null && code2 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code2,
        pos
      };
    }
    function buildPosition(pos, lineStart, curLine) {
      return new Position(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var Token = class {
      constructor(state) {
        const startIndex = state.startIndex || 0;
        this.type = state.type;
        this.value = state.value;
        this.start = startIndex + state.start;
        this.end = startIndex + state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends CommentsParser {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
          invalidDigit: (pos, lineStart, curLine, radix) => {
            if (!(this.optionFlags & 1024)) return false;
            this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
          },
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
          }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
          }
        });
        this.state = new State();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.comments = [];
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.optionFlags & 128) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(140);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead) return;
        const comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end + commentEnd.length),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 128) this.pushToken(comment);
        return comment;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead) return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
          type: "CommentLine",
          value,
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 128) this.pushToken(comment);
        return comment;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = this.optionFlags & 2048 ? [] : null;
        loop: while (this.state.pos < this.length) {
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const comment = this.skipBlockComment("*/");
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                  break;
                }
                case 47: {
                  const comment = this.skipLineComment(2);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else if (ch === 45 && !this.inModule && this.optionFlags & 4096) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  const comment = this.skipLineComment(3);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else if (ch === 60 && !this.inModule && this.optionFlags & 4096) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                  const comment = this.skipLineComment(4);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else {
                break loop;
              }
          }
        }
        if ((comments == null ? void 0 : comments.length) > 0) {
          const end = this.state.pos;
          const commentWhitespace = {
            start: this.sourceToOffsetPos(spaceStart),
            end: this.sourceToOffsetPos(end),
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart(next)) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
      }
      readToken_mult_modulo(code2) {
        let type = code2 === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width++;
          type = code2 === 37 ? 33 : 30;
        }
        this.finishOp(type, width);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code2 === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code2 === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code2 === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code2 === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code2 === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code2) {
        switch (code2) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code2);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code2);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code2);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code2);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code2);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart(code2)) {
              this.readWord(code2);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
          unexpected: String.fromCodePoint(code2)
        });
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine(ch)) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        while (pos < this.length) {
          const cp = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (cp === 118) {
              if (mods.includes("u")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            } else if (cp === 117) {
              if (mods.includes("v")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            }
            if (mods.includes(char)) {
              this.raise(Errors.DuplicateRegExpFlags, nextPos());
            }
          } else if (isIdentifierChar(cp) || cp === 92) {
            this.raise(Errors.MalformedRegExpFlags, nextPos());
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(138, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {
          n,
          pos
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos;
        return n;
      }
      readRadixNumber(radix) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
            radix
          });
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(Errors.InvalidDecimal, startLoc);
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        if (isBigInt) {
          const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(136, str);
          return;
        }
        this.finishToken(135, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(Errors.InvalidNumber, this.state.curPosition());
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
          if (!this.state.strict) {
            const underscorePos = integer.indexOf("_");
            if (underscorePos > 0) {
              this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(Errors.InvalidOrMissingExponent, startLoc);
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(Errors.InvalidBigIntLiteral, startLoc);
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(Errors.InvalidDecimal, startLoc);
          }
          ++this.state.pos;
          var isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(136, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(137, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(135, val);
      }
      readCodePoint(throwOnInvalid) {
        const {
          code: code2,
          pos
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos;
        return code2;
      }
      readString(quote) {
        const {
          str,
          pos,
          curLine,
          lineStart
        } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(134, str);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
          str,
          firstInvalidLoc,
          pos,
          curLine,
          lineStart
        } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) {
          this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
        }
        if (this.input.codePointAt(pos) === 96) {
          this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
        } else {
          this.state.pos++;
          this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
        }
      }
      recordStrictModeErrors(toParseError, at) {
        const index = at.index;
        if (this.state.strict && !this.state.strictErrors.has(index)) {
          this.raise(toParseError, at);
        } else {
          this.state.strictErrors.set(index, [toParseError, at]);
        }
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(132, word);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
            reservedWord: tokenLabelName(type)
          });
        }
      }
      raise(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError(loc, details);
        if (!(this.optionFlags & 1024)) throw error;
        if (!this.isLookahead) this.state.errors.push(error);
        return error;
      }
      raiseOverwrite(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];
          if (error.loc.index === pos) {
            return errors[i] = toParseError(loc, details);
          }
          if (error.loc.index < pos) break;
        }
        return this.raise(toParseError, at, details);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
          expected: type ? tokenLabelName(type) : null
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
          return true;
        }
        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name) => this.hasPlugin(name))) {
          throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
            missingPlugin: pluginNames
          });
        }
      }
      errorBuilder(error) {
        return (pos, lineStart, curLine) => {
          this.raise(error, buildPosition(pos, lineStart, curLine));
        };
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.parser = parser;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name)) {
              current.undefinedPrivateNames.set(name, loc);
            }
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
              identifierName: name
            });
          }
        }
      }
      declarePrivateName(name, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name);
        if (elementType & 3) {
          const accessor = redefined && loneAccessors.get(name);
          if (accessor) {
            const oldStatic = accessor & 4;
            const newStatic = elementType & 4;
            const oldKind = accessor & 3;
            const newKind = elementType & 3;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined) loneAccessors.delete(name);
          } else if (!redefined) {
            loneAccessors.set(name, elementType);
          }
        }
        if (redefined) {
          this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
            identifierName: name
          });
        }
        privateNames.add(name);
        undefinedPrivateNames.delete(name);
      }
      usePrivateName(name, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name)) return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name, loc);
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name
          });
        }
      }
    };
    var ExpressionScope = class {
      constructor(type = 0) {
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
      }
      isCertainlyParameterDeclaration() {
        return this.type === 3;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, at) {
        const index = at.index;
        this.declarationErrors.set(index, [ParsingErrorClass, at]);
      }
      clearDeclarationError(index) {
        this.declarationErrors.delete(index);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [new ExpressionScope()];
        this.parser = parser;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, node) {
        const origin = node.loc.start;
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(toParseError, origin);
          } else {
            return;
          }
          scope = stack[--i];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, node) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        const origin = node.loc.start;
        if (scope.isCertainlyParameterDeclaration()) {
          this.parser.raise(error, origin);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(error, origin);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError(at) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === 2) {
            scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
          }
          scope = stack[--i];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration()) return;
        currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, loc);
          let i = stack.length - 2;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc.index);
            scope = stack[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key, value, enumerable = true) {
        if (!node) return;
        let {
          extra
        } = node;
        if (extra == null) {
          extra = {};
          node.extra = extra;
        }
        if (enumerable) {
          extra[key] = value;
        } else {
          Object.defineProperty(extra, key, {
            enumerable,
            value
          });
        }
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      }
      eatContextual(token) {
        if (this.isContextual(token)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
          if (toParseError != null) {
            throw this.raise(toParseError, this.state.startLoc);
          }
          this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
      }
      hasFollowingLineBreak() {
        return hasNewLine(this.input, this.state.end, this.nextTokenStart());
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
      }
      expect(type, loc) {
        if (!this.eat(type)) {
          this.unexpected(loc, type);
        }
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors) return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
        }
        if (doubleProtoLoc != null) {
          this.raise(Errors.DuplicateProto, doubleProtoLoc);
        }
        if (privateKeyLoc != null) {
          this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = 0;
        if (this.inModule) {
          paramFlags |= 2;
        }
        this.scope.enter(1);
        this.prodParam.enter(paramFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
      }
    };
    var Node = class {
      constructor(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if ((parser == null ? void 0 : parser.optionFlags) & 64) this.range = [pos, 0];
        if (parser != null && parser.filename) this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node(void 0, this.start, this.loc.start);
        const keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
            newNode[key] = this[key];
          }
        }
        return newNode;
      };
    }
    function clonePlaceholder(node) {
      return cloneIdentifier(node);
    }
    function cloneIdentifier(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra,
        name
      } = node;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.name = name;
      if (type === "Placeholder") {
        cloned.expectedNode = node.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra
      } = node;
      if (type === "Placeholder") {
        return clonePlaceholder(node);
      }
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      if (node.raw !== void 0) {
        cloned.raw = node.raw;
      } else {
        cloned.extra = extra;
      }
      cloned.value = node.value;
      return cloned;
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        const loc = this.state.startLoc;
        return new Node(this, loc.index, loc);
      }
      startNodeAt(loc) {
        return new Node(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.optionFlags & 64) node.range[1] = endLoc.index;
        if (this.optionFlags & 2048) {
          this.processComment(node);
        }
        return node;
      }
      resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        if (this.optionFlags & 64) node.range[0] = startLoc.index;
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.optionFlags & 64) node.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitialized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      const list1 = [];
      const list2 = [];
      for (let i = 0; i < list.length; i++) {
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      }
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class FlowParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      finishToken(type, val) {
        if (type !== 134 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches) ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(110);
        if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
        }
        if (this.eat(10)) {
          node.value = super.parseExpression();
          this.expect(11);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, 2048, node.id.loc.start);
        return this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual(127)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual(130)) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual(131)) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          this.unexpected();
        }
      }
      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, 5, node.id.loc.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(0);
        if (this.match(134)) {
          node.id = super.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }
        const bodyNode = node.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          let bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(130) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
            }
            super.parseImport(bodyNode2);
          } else {
            this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
            const label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
            node = this.parseExport(node, null);
            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }
            node.type = "Declare" + node.type;
            return node;
          }
        }
        this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual(111);
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        const finished = this.flowParseTypeAlias(node);
        finished.type = "DeclareTypeAlias";
        return finished;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        const finished = this.flowParseOpaqueType(node, true);
        finished.type = "DeclareOpaqueType";
        return finished;
      }
      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (isClass) {
          node.implements = [];
          node.mixins = [];
          if (this.eatContextual(117)) {
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.eatContextual(113)) {
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
          reservedType: word
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        this.expectContextual(130);
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(14)) {
          node.supertype = this.flowParseTypeInitialiser(14);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
          }
        }
        return this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
      flowInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      flowParseTypeParameterInstantiationInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.flowParseTypeParameterInstantiation();
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        this.state.inType = true;
        node.params = [];
        this.flowInTopLevelContext(() => {
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        });
        this.state.inType = oldInType;
        if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        if (this.reScan_lt() !== 47) return;
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual(129);
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;
        if (this.lookahead().type === 14) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(3);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
        } else {
          node.method = false;
          if (this.eat(17)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node = this.startNode();
          if (allowProto && this.isContextual(118)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(106)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, variance);
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, variance);
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStartLoc != null;
          node.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === "get" ? 0 : 1;
        const length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value.this) {
          this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
        }
        if (length !== paramCount) {
          this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(Errors.BadSetterRestParameter, property);
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startLoc, id) {
        var _startLoc;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node2 = this.startNodeAt(startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startLoc, id) {
        const node = this.startNodeAt(startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(87);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node.types.push(this.flowParseType());
          if (this.match(3)) break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name = null;
        let optional = false;
        let typeAnnotation = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node);
          }
          name = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47: {
            const node2 = this.startNode();
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 10: {
            const node2 = this.startNode();
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            node2.typeParameters = null;
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 134:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node.value = this.match(85);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(135)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(136)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            this.unexpected();
            return;
          case 135:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 136:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(129)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
            }
        }
        this.unexpected();
      }
      flowParsePostfixType() {
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        if (this.eat(17)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node = this.startNodeAt(param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(45)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(43)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          return;
        }
        super.parseFunctionBody(node, false, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          const lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        const stmt = super.parseStatementLike(flags);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [node];
        const arrows = [];
        while (stack.length !== 0) {
          const node2 = stack.pop();
          if (node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement") {
            if (node2.typeParameters || !node2.returnType) {
              this.finishArrowValidation(node2);
            } else {
              arrows.push(node2);
            }
            stack.push(node2.body);
          } else if (node2.type === "ConditionalExpression") {
            stack.push(node2.consequent);
            stack.push(node2.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node2) => this.finishArrowValidation(node2));
          return [arrows, []];
        }
        return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(2 | 4);
        super.checkParams(node, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse3) {
        let result;
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse3();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse3();
        }
        return result;
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = newNode;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return newNode;
      }
      assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node);
      }
      parseExportDeclaration(node) {
        if (this.isContextual(130)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node.specifiers = this.parseExportSpecifiers(true);
            super.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(131)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(129)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.isContextual(126)) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }
      eatExportStar(node) {
        if (super.eatExportStar(node)) return true;
        if (this.isContextual(130) && this.lookahead().type === 55) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, startLoc);
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
            identifierName: fullWord
          });
        }
        this.finishToken(132, fullWord);
      }
      getTokenFromCode(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 123 && next === 124) {
          this.finishOp(6, 2);
        } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
          this.finishOp(code2 === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code2 === 63) {
          if (next === 46) {
            this.finishOp(18, 2);
          } else {
            this.finishOp(17, 1);
          }
        } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          this.readIterator();
        } else {
          super.getTokenFromCode(code2);
        }
      }
      isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
          node.left = this.typeCastToParameter(node.left);
        }
        super.toAssignable(node, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
          }
        }
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
      }
      parseClassProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          {
            node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        if (this.isContextual(113)) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
          }
        }
      }
      parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10)) this.unexpected();
        }
        const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, param);
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, param);
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, param);
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
        }
        return node;
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          if (!isExport) return true;
          const ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          if (!phase && this.match(65)) {
            return;
          }
          node.exportKind = phase === "type" ? phase : "value";
        } else {
          if (phase === "type" && this.match(55)) this.unexpected();
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, specifier, {
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, isConstructor) {
        const kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression") abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon()) this.unexpected();
            if (!this.match(19)) this.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          return;
        }
        for (let i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
          }
        }
        super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.arguments = super.parseCallExpressionArguments(11);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error) return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          this.expect(10);
          node.arguments = this.parseCallExpressionArguments(11);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node.arguments = super.parseCallExpressionArguments(11);
            if (subscriptState.optionalChainMember) {
              node.optional = false;
            }
            return this.finishCallExpression(node, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node) {
        super.parseNewCallee(node);
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.parseFunctionParams(node, false);
        if (!this.parseArrow(node)) return;
        return super.parseArrowExpression(node, void 0, true);
      }
      readToken_mult_modulo(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code2);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code2);
      }
      parseTopLevel(file, program3) {
        const fileNode = super.parseTopLevel(file, program3);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
          }
          this.hasFlowCommentCompletion();
          const commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
      }
      flowEnumErrorNumberMemberNotInitialized(loc, details) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 135: {
            const literal = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 134: {
            const literal = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id = this.parseIdentifier(true);
        const init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, id, {
              memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, id, {
              memberName,
              enumName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(102)) return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
            enumName
          });
        }
        const {
          value
        } = this.state;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
            enumName,
            invalidEnumType: value
          });
        }
        return value;
      }
      flowEnumBody(node, id) {
        const enumName = id.name;
        const nameLoc = id.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node, "EnumSymbolBody");
          default: {
            const empty = () => {
              node.members = [];
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            };
            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                enumName
              });
              return empty();
            }
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node, "EnumDeclaration");
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.shouldParseTypes()) {
          if (this.match(47) || this.match(51)) {
            node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class JSXParserMixin extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  this.finishToken(143);
                } else {
                  super.getTokenFromCode(ch);
                }
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(142, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(134, out);
      }
      jsxReadEntity() {
        const startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          const codePoint = this.readInt(radix, void 0, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          let count = 0;
          let semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
            ++this.state.pos;
          }
          if (semi) {
            const desc = this.input.slice(startPos, this.state.pos);
            const entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        this.finishToken(141, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        if (this.match(141)) {
          node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        if (!this.eat(14)) return name;
        const node = this.startNodeAt(startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case 5:
            node = this.startNode();
            this.setContext(types.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types.j_oTag);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, node);
            }
            return node;
          case 143:
          case 134:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        if (this.match(5)) {
          this.setContext(types.brace);
          this.next();
          this.expect(21);
          node.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        while (!this.match(56) && !this.match(144)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(144);
        return this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(144);
        return this.finishNode(node, "JSXClosingElement");
      }
      jsxParseElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents: for (; ; ) {
            switch (this.state.type) {
              case 143:
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 142:
                children.push(this.parseLiteral(this.state.value, "JSXText"));
                break;
              case 5: {
                const node2 = this.startNode();
                this.setContext(types.brace);
                this.next();
                if (this.match(21)) {
                  children.push(this.jsxParseSpreadChild(node2));
                } else {
                  children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                }
                break;
              }
              default:
                this.unexpected();
            }
          }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(143)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(143);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace) super.skipSpace();
      }
      getTokenFromCode(code2) {
        const context = this.curContext();
        if (context === types.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart(code2)) {
            this.jsxReadWord();
            return;
          }
          if (code2 === 62) {
            ++this.state.pos;
            this.finishToken(144);
            return;
          }
          if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
            this.jsxReadString(code2);
            return;
          }
        }
        if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          this.finishToken(143);
          return;
        }
        super.getTokenFromCode(code2);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 143) {
          context.splice(-2, 2, types.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 143) {
          context.push(types.j_oTag);
        } else if (type === 144) {
          const out = context[context.length - 1];
          if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
          } else {
            this.setContext(types.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.tsNames = /* @__PURE__ */ new Map();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args);
        this.importsStack = [];
      }
      createScope(flags) {
        this.importsStack.push(/* @__PURE__ */ new Set());
        return new TypeScriptScope(flags);
      }
      enter(flags) {
        if (flags === 256) {
          this.importsStack.push(/* @__PURE__ */ new Set());
        }
        super.enter(flags);
      }
      exit() {
        const flags = super.exit();
        if (flags === 256) {
          this.importsStack.pop();
        }
        return flags;
      }
      hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name)) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].has(name)) return true;
          }
        }
        return false;
      }
      declareName(name, bindingType, loc) {
        if (bindingType & 4096) {
          if (this.hasImport(name, true)) {
            this.parser.raise(Errors.VarRedeclaration, loc, {
              identifierName: name
            });
          }
          this.importsStack[this.importsStack.length - 1].add(name);
          return;
        }
        const scope = this.currentScope();
        let type = scope.tsNames.get(name) || 0;
        if (bindingType & 1024) {
          this.maybeExportDefined(scope, name);
          scope.tsNames.set(name, type | 16);
          return;
        }
        super.declareName(name, bindingType, loc);
        if (bindingType & 2) {
          if (!(bindingType & 1)) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
          }
          type = type | 1;
        }
        if (bindingType & 256) {
          type = type | 2;
        }
        if (bindingType & 512) {
          type = type | 4;
        }
        if (bindingType & 128) {
          type = type | 8;
        }
        if (type) scope.tsNames.set(name, type);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        const type = scope.tsNames.get(name);
        if ((type & 2) > 0) {
          if (bindingType & 256) {
            const isConst = !!(bindingType & 512);
            const wasConst = (type & 4) > 0;
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & 128 && (type & 8) > 0) {
          if (scope.names.get(name) & 2) {
            return !!(bindingType & 1);
          } else {
            return false;
          }
        }
        if (bindingType & 2 && (type & 1) > 0) {
          return true;
        }
        return super.isRedeclaredInScope(scope, name, bindingType);
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        if (this.hasImport(name)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          const type = scope.tsNames.get(name);
          if ((type & 1) > 0 || (type & 16) > 0) {
            return;
          }
        }
        super.checkLocalExport(id);
      }
    };
    var unwrapParenthesizedExpression = (node) => {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
            } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
              this.raise(Errors.InvalidParenthesizedAssignment, node);
            }
          } else {
            this.raise(Errors.InvalidParenthesizedAssignment, node);
          }
        }
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              const prop = node.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
          case "SpreadElement": {
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          }
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        } else if (prop.type === "SpreadElement") {
          prop.type = "RestElement";
          const arg = prop.argument;
          this.checkToRestConversion(arg, false);
          this.toAssignable(arg, isLHS);
          if (!isLast) {
            this.raise(Errors.RestTrailingComma, prop);
          }
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for (let i = 0; i <= end; i++) {
          const elt = exprList[i];
          if (!elt) continue;
          if (elt.type === "SpreadElement") {
            elt.type = "RestElement";
            const arg = elt.argument;
            this.checkToRestConversion(arg, true);
            this.toAssignable(arg, isLHS);
          } else {
            this.toAssignable(elt, isLHS);
          }
          if (elt.type === "RestElement") {
            if (i < end) {
              this.raise(Errors.RestTrailingComma, elt);
            } else if (trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, trailingCommaLoc);
            }
          }
        }
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, 1);
            return this.finishNode(node, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(21)) {
            let rest = this.parseRestBinding();
            if (this.hasPlugin("flow") || flags & 2) {
              rest = this.parseFunctionParamType(rest);
            }
            elts.push(rest);
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            if (this.match(26) && this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
            elts.push(this.parseAssignableListItem(flags, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const {
          type,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(this.startNode());
        }
        const prop = this.startNode();
        if (type === 139) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
      }
      parseAssignableListItem(flags, decorators) {
        const left = this.parseMaybeDefault();
        if (this.hasPlugin("flow") || flags & 2) {
          this.parseFunctionParamType(left);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseFunctionParamType(param) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        var _startLoc, _left;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(29)) return left;
        const node = this.startNodeAt(startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "AssignmentPattern":
            return "left";
          case "RestElement":
            return "argument";
          case "ObjectProperty":
            return "value";
          case "ParenthesizedExpression":
            return "expression";
          case "ArrayPattern":
            return "elements";
          case "ObjectPattern":
            return "properties";
        }
        return false;
      }
      isOptionalMemberExpression(expression) {
        return expression.type === "OptionalMemberExpression";
      }
      checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression)) return;
        const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
        if (isOptionalMemberExpression || type === "MemberExpression") {
          if (isOptionalMemberExpression) {
            this.expectPlugin("optionalChainingAssign", expression.loc.start);
            if (ancestor.type !== "AssignmentExpression") {
              this.raise(Errors.InvalidLhsOptionalChaining, expression, {
                ancestor
              });
            }
          }
          if (binding !== 64) {
            this.raise(Errors.InvalidPropertyBindingPattern, expression);
          }
          return;
        }
        if (type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged);
          const {
            name
          } = expression;
          if (checkClashes) {
            if (checkClashes.has(name)) {
              this.raise(Errors.ParamDupe, expression);
            } else {
              checkClashes.add(name);
            }
          }
          return;
        }
        const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true) return;
        if (validity === false) {
          const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, expression, {
            ancestor
          });
          return;
        }
        let key, isParenthesizedExpression;
        if (typeof validity === "string") {
          key = validity;
          isParenthesizedExpression = type === "ParenthesizedExpression";
        } else {
          [key, isParenthesizedExpression] = validity;
        }
        const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
          type
        } : ancestor;
        const val = expression[key];
        if (Array.isArray(val)) {
          for (const child of val) {
            if (child) {
              this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
            }
          }
        } else if (val) {
          this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
        }
      }
      checkIdentifier(at, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
          if (bindingType === 64) {
            this.raise(Errors.StrictEvalArguments, at, {
              referenceName: at.name
            });
          } else {
            this.raise(Errors.StrictEvalArgumentsBinding, at, {
              bindingName: at.name
            });
          }
        }
        if (bindingType & 8192 && at.name === "let") {
          this.raise(Errors.LetInLexicalBinding, at);
        }
        if (!(bindingType & 64)) {
          this.declareNameFromIdentifier(at, bindingType);
        }
      }
      declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern) break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, node);
        }
      }
      checkCommaAfterRest(close) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
        return true;
      }
    };
    function nonNull(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token
      }) => `'${token}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers
      }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
    });
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
      }
      tsNextTokenOnSameLineAndCanFollowModifier() {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          return false;
        }
        return this.tsTokenCanFollowModifier();
      }
      tsNextTokenCanFollowModifier() {
        if (this.match(106)) {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        return this.tsNextTokenOnSameLineAndCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.includes(modifier)) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers({
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, loc, {
              orderedModifiers: [before, after]
            });
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, loc, {
              modifiers: [mod1, mod2]
            });
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, startLoc, {
              modifier
            });
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStartLoc.index;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(134)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
          {
            node.argument = super.parseExprAtom();
          }
        } else {
          {
            node.argument = this.parseStringLiteral(this.state.value);
          }
        }
        if (this.eat(12) && !this.match(11)) {
          node.options = super.parseMaybeAssignAllowIn();
          this.eat(12);
        } else {
          node.options = null;
        }
        this.expect(11);
        if (this.eat(16)) {
          node.qualifier = this.tsParseEntityName(1 | 2);
        }
        if (this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseEntityName(flags) {
        let entity;
        if (flags & 1 && this.match(78)) {
          if (flags & 2) {
            entity = this.parseIdentifier(true);
          } else {
            const node = this.startNode();
            this.next();
            entity = this.finishNode(node, "ThisExpression");
          }
        } else {
          entity = this.parseIdentifier(!!(flags & 1));
        }
        while (this.eat(16)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(!!(flags & 1));
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName(1);
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node.exprName = this.tsParseImportType();
        } else {
          {
            node.exprName = this.tsParseEntityName(1 | 2);
          }
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter(parseModifiers) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node.default = this.tsEatThenParseType(29);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, node);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        const list = super.parseBindingList(11, 41, 2);
        for (const pattern of list) {
          const {
            type
          } = pattern;
          if (type === "AssignmentPattern" || type === "TSParameterProperty") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
              type
            });
          }
        }
        return list;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return;
        }
        this.expect(0);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17)) node.optional = true;
        const nodeAny = node;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, node);
          }
          const method = nodeAny;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, this.state.curPosition());
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, this.state.curPosition());
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly) property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(77)) {
          const id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node);
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        super.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          super.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(122);
        }
        if (this.isContextual(122)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual(122);
        } else if (this.eatContextual(122)) {
          node.readonly = true;
        }
        this.expect(0);
        {
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsExpectThenParseType(58);
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        }
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        node.elementTypes.forEach((elementNode) => {
          const {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        const restStartLoc = this.state.startLoc;
        const rest = this.eat(21);
        const {
          startLoc
        } = this.state;
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58) {
          labeled = true;
          optional = false;
          label = this.parseIdentifier(true);
          this.expect(14);
          type = this.tsParseType();
        } else if (chAfterWord === 63) {
          optional = true;
          const wordName = this.state.value;
          const typeOrLabel = this.tsParseNonArrayType();
          if (this.lookaheadCharCode() === 58) {
            labeled = true;
            label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
            this.expect(17);
            this.expect(14);
            type = this.tsParseType();
          } else {
            labeled = false;
            type = typeOrLabel;
            this.expect(17);
          }
        } else {
          type = this.tsParseType();
          optional = this.eat(17);
          labeled = this.eat(14);
        }
        if (labeled) {
          let labeledNode;
          if (label) {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            labeledNode.label = label;
            labeledNode.elementType = type;
            if (this.eat(17)) {
              labeledNode.optional = true;
              this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
            }
          } else {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            this.raise(TSErrors.InvalidTupleMemberLabel, type);
            labeledNode.label = type;
            labeledNode.elementType = this.tsParseType();
          }
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAt(startLoc);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(restStartLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
        return this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        switch (this.state.type) {
          case 135:
          case 136:
          case 134:
          case 85:
          case 86:
            node.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        {
          const node = this.startNode();
          node.literal = super.parseTemplate(false);
          return this.finishNode(node, "TSLiteralType");
        }
      }
      parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 134:
          case 135:
          case 136:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 135 && nextToken.type !== 136) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        const {
          startLoc
        } = this.state;
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node = this.startNodeAt(startLoc);
            node.elementType = type;
            this.expect(3);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAt(startLoc);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(115);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            super.parseBindingList(3, 93, 1);
            return errors.length === previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t3 = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t3.typeAnnotation = thisTypePredicate;
            return this.finishNode(t3, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t3);
            }
            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t3.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t3, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t3.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t3, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeAnnotation();
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
            reservedWord: "asserts"
          });
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t3 = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(14);
          t3.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t3, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && this.lookahead().type === 77;
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        const node = this.startNode();
        node.typeAnnotation = this.tsInType(() => {
          this.next();
          return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node = this.startNode();
          {
            node.expression = this.tsParseEntityName(1 | 2);
            if (this.match(47)) {
              node.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node, "TSExpressionWithTypeArguments");
          }
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
            token
          });
        }
        return delimitedList;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual(129);
        if (properties.declare) node.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, 130);
        } else {
          node.id = null;
          this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (this.eat(81)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, 2);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
          this.expect(29);
          if (this.isContextual(114) && this.lookahead().type !== 16) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token) {
        if (this.match(token)) {
          return this.tsNextThenParseType();
        }
      }
      tsExpectThenParseType(token) {
        return this.tsInType(() => {
          this.expect(token);
          return this.tsParseType();
        });
      }
      tsNextThenParseType() {
        return this.tsInType(() => {
          this.next();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node.initializer = super.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const) node.const = true;
        if (properties.declare) node.declare = true;
        this.expectContextual(126);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node.const ? 8971 : 8459);
        {
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
        }
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseEnumBody() {
        const node = this.startNode();
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumBody");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(0);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node.id, 1024);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(112)) {
          node.kind = "global";
          {
            node.global = true;
          }
          node.id = this.parseIdentifier();
        } else if (this.match(134)) {
          node.kind = "module";
          node.id = super.parseStringLiteral(this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
        {
          node.isExport = isExport || false;
        }
        node.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node.id, 4096);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        if (!this.match(134)) {
          this.unexpected();
        }
        node.expression = super.parseExprAtom();
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node) return;
        if (result.error) this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        }
        this.state = state;
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let startType = this.state.type;
        let kind;
        if (this.isContextual(100)) {
          startType = 74;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          switch (startType) {
            case 68:
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, false);
            case 80:
              nany.declare = true;
              return this.parseClass(nany, true, false);
            case 126:
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            case 75:
            case 74:
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            case 129: {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result) return result;
            }
            default:
              if (tokenIsIdentifier(startType)) {
                return this.tsParseDeclaration(nany, this.state.value, true, null);
              }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      }
      tsParseExpressionStatement(node, expr, decorators) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) {
              declaration.declare = true;
            }
            return declaration;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(256);
              this.prodParam.enter(0);
              const mod = node;
              mod.kind = "global";
              {
                node.global = true;
              }
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node, expr.name, false, decorators);
        }
      }
      tsParseDeclaration(node, value, next, decorators) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node, decorators);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(134)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                node.kind = "module";
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              node.kind = "namespace";
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47)) return;
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) return;
        return super.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() => this.tsInTopLevelContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, node);
        } else if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(flags, decorators) {
        const startLoc = this.state.startLoc;
        const modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        const accessibility = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        if (!(flags & 4) && (accessibility || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        const left = this.parseMaybeDefault();
        if (flags & 2) {
          this.parseFunctionParamType(left);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility || readonly || override) {
          const pp = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;
          if (override) pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      isSimpleParameter(node) {
        return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
      }
      tsDisallowOptionalPattern(node) {
        for (const param of node.params) {
          if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
            this.raise(TSErrors.PatternIsOptional, param);
          }
        }
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, node);
          if (node.declare) {
            return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
          }
        }
        this.tsDisallowOptionalPattern(node);
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkIdentifier(node.id, 1024);
        } else {
          super.registerFunctionStatementId(node);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              {
                result2.typeParameters = typeArguments;
              }
              return result2;
            }
            if (!noCalls && this.eat(10)) {
              const node2 = this.startNodeAt(startLoc);
              node2.callee = base;
              node2.arguments = this.parseCallExpressionArguments(11);
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              {
                node2.typeParameters = typeArguments;
              }
              if (state.optionalChainMember) {
                node2.optional = isOptionalCall;
              }
              return this.finishCallExpression(node2, state.optionalChainMember);
            }
            const tokenType = this.state.type;
            if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
              return;
            }
            const node = this.startNodeAt(startLoc);
            node.expression = base;
            {
              node.typeParameters = typeArguments;
            }
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
              this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
            }
            return result;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node) {
        var _callee$extra;
        super.parseNewCallee(node);
        const {
          callee
        } = node;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          {
            node.typeParameters = callee.typeParameters;
          }
          node.callee = callee.expression;
        }
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          const node = this.startNodeAt(leftStartLoc);
          node.expression = left;
          node.typeAnnotation = this.tsInType(() => {
            this.next();
            if (this.match(75)) {
              if (isSatisfies) {
                this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                  keyword: "const"
                });
              }
              return this.tsParseTypeReference();
            }
            return this.tsParseType();
          });
          this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          const ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          node.exportKind = phase === "type" ? "type" : "value";
        } else {
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImport(node) {
        if (this.match(134)) {
          node.importKind = "value";
          return super.parseImport(node);
        }
        let importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
          node.importKind = "value";
          return this.tsParseImportEqualsDeclaration(node);
        } else if (this.isContextual(130)) {
          const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
          if (this.lookaheadCharCode() === 61) {
            return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
          } else {
            importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
          }
        } else {
          importNode = super.parseImport(node);
        }
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        return importNode;
      }
      parseExport(node, decorators) {
        if (this.match(83)) {
          const nodeImportEquals = node;
          this.next();
          let maybeDefaultIdentifier = null;
          if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
            maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
          } else {
            nodeImportEquals.importKind = "value";
          }
          const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
          {
            return declaration;
          }
        } else if (this.eat(29)) {
          const assign = node;
          assign.expression = super.parseExpression();
          this.semicolon();
          this.sawUnambiguousESM = true;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl = node;
          this.expectContextual(128);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          return super.parseExport(node, decorators);
        }
      }
      isAbstractClass() {
        return this.isContextual(124) && this.lookahead().type === 80;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const {
          isAmbientContext
        } = this.state;
        const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext) return declaration;
        for (const {
          id,
          init
        } of declaration.declarations) {
          if (!init) continue;
          if (kind !== "const" || !!id.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
          } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
            this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
          }
        }
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(75);
          return this.tsParseEnumDeclaration(node, {
            const: true
          });
        }
        if (this.isContextual(126)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.isContextual(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
            }
            super.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, member);
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, member);
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, member);
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, member);
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
      }
      parseExpressionStatement(node, expr, decorators) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
        return decl || super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.state.maybeInArrowParameters || !this.match(17)) {
          return super.parseConditional(expr, startLoc, refExpressionErrors);
        }
        const result = this.tryParse(() => super.parseConditional(expr, startLoc));
        if (!result.node) {
          if (result.error) {
            super.setOptionalParametersError(refExpressionErrors, result.error);
          }
          return expr;
        }
        if (result.error) this.state = result.failState;
        return result.node;
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(125)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        const isIdentifier = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        if (!declaration) return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(113)) {
          return;
        }
        super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (typeParameters) node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.eat(35)) {
            node.definite = true;
          } else if (this.eat(17)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }
      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        if (node.abstract && this.match(29)) {
          const {
            key
          } = node;
          this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
            propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
          });
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, node);
        }
        if (node.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, node, {
            modifier: node.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }
      parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (node.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, node);
        }
        return super.parseClassAccessorProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        const {
          declare = false,
          kind
        } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, method, {
            kind
          });
        }
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node, kind) {
        if (node.type === "TSDeclareMethod") return;
        if (node.type === "MethodDefinition" && !hasOwnProperty.call(node.value, "body")) {
          return;
        }
        super.declareClassPrivateMethodInScope(node, kind);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
        }
        if (this.eatContextual(113)) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) prop.typeParameters = typeParameters;
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state) state = this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx2) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!typeCast.error) return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      }
      reportReservedArrowTypeParam(node) {
        var _node$extra;
        if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, node);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        }
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19)) abort();
            return returnType;
          });
          if (result.aborted) return;
          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return super.parseArrow(node);
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
            }
            this.toAssignable(node.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
          default:
            super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isLHS);
            break;
          default:
            super.toAssignable(node, isLHS);
        }
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node.expression, false);
            break;
          default:
            super.checkToRestConversion(node, allowPattern);
        }
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "TSTypeCastExpression":
            return true;
          case "TSParameterProperty":
            return "parameter";
          case "TSNonNullExpression":
          case "TSInstantiationExpression":
            return "expression";
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
            return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true];
          default:
            return super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
      }
      parseBindingAtom() {
        if (this.state.type === 78) {
          return this.parseIdentifier(true);
        }
        return super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call = super.parseMaybeDecoratorArguments(expr, startLoc);
            {
              call.typeParameters = typeArguments;
            }
            return call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr, startLoc);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        }
        return super.checkCommaAfterRest(close);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
        }
        return node;
      }
      getTokenFromCode(code2) {
        if (this.state.inType) {
          if (code2 === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code2 === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        super.getTokenFromCode(code2);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments) {
            {
              node.typeParameters = typeArguments;
            }
          }
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const {
          isAmbientContext: oldIsAmbientContext,
          strict: oldStrict
        } = this.state;
        this.state.isAmbientContext = true;
        this.state.strict = false;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
          this.state.strict = oldStrict;
        }
      }
      parseClass(node, isStatement, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80)) {
          node.abstract = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, 80);
        }
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if (method.abstract) {
          const hasEstreePlugin = this.hasPlugin("estree");
          const methodFn = hasEstreePlugin ? method.value : method;
          if (methodFn.body) {
            const {
              key
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, method, {
              methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
            });
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
          return this.finishNode(node, "ExportSpecifier");
        }
        node.exportKind = "value";
        return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression") return false;
      const {
        computed,
        property
      } = expression;
      if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    function isValidAmbientConstInitializer(expression, estree2) {
      var _expression$extra;
      const {
        type
      } = expression;
      if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
        return false;
      }
      if (estree2) {
        if (type === "Literal") {
          const {
            value
          } = expression;
          if (typeof value === "string" || typeof value === "boolean") {
            return true;
          }
        }
      } else {
        if (type === "StringLiteral" || type === "BooleanLiteral") {
          return true;
        }
      }
      if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
        return true;
      }
      if (type === "TemplateLiteral" && expression.expressions.length === 0) {
        return true;
      }
      if (isPossiblyLiteralEnum(expression)) {
        return true;
      }
      return false;
    }
    function isNumber(expression, estree2) {
      if (estree2) {
        return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
      }
      return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression, estree2) {
      if (expression.type === "UnaryExpression") {
        const {
          operator,
          argument
        } = expression;
        if (operator === "-" && isNumber(argument, estree2)) {
          return true;
        }
      }
      return false;
    }
    function isUncomputedMemberExpressionChain(expression) {
      if (expression.type === "Identifier") return true;
      if (expression.type !== "MemberExpression" || expression.computed) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(133)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace();
          node.name = super.parseIdentifier(true);
          this.assertNoSpace();
          this.expect(133);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        let placeholder = node;
        if (!placeholder.expectedNode || !placeholder.type) {
          placeholder = this.finishNode(placeholder, "Placeholder");
        }
        placeholder.expectedNode = expectedNode;
        return placeholder;
      }
      getTokenFromCode(code2) {
        if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          this.finishOp(133, 2);
        } else {
          super.getTokenFromCode(code2);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word !== void 0) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
      }
      toAssignable(node, isLHS) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
          return true;
        }
        const nextToken = this.lookahead();
        if (nextToken.type === 133) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node, isBreak) {
        if (node.label && node.label.type === "Placeholder") return;
        super.verifyBreakContinue(node, isBreak);
      }
      parseExpressionStatement(node, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          return super.parseExpressionStatement(node, expr);
        }
        if (this.match(14)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        const stmtPlaceholder = node;
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(133) || this.match(5)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }
        super.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }
      parseExport(node, decorators) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseExport(node, decorators);
        const node2 = node;
        if (!this.isContextual(98) && !this.match(12)) {
          node2.specifiers = [];
          node2.source = null;
          node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node2, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        var _specifiers;
        if ((_specifiers = node.specifiers) != null && _specifiers.length) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
      }
      checkExport(node) {
        const {
          specifiers
        } = node;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
        }
        super.checkExport(node);
        node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseImport(node);
        node.specifiers = [];
        if (!this.isContextual(98) && !this.match(12)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual(98);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
          this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
      }
    };
    var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name = this.parseIdentifierName();
            const identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    };
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    function validatePlugins(pluginsMap) {
      if (pluginsMap.has("decorators")) {
        if (pluginsMap.has("decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        }
        const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (pluginsMap.has("pipelineOperator")) {
        var _pluginsMap$get;
        const proposal = pluginsMap.get("pipelineOperator").proposal;
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const tupleSyntaxIsHash = ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash";
        if (proposal === "hack") {
          if (pluginsMap.has("placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (pluginsMap.has("v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = pluginsMap.get("pipelineOperator").topicToken;
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t3) => `"${t3}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
        }
      }
      if (pluginsMap.has("moduleAttributes")) {
        {
          if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
            throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
          }
          const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
          if (moduleAttributesVersionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (pluginsMap.has("importAssertions")) {
        if (pluginsMap.has("deprecatedImportAssert")) {
          throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
        }
      }
      if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
        {
          pluginsMap.set("deprecatedImportAssert", {});
        }
      }
      if (pluginsMap.has("recordAndTuple")) {
        const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
        if (syntaxType != null) {
          {
            const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
            if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
            }
          }
        }
      }
      if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
      if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return;
        }
        const key = prop.key;
        const name = key.type === "Identifier" ? key.name : key.value;
        if (name === "__proto__") {
          if (isRecord) {
            this.raise(Errors.RecordNoProto, key);
            return;
          }
          if (protoRef.used) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key.loc.start;
              }
            } else {
              this.raise(Errors.DuplicateProto, key);
            }
          }
          protoRef.used = true;
        }
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(140)) {
          this.unexpected();
        }
        this.finalizeRemainingComments();
        expr.comments = this.comments;
        expr.errors = this.state.errors;
        if (this.optionFlags & 128) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node = this.startNodeAt(startLoc);
          node.expressions = [expr];
          while (this.eat(12)) {
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        var _resultError$loc;
        refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        if (this.isContextual(108)) {
          if (this.prodParam.hasYield) {
            let left2 = this.parseYield();
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node = this.startNodeAt(startLoc);
          const operator = this.state.value;
          node.operator = operator;
          if (this.match(29)) {
            this.toAssignable(left, true);
            node.left = left;
            const startIndex = startLoc.index;
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
          } else {
            node.left = left;
          }
          this.next();
          node.right = this.parseMaybeAssign();
          this.checkLVal(left, this.finishNode(node, "AssignmentExpression"));
          return node;
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node = this.startNodeAt(startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node.alternate = this.parseMaybeAssign();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(Errors.PrivateInExpectedIn, left, {
              identifierName: value
            });
          }
          this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node = this.startNodeAt(leftStartLoc);
            node.left = left;
            node.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
              }
            }
            node.right = this.parseExprOpRightExpr(op, prec);
            const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
            }
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
            if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108)) {
                  throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                }
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
            type: body.type
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipeTopicUnused, startLoc);
        }
        return body;
      }
      checkExponentialAfterUnary(node) {
        if (this.match(57)) {
          this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.recordAwaitIfAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startLoc);
          if (!sawUnary) this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(34);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node.operator = this.state.value;
          node.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node.argument;
            if (arg.type === "Identifier") {
              this.raise(Errors.StrictDelete, node);
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(Errors.DeletePrivateField, node);
            }
          }
          if (!update) {
            if (!sawUnary) {
              this.checkExponentialAfterUnary(node);
            }
            return this.finishNode(node, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousAwait()) {
            this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
            return this.parseAwait(startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node, update, refExpressionErrors) {
        if (update) {
          const updateExpressionNode = node;
          this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
          return node;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startLoc);
          node2.operator = this.state.value;
          node2.prefix = false;
          node2.argument = expr;
          this.next();
          this.checkLVal(expr, expr = this.finishNode(node2, "UpdateExpression"));
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls) {
            this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
            if (this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startLoc, state, computed, optional);
          } else {
            state.stop = true;
            return base;
          }
        }
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        node.computed = computed;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(139)) {
          if (base.type === "Super") {
            this.raise(Errors.SuperPrivateField, startLoc);
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node.property = this.parsePrivateName();
        } else {
          node.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node.optional = optional;
          return this.finishNode(node, "OptionalMemberExpression");
        } else {
          return this.finishNode(node, "MemberExpression");
        }
      }
      parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node.optional = optional;
        }
        if (optional) {
          node.arguments = this.parseCallExpressionArguments(11);
        } else {
          node.arguments = this.parseCallExpressionArguments(11, base.type !== "Super", node, refExpressionErrors);
        }
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(Errors.OptionalChainingNoTemplate, startLoc);
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
          if (node.arguments.length === 0 || node.arguments.length > 2) {
            this.raise(Errors.ImportCallArity, node);
          } else {
            for (const arg of node.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, arg);
              }
            }
          }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) {
          setInnerComments(node, call.innerComments);
        }
        if (call.callee.trailingComments) {
          setInnerComments(node, call.callee.trailingComments);
        }
        return node;
      }
      parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaProperty(node);
            }
            if (this.match(10)) {
              if (this.optionFlags & 256) {
                return this.parseImportCall(node);
              } else {
                return this.finishNode(node, "Import");
              }
            } else {
              this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
              return this.finishNode(node, "Import");
            }
          case 78:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 135:
            return this.parseNumericLiteral(this.state.value);
          case 136:
            return this.parseBigIntLiteral(this.state.value);
          case 134:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 2:
          case 1: {
            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
          }
          case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
          case 6:
          case 7: {
            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, callee);
            }
          }
          case 139: {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            }
            this.unexpected();
            break;
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
            } else {
              this.unexpected();
            }
            break;
          }
          default:
            if (type === 137) {
              return this.parseDecimalLiteral(this.state.value);
            }
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id);
                  this.next();
                  return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                  } else {
                    return id;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id);
                  return this.parseDo(this.startNodeAtNode(id), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
              }
              return id;
            } else {
              this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        } else {
          this.unexpected();
        }
      }
      parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
      }
      finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
          if (pipeProposal === "hack") {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PipeTopicUnbound, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node, "TopicReference");
          } else {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node, "PipelinePrimaryTopicReference");
          }
        } else {
          throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
            token: tokenLabelName(tokenType)
          });
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          }
          case "smart":
            return tokenType === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
        }
        this.expect(19);
        return this.parseArrowExpression(node, params, true);
      }
      parseDo(node, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(2);
          node.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {
          this.raise(Errors.SuperNotAllowed, node);
        } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {
          this.raise(Errors.UnexpectedSuper, node);
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(Errors.UnsupportedSuper, node);
        }
        return this.finishNode(node, "Super");
      }
      parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          this.next();
          if (this.match(103)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) {
          this.raise(Errors.UnsupportedMetaProperty, node.property, {
            target: meta.name,
            onlyValidPropertyName: propertyName
          });
        }
        return this.finishNode(node, "MetaProperty");
      }
      parseImportMetaProperty(node) {
        const id = this.createIdentifier(this.startNodeAtNode(node), "import");
        this.next();
        if (this.isContextual(101)) {
          if (!this.inModule) {
            this.raise(Errors.ImportMetaOutsideModule, id);
          }
          this.sawUnambiguousESM = true;
        } else if (this.isContextual(105) || this.isContextual(97)) {
          const isSource = this.isContextual(105);
          this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
          if (!(this.optionFlags & 256)) {
            throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
              phase: this.state.value
            });
          }
          this.next();
          node.phase = isSource ? "source" : "defer";
          return this.parseImportCall(node);
        }
        return this.parseMetaProperty(node, id, "meta");
      }
      parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      }
      parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node = this.startNode();
        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.pattern = value.pattern;
        node.flags = value.flags;
        this.next();
        return this.finishNode(node, "RegExpLiteral");
      }
      parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc) this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        return this.wrapParenthesis(startLoc, val);
      }
      wrapParenthesis(startLoc, expression) {
        if (!(this.optionFlags & 512)) {
          this.addExtra(expression, "parenthesized", true);
          this.addExtra(expression, "parenStart", startLoc.index);
          this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
          return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(19)) {
          return node;
        }
      }
      parseParenItem(node, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node, meta, "target");
          if (!this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4)) {
            this.raise(Errors.UnexpectedNewTarget, metaProp);
          }
          return metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        this.parseNewCallee(node);
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      }
      parseNewCallee(node) {
        const isImport = this.match(83);
        const callee = this.parseNoCallExpr();
        node.callee = callee;
        if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
          this.raise(Errors.ImportCallNotNewExpression, callee);
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start,
          startLoc,
          end,
          value
        } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
          if (!isTagged) {
            this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
      }
      parseTemplate(isTagged) {
        const node = this.startNode();
        let curElt = this.parseTemplateElement(isTagged);
        const quasis = [curElt];
        const substitutions = [];
        while (!curElt.tail) {
          substitutions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        node.expressions = substitutions;
        node.quasis = quasis;
        return this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = /* @__PURE__ */ Object.create(null);
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              this.addTrailingCommaExtraToNode(node);
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            this.checkProto(prop, isRecord, propHash, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(Errors.InvalidRecordProperty, prop);
          }
          {
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
          }
          node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node, type);
      }
      addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length) this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const {
            key
          } = prop;
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                kind: keyName
              });
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(Errors.BadSetterRestParameter, method);
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(finishedProp);
          return finishedProp;
        }
        if (isAsync || isGenerator || this.match(10)) {
          if (isPattern) this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
            }
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else {
            prop.value = cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node) this.unexpected();
        return node;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value
          } = this.state;
          let key;
          if (tokenIsKeywordOrIdentifier(type)) {
            key = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 135:
                key = this.parseNumericLiteral(value);
                break;
              case 134:
                key = this.parseStringLiteral(value);
                break;
              case 136:
                key = this.parseBigIntLiteral(value);
                break;
              case 139: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                }
                key = this.parsePrivateName();
                break;
              }
              default:
                if (type === 137) {
                  key = this.parseDecimalLiteral(value);
                  break;
                }
                this.unexpected();
            }
          }
          prop.key = key;
          if (type !== 139) {
            prop.computed = false;
          }
        }
      }
      initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = isAsync;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = isGenerator;
        this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(2 | 4);
        let flags = functionFlags(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= 8;
        }
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        return this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | 4);
          node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node.params);
            if (hasStrictModeDirective && nonSimple) {
              this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node.id) {
              this.checkIdentifier(node.id, 65, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node) {
        return node.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (!this.isSimpleParameter(params[i])) return false;
        }
        return true;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
        const formalParameters = {
          type: "FormalParameters"
        };
        for (const param of node.params) {
          this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
              unexpected: ","
            });
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
          }
          const node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(liberal);
        return this.createIdentifier(node, name);
      }
      createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, "Identifier");
      }
      parseIdentifierName(liberal) {
        let name;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name = this.state.value;
        } else {
          this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(132);
          }
        } else {
          this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (checkKeywords && isKeyword(word)) {
          this.raise(Errors.UnexpectedKeyword, startLoc, {
            keyword: word
          });
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, startLoc, {
            reservedWord: word
          });
          return;
        } else if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, startLoc);
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, startLoc);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(Errors.ArgumentsInClass, startLoc);
            return;
          }
        }
      }
      recordAwaitIfAllowed() {
        const isAwaitAllowed = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
        if (isAwaitAllowed && !this.scope.inFunction) {
          this.state.hasTopLevelAwait = true;
        }
        return isAwaitAllowed;
      }
      parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
        if (this.eat(55)) {
          this.raise(Errors.ObsoleteAwaitStar, node);
        }
        if (!this.scope.inFunction && !(this.optionFlags & 1)) {
          if (this.isAmbiguousAwait()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak()) return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield() {
        const node = this.startNode();
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 140:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating) break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
      }
      parseImportCall(node) {
        this.next();
        node.source = this.parseMaybeAssignAllowIn();
        node.options = null;
        if (this.eat(12)) {
          if (!this.match(11)) {
            node.options = this.parseMaybeAssignAllowIn();
            if (this.eat(12) && !this.match(11)) {
              do {
                this.parseMaybeAssignAllowIn();
              } while (this.eat(12) && !this.match(11));
              this.raise(Errors.ImportCallArity, node);
            }
          }
        }
        this.expect(11);
        return this.finishNode(node, "ImportExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          const bodyNode = this.startNodeAt(startLoc);
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          const bodyNode = this.startNodeAt(startLoc);
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipelineTopicUnused, startLoc);
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | 8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        if (!this.match(5)) {
          this.unexpected(null, 5);
        }
        const program3 = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          node.body = this.parseProgram(program3, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel = {
      kind: 1
    };
    var switchLabel = {
      kind: 2
    };
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input, startIndex) {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {
          type
        } = token;
        if (typeof type === "number") {
          {
            if (type === 139) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const hashEndPos = start + 1;
              const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i, 1, new Token({
                type: getExportedToken(27),
                value: "#",
                start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token({
                type: getExportedToken(132),
                value,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              }));
              i++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const backquoteEnd = start + 1;
              const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
              let startToken;
              if (input.charCodeAt(start - startIndex) === 96) {
                startToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              } else {
                startToken = new Token({
                  type: getExportedToken(8),
                  value: "}",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              }
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              if (type === 24) {
                templateElementEnd = end - 1;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                templateValue = value === null ? null : value.slice(1, -1);
                endToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              } else {
                templateElementEnd = end - 2;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                templateValue = value === null ? null : value.slice(1, -2);
                endToken = new Token({
                  type: getExportedToken(23),
                  value: "${",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              }
              tokens.splice(i, 1, startToken, new Token({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken);
              i += 2;
              continue;
            }
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program3) {
        file.program = this.parseProgram(program3);
        file.comments = this.comments;
        if (this.optionFlags & 128) {
          file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program3, end = 140, sourceType = this.options.sourceType) {
        program3.sourceType = sourceType;
        program3.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program3, true, true, end);
        if (this.inModule) {
          if (!(this.optionFlags & 32) && this.scope.undefinedExports.size > 0) {
            for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, at, {
                localName
              });
            }
          }
          this.addExtra(program3, "topLevelAwait", this.state.hasTopLevelAwait);
        }
        let finishedProgram;
        if (end === 140) {
          finishedProgram = this.finishNode(program3, "Program");
        } else {
          finishedProgram = this.finishNodeAt(program3, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        return finishedProgram;
      }
      stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      }
      isLet() {
        if (!this.isContextual(100)) {
          return false;
        }
        return this.hasFollowingBindingAtom();
      }
      chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart(ch)) {
          keywordRelationalOperator.lastIndex = pos;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasInLineFollowingBindingIdentifierOrBrace() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
      }
      startsUsingForOf() {
        const {
          type,
          containsEsc
        } = this.lookahead();
        if (type === 102 && !containsEsc) {
          return false;
        } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
      }
      startsAwaitUsing() {
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
          next = this.nextTokenInLineStartSince(next + 5);
          const nextCh = this.codePointAtPos(next);
          if (this.chStartsBindingIdentifier(nextCh, next)) {
            this.expectPlugin("explicitResourceManagement");
            return true;
          }
        }
        return false;
      }
      parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
      }
      parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        if (this.options.annexB && !this.state.strict) {
          flags |= 4;
          if (allowLabeledFunction) {
            flags |= 8;
          }
        }
        return this.parseStatementLike(flags);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) {
          decorators = this.parseDecorators(true);
        }
        return this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        const startType = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        switch (startType) {
          case 60:
            return this.parseBreakContinueStatement(node, true);
          case 63:
            return this.parseBreakContinueStatement(node, false);
          case 64:
            return this.parseDebuggerStatement(node);
          case 90:
            return this.parseDoWhileStatement(node);
          case 91:
            return this.parseForStatement(node);
          case 68:
            if (this.lookaheadCharCode() === 46) break;
            if (!allowFunctionDeclaration) {
              this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
            }
            return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            if (!allowDeclaration) this.unexpected();
            return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
          case 69:
            return this.parseIfStatement(node);
          case 70:
            return this.parseReturnStatement(node);
          case 71:
            return this.parseSwitchStatement(node);
          case 72:
            return this.parseThrowStatement(node);
          case 73:
            return this.parseTryStatement(node);
          case 96:
            if (!this.state.containsEsc && this.startsAwaitUsing()) {
              if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, node);
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, node);
              }
              this.next();
              return this.parseVarStatement(node, "await using");
            }
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
              break;
            }
            this.expectPlugin("explicitResourceManagement");
            if (!this.scope.inModule && this.scope.inTopLevel) {
              this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
            return this.parseVarStatement(node, "using");
          case 100: {
            if (this.state.containsEsc) {
              break;
            }
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak()) break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
          case 75: {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
          }
          case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node, kind);
          }
          case 92:
            return this.parseWhileStatement(node);
          case 76:
            return this.parseWithStatement(node);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!(this.optionFlags & 8) && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            this.next();
            let result;
            if (startType === 83) {
              result = this.parseImport(node);
              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node, decorators);
              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
              }
              this.next();
              return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(node, maybeName, expr, flags);
        } else {
          return this.parseExpressionStatement(node, expr, decorators);
        }
      }
      assertModuleNodeAllowed(node) {
        if (!(this.optionFlags & 8) && !this.inModule) {
          this.raise(Errors.ImportOutsideModule, node);
        }
      }
      decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy")) return true;
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          var _classNode$decorators;
          if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
              this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
            }
            classNode.decorators.unshift(...maybeDecorators);
          } else {
            classNode.decorators = maybeDecorators;
          }
          this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
          if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const decorators = [];
        do {
          decorators.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (!this.decoratorsEnabledBeforeExport()) {
            this.raise(Errors.DecoratorExportClass, this.state.startLoc);
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        }
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          const startLoc = this.state.startLoc;
          let expr;
          if (this.match(10)) {
            const startLoc2 = this.state.startLoc;
            this.next();
            expr = this.parseExpression();
            this.expect(11);
            expr = this.wrapParenthesis(startLoc2, expr);
            const paramsStartLoc = this.state.startLoc;
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc2);
            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
              this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
            }
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node2 = this.startNodeAt(startLoc);
              node2.object = expr;
              if (this.match(139)) {
                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                node2.property = this.parsePrivateName();
              } else {
                node2.property = this.parseIdentifier(true);
              }
              node2.computed = false;
              expr = this.finishNode(node2, "MemberExpression");
            }
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
          }
        } else {
          node.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.eat(10)) {
          const node = this.startNodeAt(startLoc);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments(11);
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === 1)) {
              break;
            }
            if (node.label && isBreak) break;
          }
        }
        if (i === this.state.labels.length) {
          const type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, node, {
            type
          });
        }
      }
      parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
          awaitAt = this.state.startLoc;
          this.next();
        }
        this.scope.enter(0);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual(100);
        {
          const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
          const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
          const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            const initNode = this.startNode();
            let kind;
            if (startsWithAwaitUsing) {
              kind = "await using";
              if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
              }
              this.next();
            } else {
              kind = this.state.value;
            }
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            const isForIn = this.match(58);
            if (isForIn && starsWithUsingDeclaration) {
              this.raise(Errors.ForInUsing, init2);
            }
            if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
              return this.parseForIn(node, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init2);
          }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(102);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(Errors.ForOfLet, init);
          }
          if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
            this.raise(Errors.ForOfAsync, init);
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init, true);
          const type = isForOf ? "ForOfStatement" : "ForInStatement";
          this.checkLVal(init, {
            type
          });
          return this.parseForIn(node, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      }
      parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
      }
      parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        if (!this.prodParam.hasReturn && !(this.optionFlags & 2)) {
          this.raise(Errors.IllegalReturn, this.state.startLoc);
        }
        this.next();
        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(0);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur) this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatementListItem());
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
        this.checkLVal(param, {
          type: "CatchClause"
        }, 9);
        return param;
      }
      parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(0);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(Errors.NoCatchOrFinally, node);
        }
        return this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        if (this.state.strict) {
          this.raise(Errors.StrictWith, this.state.startLoc);
        }
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        return this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(Errors.LabelRedeclaration, expr, {
              labelName: maybeName
            });
          }
        }
        const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          const label = this.state.labels[i];
          if (label.statementStart === node.start) {
            label.statementStart = this.sourceToOffsetPos(this.state.start);
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.sourceToOffsetPos(this.state.start)
        });
        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr, decorators) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(5);
        if (createNewLexicalScope) {
          this.scope.enter(0);
        }
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive = this.stmtToDirective(stmt);
              directives.push(directive);
              if (!hasStrictModeDirective && directive.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
          if (awaitAt !== null) this.unexpected(awaitAt);
        } else {
          node.await = awaitAt !== null;
        }
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(Errors.ForInOfLoopInitializer, init, {
            type: isForIn ? "ForInStatement" : "ForOfStatement"
          });
        }
        if (init.type === "AssignmentPattern") {
          this.raise(Errors.InvalidLhs, init, {
            ancestor: {
              type: "ForStatement"
            }
          });
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          const decl = this.startNode();
          this.parseVarId(decl, kind);
          decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          if (decl.init === null && !allowMissingInitializer) {
            if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind: "destructuring"
              });
            } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind
              });
            }
          }
          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(12)) break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        if (kind === "using" || kind === "await using") {
          if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
            this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
          }
        }
        this.checkLVal(id, {
          type: "VariableDeclarator"
        }, kind === "var" ? 5 : 8201);
        decl.id = id;
      }
      parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
      }
      parseFunction(node, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration = !!(flags & 1);
        const requireId = isDeclaration && !(flags & 4);
        const isAsync = !!(flags & 8);
        this.initFunction(node, isAsync);
        if (this.match(55)) {
          if (hangingDeclaration) {
            this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
          }
          this.next();
          node.generator = true;
        }
        if (isDeclaration) {
          node.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(2);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        if (!isDeclaration) {
          node.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isDeclaration && !hangingDeclaration) {
          this.registerFunctionStatementId(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, isConstructor) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        if (!node.id) return;
        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
      }
      parseClass(node, isStatement, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      nameIsConstructor(key) {
        return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(8)) {
            if (this.eat(13)) {
              if (decorators.length > 0) {
                throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
              }
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(Errors.DecoratorConstructor, member);
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(106);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
          method.kind = "method";
          const isPrivateName = this.match(139);
          this.parseClassElementName(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
        const key = this.parseClassElementName(member);
        const maybeContextualKw = isContextual ? key.name : null;
        const isPrivate = this.isPrivateName(key);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(Errors.DuplicateConstructor, key);
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(Errors.OverrideOnConstructor, key);
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          const isGenerator = this.eat(55);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStartLoc);
          }
          method.kind = "method";
          const isPrivate2 = this.match(139);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAsync, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key);
          method.kind = maybeContextualKw;
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors");
          this.resetPreviousNodeTrailingComments(key);
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicProp);
          this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value
        } = this.state;
        if ((type === 132 || type === 134) && member.static && value === "prototype") {
          this.raise(Errors.StaticPrototype, this.state.startLoc);
        }
        if (type === 139) {
          if (value === "constructor") {
            this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
          }
          const key = this.parsePrivateName();
          member.key = key;
          return key;
        }
        this.parsePropertyName(member);
        return member.key;
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(64 | 128 | 16);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(0);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(Errors.DecoratorStaticBlock, member);
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        const node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node);
        if (isPrivate) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node, kind);
      }
      declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
      }
      parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassAccessorProperty");
      }
      parseInitializer(node) {
        this.scope.enter(64 | 16);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(0);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node, isStatement, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          if (isStatement) {
            this.declareNameFromIdentifier(node.id, bindingType);
          }
        } else {
          if (optionalId || !isStatement) {
            node.id = null;
          } else {
            throw this.raise(Errors.MissingClassName, this.state.startLoc);
          }
        }
      }
      parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault) this.unexpected();
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, true);
          return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
          this.unexpected(null, 5);
        }
        if (hasNamespace && parseAfterNamespace) {
          this.unexpected(null, 98);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          var _node2$declaration;
          const node2 = node;
          this.checkExport(node2, true, false, !!node2.source);
          if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, node2.declaration, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          const node2 = node;
          const decl = this.parseExportDefaultExpression();
          node2.declaration = decl;
          if (decl.type === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, decl, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.checkExport(node2, true, true);
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        this.unexpected(null, 5);
      }
      eatExportStar(node) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
          const id = maybeDefaultIdentifier || this.parseIdentifier(true);
          const specifier = this.startNodeAtNode(id);
          specifier.exported = id;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
          var _ref, _ref$specifiers;
          (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
          const node2 = node;
          if (!node2.specifiers) node2.specifiers = [];
          const isTypeExport = node2.exportKind === "type";
          node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
          node2.source = null;
          node2.declaration = null;
          if (this.hasPlugin("importAssertions")) {
            node2.assertions = [];
          }
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          node.specifiers = [];
          node.source = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          }
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual(95)) return false;
        const next = this.nextTokenInLineStart();
        return this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        if (this.match(68)) {
          this.next();
          return this.parseFunction(expr, 1 | 4);
        } else if (this.isAsyncFunction()) {
          this.next();
          this.next();
          return this.parseFunction(expr, 1 | 4 | 8);
        }
        if (this.match(80)) {
          return this.parseClass(expr, true, true);
        }
        if (this.match(26)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet()) {
          throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        }
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
      parseExportDeclaration(node) {
        if (this.match(80)) {
          const node2 = this.parseClass(this.startNode(), true, false);
          return node2;
        }
        return this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 100) {
            return false;
          }
          if ((type === 130 || type === 129) && !this.state.containsEsc) {
            const {
              type: nextType
            } = this.lookahead();
            if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(65)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
          return true;
        }
        if (this.match(65) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node, expect) {
        if (this.eatContextual(98)) {
          node.source = this.parseImportSource();
          this.checkExport(node);
          this.maybeParseImportAttributes(node);
          this.checkJSONModuleImport(node);
        } else if (expect) {
          this.unexpected();
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 26) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
              this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
            }
            return true;
          }
        }
        if (this.isContextual(107)) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        if (this.isContextual(96) && this.startsAwaitUsing()) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          var _node$specifiers;
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
              }
            }
          } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
            for (const specifier of node.specifiers) {
              const {
                exported
              } = specifier;
              const exportName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(Errors.ExportBindingIsString, specifier, {
                    localName: local.value,
                    exportName
                  });
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node.declaration) {
            const decl = node.declaration;
            if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
              const {
                id
              } = decl;
              if (!id) throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (decl.type === "VariableDeclaration") {
              for (const declaration of decl.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (const prop of node.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (const elem of node.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      }
      checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
          if (exportName === "default") {
            this.raise(Errors.DuplicateDefaultExport, node);
          } else {
            this.raise(Errors.DuplicateExport, node, {
              exportName
            });
          }
        }
        this.exportedIdentifiers.add(exportName);
      }
      parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.eat(8)) break;
          }
          const isMaybeTypeOnly = this.isContextual(130);
          const isString = this.match(134);
          const node = this.startNode();
          node.local = this.parseModuleExportName();
          nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          node.exported = this.parseModuleExportName();
        } else if (isString) {
          node.exported = cloneStringLiteral(node.local);
        } else if (!node.exported) {
          node.exported = cloneIdentifier(node.local);
        }
        return this.finishNode(node, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(134)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = loneSurrogate.exec(result.value);
          if (surrogate) {
            this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
              surrogateCharCode: surrogate[0].charCodeAt(0)
            });
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      isJSONModuleImport(node) {
        if (node.assertions != null) {
          return node.assertions.some(({
            key,
            value
          }) => {
            return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
          });
        }
        return false;
      }
      checkImportReflection(node) {
        const {
          specifiers
        } = node;
        const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        if (node.phase === "source") {
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
          }
        } else if (node.phase === "defer") {
          if (singleBindingType !== "ImportNamespaceSpecifier") {
            this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
          }
        } else if (node.module) {
          var _node$assertions;
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
          }
          if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
            this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
          }
        }
      }
      checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
          const {
            specifiers
          } = node;
          if (specifiers != null) {
            const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
              let imported;
              if (specifier.type === "ExportSpecifier") {
                imported = specifier.local;
              } else if (specifier.type === "ImportSpecifier") {
                imported = specifier.imported;
              }
              if (imported !== void 0) {
                return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
              }
            });
            if (nonDefaultNamedSpecifier !== void 0) {
              this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
            }
          }
        }
      }
      isPotentialImportPhase(isExport) {
        if (isExport) return false;
        return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
      }
      applyImportPhase(node, isExport, phase, loc) {
        if (isExport) {
          return;
        }
        if (phase === "module") {
          this.expectPlugin("importReflection", loc);
          node.module = true;
        } else if (this.hasPlugin("importReflection")) {
          node.module = false;
        }
        if (phase === "source") {
          this.expectPlugin("sourcePhaseImports", loc);
          node.phase = "source";
        } else if (phase === "defer") {
          this.expectPlugin("deferredImportEvaluation", loc);
          node.phase = "defer";
        } else if (this.hasPlugin("sourcePhaseImports")) {
          node.phase = null;
        }
      }
      parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
          this.applyImportPhase(node, isExport, null);
          return null;
        }
        const phaseIdentifier = this.parseIdentifier(true);
        const {
          type
        } = this.state;
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
        if (isImportPhase) {
          this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
          this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
          return null;
        } else {
          this.applyImportPhase(node, isExport, null);
          return phaseIdentifier;
        }
      }
      isPrecedingIdImportPhase(phase) {
        const {
          type
        } = this.state;
        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      }
      parseImport(node) {
        if (this.match(134)) {
          return this.parseImportSourceAndAttributes(node);
        }
        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
      }
      parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(12);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual(98);
        return this.parseImportSourceAndAttributes(node);
      }
      parseImportSourceAndAttributes(node) {
        var _node$specifiers2;
        (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
        node.source = this.parseImportSource();
        this.maybeParseImportAttributes(node);
        this.checkImportReflection(node);
        this.checkJSONModuleImport(node);
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(134)) this.unexpected();
        return this.parseExprAtom();
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      finishImportSpecifier(specifier, type, bindingType = 8201) {
        this.checkLVal(specifier.local, {
          type
        }, bindingType);
        return this.finishNode(specifier, type);
      }
      parseImportAttributes() {
        this.expect(5);
        const attrs = [];
        const attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8)) {
            break;
          }
          const node = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
              key: keyName
            });
          }
          attrNames.add(keyName);
          if (this.match(134)) {
            node.key = this.parseStringLiteral(keyName);
          } else {
            node.key = this.parseIdentifier(true);
          }
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        this.expect(8);
        return attrs;
      }
      parseModuleAttributes() {
        const attrs = [];
        const attributes = /* @__PURE__ */ new Set();
        do {
          const node = this.startNode();
          node.key = this.parseIdentifier(true);
          if (node.key.name !== "type") {
            this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
          }
          if (attributes.has(node.key.name)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
              key: node.key.name
            });
          }
          attributes.add(node.key.name);
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAttributes(node) {
        let attributes;
        {
          var useWith = false;
        }
        if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
            return;
          }
          this.next();
          if (this.hasPlugin("moduleAttributes")) {
            attributes = this.parseModuleAttributes();
          } else {
            attributes = this.parseImportAttributes();
          }
          {
            useWith = true;
          }
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
          if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
            this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
          }
          if (!this.hasPlugin("importAssertions")) {
            this.addExtra(node, "deprecatedAssertSyntax", true);
          }
          this.next();
          attributes = this.parseImportAttributes();
        } else {
          attributes = [];
        }
        if (!useWith && this.hasPlugin("importAssertions")) {
          node.assertions = attributes;
        } else {
          node.attributes = attributes;
        }
      }
      maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
          const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
          specifier.local = maybeDefaultIdentifier;
          node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
          return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual(93);
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(14)) {
              throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
            }
            this.expect(12);
            if (this.eat(8)) break;
          }
          const specifier = this.startNode();
          const importedIsString = this.match(134);
          const isMaybeTypeOnly = this.isContextual(130);
          specifier.imported = this.parseModuleExportName();
          const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
          node.specifiers.push(importSpecifier);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: imported.value
            });
          }
          this.checkReservedWord(imported.name, specifier.loc.start, true, true);
          if (!specifier.local) {
            specifier.local = cloneIdentifier(imported);
          }
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser = class extends StatementParser {
      constructor(options, input, pluginsMap) {
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap;
        this.filename = options.sourceFilename;
        this.startIndex = options.startIndex;
        let optionFlags = 0;
        if (options.allowAwaitOutsideFunction) {
          optionFlags |= 1;
        }
        if (options.allowReturnOutsideFunction) {
          optionFlags |= 2;
        }
        if (options.allowImportExportEverywhere) {
          optionFlags |= 8;
        }
        if (options.allowSuperOutsideMethod) {
          optionFlags |= 16;
        }
        if (options.allowUndeclaredExports) {
          optionFlags |= 32;
        }
        if (options.allowNewTargetOutsideFunction) {
          optionFlags |= 4;
        }
        if (options.ranges) {
          optionFlags |= 64;
        }
        if (options.tokens) {
          optionFlags |= 128;
        }
        if (options.createImportExpressions) {
          optionFlags |= 256;
        }
        if (options.createParenthesizedExpressions) {
          optionFlags |= 512;
        }
        if (options.errorRecovery) {
          optionFlags |= 1024;
        }
        if (options.attachComment) {
          optionFlags |= 2048;
        }
        if (options.annexB) {
          optionFlags |= 4096;
        }
        this.optionFlags = optionFlags;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program3 = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program3);
        file.errors = this.state.errors;
        file.comments.length = this.state.commentsLen;
        return file;
      }
    };
    function parse2(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input);
          const ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      const parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      const tokenTypes2 = {};
      for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
      }
      return tokenTypes2;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      let cls = Parser;
      const pluginsMap = /* @__PURE__ */ new Map();
      if (options != null && options.plugins) {
        for (const plugin of options.plugins) {
          let name, opts;
          if (typeof plugin === "string") {
            name = plugin;
          } else {
            [name, opts] = plugin;
          }
          if (!pluginsMap.has(name)) {
            pluginsMap.set(name, opts || {});
          }
        }
        validatePlugins(pluginsMap);
        cls = getParserClass(pluginsMap);
      }
      return new cls(options, input, pluginsMap);
    }
    var parserClassCache = /* @__PURE__ */ new Map();
    function getParserClass(pluginsMap) {
      const pluginList = [];
      for (const name of mixinPluginNames) {
        if (pluginsMap.has(name)) {
          pluginList.push(name);
        }
      }
      const key = pluginList.join("|");
      let cls = parserClassCache.get(key);
      if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
          cls = mixinPlugins[plugin](cls);
        }
        parserClassCache.set(key, cls);
      }
      return cls;
    }
    exports2.parse = parse2;
    exports2.parseExpression = parseExpression;
    exports2.tokTypes = tokTypes;
  }
});

// node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Var = exports2.User = exports2.Statement = exports2.SpreadProperty = exports2.Scope = exports2.RestProperty = exports2.ReferencedMemberExpression = exports2.ReferencedIdentifier = exports2.Referenced = exports2.Pure = exports2.NumericLiteralTypeAnnotation = exports2.Generated = exports2.ForAwaitStatement = exports2.Flow = exports2.Expression = exports2.ExistentialTypeParam = exports2.BlockScoped = exports2.BindingIdentifier = void 0;
    var ReferencedIdentifier = exports2.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
    var ReferencedMemberExpression = exports2.ReferencedMemberExpression = ["MemberExpression"];
    var BindingIdentifier = exports2.BindingIdentifier = ["Identifier"];
    var Statement = exports2.Statement = ["Statement"];
    var Expression = exports2.Expression = ["Expression"];
    var Scope = exports2.Scope = ["Scopable", "Pattern"];
    var Referenced = exports2.Referenced = null;
    var BlockScoped = exports2.BlockScoped = null;
    var Var = exports2.Var = ["VariableDeclaration"];
    var User = exports2.User = null;
    var Generated = exports2.Generated = null;
    var Pure = exports2.Pure = null;
    var Flow = exports2.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
    var RestProperty = exports2.RestProperty = ["RestElement"];
    var SpreadProperty = exports2.SpreadProperty = ["RestElement"];
    var ExistentialTypeParam = exports2.ExistentialTypeParam = ["ExistsTypeAnnotation"];
    var NumericLiteralTypeAnnotation = exports2.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
    var ForAwaitStatement = exports2.ForAwaitStatement = ["ForOfStatement"];
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
  "node_modules/@babel/types/lib/utils/shallowEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = shallowEqual;
    function shallowEqual(actual, expected) {
      const keys = Object.keys(expected);
      for (const key of keys) {
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS({
  "node_modules/@babel/types/lib/utils/deprecationWarning.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = deprecationWarning;
    var warnings = /* @__PURE__ */ new Set();
    function deprecationWarning(oldName, newName, prefix = "") {
      if (warnings.has(oldName)) return;
      warnings.add(oldName);
      const {
        internal,
        trace
      } = captureShortStackTrace(1, 2);
      if (internal) {
        return;
      }
      console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
    }
    function captureShortStackTrace(skip, length) {
      const {
        stackTraceLimit,
        prepareStackTrace
      } = Error;
      let stackTrace;
      Error.stackTraceLimit = 1 + skip + length;
      Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
      };
      new Error().stack;
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      if (!stackTrace) return {
        internal: false,
        trace: ""
      };
      const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
      };
    }
  }
});

// node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
  "node_modules/@babel/types/lib/validators/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAccessor = isAccessor;
    exports2.isAnyTypeAnnotation = isAnyTypeAnnotation;
    exports2.isArgumentPlaceholder = isArgumentPlaceholder;
    exports2.isArrayExpression = isArrayExpression;
    exports2.isArrayPattern = isArrayPattern;
    exports2.isArrayTypeAnnotation = isArrayTypeAnnotation;
    exports2.isArrowFunctionExpression = isArrowFunctionExpression;
    exports2.isAssignmentExpression = isAssignmentExpression;
    exports2.isAssignmentPattern = isAssignmentPattern;
    exports2.isAwaitExpression = isAwaitExpression;
    exports2.isBigIntLiteral = isBigIntLiteral;
    exports2.isBinary = isBinary;
    exports2.isBinaryExpression = isBinaryExpression;
    exports2.isBindExpression = isBindExpression;
    exports2.isBlock = isBlock;
    exports2.isBlockParent = isBlockParent;
    exports2.isBlockStatement = isBlockStatement;
    exports2.isBooleanLiteral = isBooleanLiteral;
    exports2.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    exports2.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    exports2.isBreakStatement = isBreakStatement;
    exports2.isCallExpression = isCallExpression;
    exports2.isCatchClause = isCatchClause;
    exports2.isClass = isClass;
    exports2.isClassAccessorProperty = isClassAccessorProperty;
    exports2.isClassBody = isClassBody;
    exports2.isClassDeclaration = isClassDeclaration;
    exports2.isClassExpression = isClassExpression;
    exports2.isClassImplements = isClassImplements;
    exports2.isClassMethod = isClassMethod;
    exports2.isClassPrivateMethod = isClassPrivateMethod;
    exports2.isClassPrivateProperty = isClassPrivateProperty;
    exports2.isClassProperty = isClassProperty;
    exports2.isCompletionStatement = isCompletionStatement;
    exports2.isConditional = isConditional;
    exports2.isConditionalExpression = isConditionalExpression;
    exports2.isContinueStatement = isContinueStatement;
    exports2.isDebuggerStatement = isDebuggerStatement;
    exports2.isDecimalLiteral = isDecimalLiteral;
    exports2.isDeclaration = isDeclaration;
    exports2.isDeclareClass = isDeclareClass;
    exports2.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    exports2.isDeclareExportDeclaration = isDeclareExportDeclaration;
    exports2.isDeclareFunction = isDeclareFunction;
    exports2.isDeclareInterface = isDeclareInterface;
    exports2.isDeclareModule = isDeclareModule;
    exports2.isDeclareModuleExports = isDeclareModuleExports;
    exports2.isDeclareOpaqueType = isDeclareOpaqueType;
    exports2.isDeclareTypeAlias = isDeclareTypeAlias;
    exports2.isDeclareVariable = isDeclareVariable;
    exports2.isDeclaredPredicate = isDeclaredPredicate;
    exports2.isDecorator = isDecorator;
    exports2.isDirective = isDirective;
    exports2.isDirectiveLiteral = isDirectiveLiteral;
    exports2.isDoExpression = isDoExpression;
    exports2.isDoWhileStatement = isDoWhileStatement;
    exports2.isEmptyStatement = isEmptyStatement;
    exports2.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    exports2.isEnumBody = isEnumBody;
    exports2.isEnumBooleanBody = isEnumBooleanBody;
    exports2.isEnumBooleanMember = isEnumBooleanMember;
    exports2.isEnumDeclaration = isEnumDeclaration;
    exports2.isEnumDefaultedMember = isEnumDefaultedMember;
    exports2.isEnumMember = isEnumMember;
    exports2.isEnumNumberBody = isEnumNumberBody;
    exports2.isEnumNumberMember = isEnumNumberMember;
    exports2.isEnumStringBody = isEnumStringBody;
    exports2.isEnumStringMember = isEnumStringMember;
    exports2.isEnumSymbolBody = isEnumSymbolBody;
    exports2.isExistsTypeAnnotation = isExistsTypeAnnotation;
    exports2.isExportAllDeclaration = isExportAllDeclaration;
    exports2.isExportDeclaration = isExportDeclaration;
    exports2.isExportDefaultDeclaration = isExportDefaultDeclaration;
    exports2.isExportDefaultSpecifier = isExportDefaultSpecifier;
    exports2.isExportNamedDeclaration = isExportNamedDeclaration;
    exports2.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    exports2.isExportSpecifier = isExportSpecifier;
    exports2.isExpression = isExpression;
    exports2.isExpressionStatement = isExpressionStatement;
    exports2.isExpressionWrapper = isExpressionWrapper;
    exports2.isFile = isFile;
    exports2.isFlow = isFlow;
    exports2.isFlowBaseAnnotation = isFlowBaseAnnotation;
    exports2.isFlowDeclaration = isFlowDeclaration;
    exports2.isFlowPredicate = isFlowPredicate;
    exports2.isFlowType = isFlowType;
    exports2.isFor = isFor;
    exports2.isForInStatement = isForInStatement;
    exports2.isForOfStatement = isForOfStatement;
    exports2.isForStatement = isForStatement;
    exports2.isForXStatement = isForXStatement;
    exports2.isFunction = isFunction;
    exports2.isFunctionDeclaration = isFunctionDeclaration;
    exports2.isFunctionExpression = isFunctionExpression;
    exports2.isFunctionParent = isFunctionParent;
    exports2.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    exports2.isFunctionTypeParam = isFunctionTypeParam;
    exports2.isGenericTypeAnnotation = isGenericTypeAnnotation;
    exports2.isIdentifier = isIdentifier;
    exports2.isIfStatement = isIfStatement;
    exports2.isImmutable = isImmutable;
    exports2.isImport = isImport;
    exports2.isImportAttribute = isImportAttribute;
    exports2.isImportDeclaration = isImportDeclaration;
    exports2.isImportDefaultSpecifier = isImportDefaultSpecifier;
    exports2.isImportExpression = isImportExpression;
    exports2.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    exports2.isImportOrExportDeclaration = isImportOrExportDeclaration;
    exports2.isImportSpecifier = isImportSpecifier;
    exports2.isIndexedAccessType = isIndexedAccessType;
    exports2.isInferredPredicate = isInferredPredicate;
    exports2.isInterfaceDeclaration = isInterfaceDeclaration;
    exports2.isInterfaceExtends = isInterfaceExtends;
    exports2.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    exports2.isInterpreterDirective = isInterpreterDirective;
    exports2.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    exports2.isJSX = isJSX;
    exports2.isJSXAttribute = isJSXAttribute2;
    exports2.isJSXClosingElement = isJSXClosingElement;
    exports2.isJSXClosingFragment = isJSXClosingFragment;
    exports2.isJSXElement = isJSXElement;
    exports2.isJSXEmptyExpression = isJSXEmptyExpression;
    exports2.isJSXExpressionContainer = isJSXExpressionContainer;
    exports2.isJSXFragment = isJSXFragment;
    exports2.isJSXIdentifier = isJSXIdentifier2;
    exports2.isJSXMemberExpression = isJSXMemberExpression2;
    exports2.isJSXNamespacedName = isJSXNamespacedName;
    exports2.isJSXOpeningElement = isJSXOpeningElement;
    exports2.isJSXOpeningFragment = isJSXOpeningFragment;
    exports2.isJSXSpreadAttribute = isJSXSpreadAttribute;
    exports2.isJSXSpreadChild = isJSXSpreadChild;
    exports2.isJSXText = isJSXText;
    exports2.isLVal = isLVal;
    exports2.isLabeledStatement = isLabeledStatement;
    exports2.isLiteral = isLiteral;
    exports2.isLogicalExpression = isLogicalExpression;
    exports2.isLoop = isLoop;
    exports2.isMemberExpression = isMemberExpression;
    exports2.isMetaProperty = isMetaProperty;
    exports2.isMethod = isMethod;
    exports2.isMiscellaneous = isMiscellaneous;
    exports2.isMixedTypeAnnotation = isMixedTypeAnnotation;
    exports2.isModuleDeclaration = isModuleDeclaration;
    exports2.isModuleExpression = isModuleExpression;
    exports2.isModuleSpecifier = isModuleSpecifier;
    exports2.isNewExpression = isNewExpression;
    exports2.isNoop = isNoop;
    exports2.isNullLiteral = isNullLiteral;
    exports2.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    exports2.isNullableTypeAnnotation = isNullableTypeAnnotation;
    exports2.isNumberLiteral = isNumberLiteral;
    exports2.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    exports2.isNumberTypeAnnotation = isNumberTypeAnnotation;
    exports2.isNumericLiteral = isNumericLiteral;
    exports2.isObjectExpression = isObjectExpression;
    exports2.isObjectMember = isObjectMember;
    exports2.isObjectMethod = isObjectMethod;
    exports2.isObjectPattern = isObjectPattern;
    exports2.isObjectProperty = isObjectProperty;
    exports2.isObjectTypeAnnotation = isObjectTypeAnnotation;
    exports2.isObjectTypeCallProperty = isObjectTypeCallProperty;
    exports2.isObjectTypeIndexer = isObjectTypeIndexer;
    exports2.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    exports2.isObjectTypeProperty = isObjectTypeProperty;
    exports2.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    exports2.isOpaqueType = isOpaqueType;
    exports2.isOptionalCallExpression = isOptionalCallExpression;
    exports2.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    exports2.isOptionalMemberExpression = isOptionalMemberExpression;
    exports2.isParenthesizedExpression = isParenthesizedExpression;
    exports2.isPattern = isPattern;
    exports2.isPatternLike = isPatternLike;
    exports2.isPipelineBareFunction = isPipelineBareFunction;
    exports2.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    exports2.isPipelineTopicExpression = isPipelineTopicExpression;
    exports2.isPlaceholder = isPlaceholder;
    exports2.isPrivate = isPrivate;
    exports2.isPrivateName = isPrivateName;
    exports2.isProgram = isProgram;
    exports2.isProperty = isProperty;
    exports2.isPureish = isPureish;
    exports2.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    exports2.isRecordExpression = isRecordExpression;
    exports2.isRegExpLiteral = isRegExpLiteral;
    exports2.isRegexLiteral = isRegexLiteral;
    exports2.isRestElement = isRestElement;
    exports2.isRestProperty = isRestProperty;
    exports2.isReturnStatement = isReturnStatement;
    exports2.isScopable = isScopable;
    exports2.isSequenceExpression = isSequenceExpression;
    exports2.isSpreadElement = isSpreadElement;
    exports2.isSpreadProperty = isSpreadProperty;
    exports2.isStandardized = isStandardized;
    exports2.isStatement = isStatement;
    exports2.isStaticBlock = isStaticBlock;
    exports2.isStringLiteral = isStringLiteral3;
    exports2.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    exports2.isStringTypeAnnotation = isStringTypeAnnotation;
    exports2.isSuper = isSuper;
    exports2.isSwitchCase = isSwitchCase;
    exports2.isSwitchStatement = isSwitchStatement;
    exports2.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    exports2.isTSAnyKeyword = isTSAnyKeyword;
    exports2.isTSArrayType = isTSArrayType;
    exports2.isTSAsExpression = isTSAsExpression;
    exports2.isTSBaseType = isTSBaseType;
    exports2.isTSBigIntKeyword = isTSBigIntKeyword;
    exports2.isTSBooleanKeyword = isTSBooleanKeyword;
    exports2.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    exports2.isTSConditionalType = isTSConditionalType;
    exports2.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    exports2.isTSConstructorType = isTSConstructorType;
    exports2.isTSDeclareFunction = isTSDeclareFunction;
    exports2.isTSDeclareMethod = isTSDeclareMethod;
    exports2.isTSEntityName = isTSEntityName;
    exports2.isTSEnumBody = isTSEnumBody;
    exports2.isTSEnumDeclaration = isTSEnumDeclaration;
    exports2.isTSEnumMember = isTSEnumMember;
    exports2.isTSExportAssignment = isTSExportAssignment;
    exports2.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    exports2.isTSExternalModuleReference = isTSExternalModuleReference;
    exports2.isTSFunctionType = isTSFunctionType;
    exports2.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    exports2.isTSImportType = isTSImportType;
    exports2.isTSIndexSignature = isTSIndexSignature;
    exports2.isTSIndexedAccessType = isTSIndexedAccessType;
    exports2.isTSInferType = isTSInferType;
    exports2.isTSInstantiationExpression = isTSInstantiationExpression;
    exports2.isTSInterfaceBody = isTSInterfaceBody;
    exports2.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    exports2.isTSIntersectionType = isTSIntersectionType;
    exports2.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    exports2.isTSLiteralType = isTSLiteralType;
    exports2.isTSMappedType = isTSMappedType;
    exports2.isTSMethodSignature = isTSMethodSignature;
    exports2.isTSModuleBlock = isTSModuleBlock;
    exports2.isTSModuleDeclaration = isTSModuleDeclaration;
    exports2.isTSNamedTupleMember = isTSNamedTupleMember;
    exports2.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    exports2.isTSNeverKeyword = isTSNeverKeyword;
    exports2.isTSNonNullExpression = isTSNonNullExpression;
    exports2.isTSNullKeyword = isTSNullKeyword;
    exports2.isTSNumberKeyword = isTSNumberKeyword;
    exports2.isTSObjectKeyword = isTSObjectKeyword;
    exports2.isTSOptionalType = isTSOptionalType;
    exports2.isTSParameterProperty = isTSParameterProperty;
    exports2.isTSParenthesizedType = isTSParenthesizedType;
    exports2.isTSPropertySignature = isTSPropertySignature;
    exports2.isTSQualifiedName = isTSQualifiedName;
    exports2.isTSRestType = isTSRestType;
    exports2.isTSSatisfiesExpression = isTSSatisfiesExpression;
    exports2.isTSStringKeyword = isTSStringKeyword;
    exports2.isTSSymbolKeyword = isTSSymbolKeyword;
    exports2.isTSTemplateLiteralType = isTSTemplateLiteralType;
    exports2.isTSThisType = isTSThisType;
    exports2.isTSTupleType = isTSTupleType;
    exports2.isTSType = isTSType;
    exports2.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    exports2.isTSTypeAnnotation = isTSTypeAnnotation;
    exports2.isTSTypeAssertion = isTSTypeAssertion;
    exports2.isTSTypeElement = isTSTypeElement;
    exports2.isTSTypeLiteral = isTSTypeLiteral;
    exports2.isTSTypeOperator = isTSTypeOperator;
    exports2.isTSTypeParameter = isTSTypeParameter;
    exports2.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    exports2.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    exports2.isTSTypePredicate = isTSTypePredicate;
    exports2.isTSTypeQuery = isTSTypeQuery;
    exports2.isTSTypeReference = isTSTypeReference;
    exports2.isTSUndefinedKeyword = isTSUndefinedKeyword;
    exports2.isTSUnionType = isTSUnionType;
    exports2.isTSUnknownKeyword = isTSUnknownKeyword;
    exports2.isTSVoidKeyword = isTSVoidKeyword;
    exports2.isTaggedTemplateExpression = isTaggedTemplateExpression;
    exports2.isTemplateElement = isTemplateElement;
    exports2.isTemplateLiteral = isTemplateLiteral;
    exports2.isTerminatorless = isTerminatorless;
    exports2.isThisExpression = isThisExpression;
    exports2.isThisTypeAnnotation = isThisTypeAnnotation;
    exports2.isThrowStatement = isThrowStatement;
    exports2.isTopicReference = isTopicReference;
    exports2.isTryStatement = isTryStatement;
    exports2.isTupleExpression = isTupleExpression;
    exports2.isTupleTypeAnnotation = isTupleTypeAnnotation;
    exports2.isTypeAlias = isTypeAlias;
    exports2.isTypeAnnotation = isTypeAnnotation;
    exports2.isTypeCastExpression = isTypeCastExpression;
    exports2.isTypeParameter = isTypeParameter;
    exports2.isTypeParameterDeclaration = isTypeParameterDeclaration;
    exports2.isTypeParameterInstantiation = isTypeParameterInstantiation;
    exports2.isTypeScript = isTypeScript;
    exports2.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    exports2.isUnaryExpression = isUnaryExpression;
    exports2.isUnaryLike = isUnaryLike;
    exports2.isUnionTypeAnnotation = isUnionTypeAnnotation;
    exports2.isUpdateExpression = isUpdateExpression;
    exports2.isUserWhitespacable = isUserWhitespacable;
    exports2.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    exports2.isVariableDeclaration = isVariableDeclaration;
    exports2.isVariableDeclarator = isVariableDeclarator;
    exports2.isVariance = isVariance;
    exports2.isVoidTypeAnnotation = isVoidTypeAnnotation;
    exports2.isWhile = isWhile;
    exports2.isWhileStatement = isWhileStatement;
    exports2.isWithStatement = isWithStatement;
    exports2.isYieldExpression = isYieldExpression;
    var _shallowEqual = require_shallowEqual();
    var _deprecationWarning = require_deprecationWarning();
    function isArrayExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrayExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "AssignmentExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinaryExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "BinaryExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterpreterDirective(node, opts) {
      if (!node) return false;
      if (node.type !== "InterpreterDirective") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirective(node, opts) {
      if (!node) return false;
      if (node.type !== "Directive") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirectiveLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "DirectiveLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "BlockStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBreakStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "BreakStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCallExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "CallExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCatchClause(node, opts) {
      if (!node) return false;
      if (node.type !== "CatchClause") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditionalExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ConditionalExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isContinueStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ContinueStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDebuggerStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "DebuggerStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoWhileStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "DoWhileStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "EmptyStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ExpressionStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFile(node, opts) {
      if (!node) return false;
      if (node.type !== "File") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForInStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ForInStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ForStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "Identifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIfStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "IfStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLabeledStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "LabeledStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteral3(node, opts) {
      if (!node) return false;
      if (node.type !== "StringLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumericLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "NumericLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "NullLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "BooleanLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegExpLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "RegExpLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLogicalExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "LogicalExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMemberExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "MemberExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNewExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "NewExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProgram(node, opts) {
      if (!node) return false;
      if (node.type !== "Program") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestElement(node, opts) {
      if (!node) return false;
      if (node.type !== "RestElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isReturnStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ReturnStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSequenceExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "SequenceExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isParenthesizedExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ParenthesizedExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchCase(node, opts) {
      if (!node) return false;
      if (node.type !== "SwitchCase") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "SwitchStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ThisExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThrowStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ThrowStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTryStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "TryStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "UnaryExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUpdateExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "UpdateExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "VariableDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclarator(node, opts) {
      if (!node) return false;
      if (node.type !== "VariableDeclarator") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhileStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "WhileStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWithStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "WithStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "AssignmentPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrayPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrowFunctionExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrowFunctionExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassBody(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportAllDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportAllDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportDefaultDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamedDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportNamedDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForOfStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ForOfStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDefaultSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportDefaultSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportNamespaceSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportNamespaceSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMetaProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "MetaProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadElement(node, opts) {
      if (!node) return false;
      if (node.type !== "SpreadElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSuper(node, opts) {
      if (!node) return false;
      if (node.type !== "Super") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTaggedTemplateExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TaggedTemplateExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateElement(node, opts) {
      if (!node) return false;
      if (node.type !== "TemplateElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "TemplateLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isYieldExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "YieldExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAwaitExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "AwaitExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImport(node, opts) {
      if (!node) return false;
      if (node.type !== "Import") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBigIntLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "BigIntLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamespaceSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportNamespaceSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalMemberExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "OptionalMemberExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalCallExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "OptionalCallExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassAccessorProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassAccessorProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassPrivateProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassPrivateMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivateName(node, opts) {
      if (!node) return false;
      if (node.type !== "PrivateName") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStaticBlock(node, opts) {
      if (!node) return false;
      if (node.type !== "StaticBlock") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAnyTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "AnyTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrayTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "BooleanTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "BooleanLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NullLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassImplements(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassImplements") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareClass(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareClass") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareFunction(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareFunction") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareInterface(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareInterface") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModule(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareModule") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModuleExports(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareModuleExports") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareTypeAlias(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareTypeAlias") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareOpaqueType(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareOpaqueType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareVariable(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareVariable") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareExportDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportAllDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareExportAllDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaredPredicate(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclaredPredicate") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExistsTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ExistsTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeParam(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionTypeParam") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isGenericTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "GenericTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInferredPredicate(node, opts) {
      if (!node) return false;
      if (node.type !== "InferredPredicate") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceExtends(node, opts) {
      if (!node) return false;
      if (node.type !== "InterfaceExtends") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "InterfaceDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "InterfaceTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIntersectionTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "IntersectionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMixedTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "MixedTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "EmptyTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullableTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NullableTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NumberLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NumberTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeInternalSlot(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeInternalSlot") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeCallProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeCallProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeIndexer(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeIndexer") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeSpreadProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeSpreadProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOpaqueType(node, opts) {
      if (!node) return false;
      if (node.type !== "OpaqueType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isQualifiedTypeIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "QualifiedTypeIdentifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "StringLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "StringTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSymbolTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "SymbolTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ThisTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TupleTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeofTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeofTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAlias(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeAlias") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeCastExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeCastExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameter(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeParameter") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeParameterDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterInstantiation(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeParameterInstantiation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnionTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "UnionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariance(node, opts) {
      if (!node) return false;
      if (node.type !== "Variance") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVoidTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "VoidTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumBooleanBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumNumberBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumStringBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumSymbolBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumSymbolBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumBooleanMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumNumberMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumStringMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDefaultedMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumDefaultedMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIndexedAccessType(node, opts) {
      if (!node) return false;
      if (node.type !== "IndexedAccessType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalIndexedAccessType(node, opts) {
      if (!node) return false;
      if (node.type !== "OptionalIndexedAccessType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXAttribute2(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXAttribute") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingElement(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXClosingElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXElement(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXEmptyExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXEmptyExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXExpressionContainer(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXExpressionContainer") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadChild(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXSpreadChild") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXIdentifier2(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXIdentifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXMemberExpression2(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXMemberExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXNamespacedName(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXNamespacedName") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningElement(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXOpeningElement") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadAttribute(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXSpreadAttribute") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXText(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXText") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXFragment(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXFragment") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningFragment(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXOpeningFragment") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingFragment(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXClosingFragment") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNoop(node, opts) {
      if (!node) return false;
      if (node.type !== "Noop") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPlaceholder(node, opts) {
      if (!node) return false;
      if (node.type !== "Placeholder") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isV8IntrinsicIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "V8IntrinsicIdentifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArgumentPlaceholder(node, opts) {
      if (!node) return false;
      if (node.type !== "ArgumentPlaceholder") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBindExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "BindExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportAttribute(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportAttribute") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecorator(node, opts) {
      if (!node) return false;
      if (node.type !== "Decorator") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "DoExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportDefaultSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRecordExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "RecordExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TupleExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecimalLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "DecimalLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ModuleExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTopicReference(node, opts) {
      if (!node) return false;
      if (node.type !== "TopicReference") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineTopicExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "PipelineTopicExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineBareFunction(node, opts) {
      if (!node) return false;
      if (node.type !== "PipelineBareFunction") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelinePrimaryTopicReference(node, opts) {
      if (!node) return false;
      if (node.type !== "PipelinePrimaryTopicReference") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParameterProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "TSParameterProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareFunction(node, opts) {
      if (!node) return false;
      if (node.type !== "TSDeclareFunction") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "TSDeclareMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSQualifiedName(node, opts) {
      if (!node) return false;
      if (node.type !== "TSQualifiedName") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSCallSignatureDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSCallSignatureDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructSignatureDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSConstructSignatureDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSPropertySignature(node, opts) {
      if (!node) return false;
      if (node.type !== "TSPropertySignature") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMethodSignature(node, opts) {
      if (!node) return false;
      if (node.type !== "TSMethodSignature") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexSignature(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIndexSignature") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAnyKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSAnyKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBooleanKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSBooleanKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBigIntKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSBigIntKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntrinsicKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIntrinsicKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNeverKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNeverKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNullKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNullKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNumberKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNumberKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSObjectKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSObjectKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSStringKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSStringKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSymbolKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSSymbolKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUndefinedKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSUndefinedKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnknownKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSUnknownKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSVoidKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSVoidKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSThisType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSThisType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSFunctionType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSFunctionType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructorType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSConstructorType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeReference(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeReference") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypePredicate(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypePredicate") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeQuery(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeQuery") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSArrayType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSArrayType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTupleType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTupleType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSOptionalType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSOptionalType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSRestType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSRestType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamedTupleMember(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNamedTupleMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnionType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSUnionType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntersectionType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIntersectionType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConditionalType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSConditionalType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInferType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInferType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParenthesizedType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSParenthesizedType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeOperator(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeOperator") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexedAccessType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIndexedAccessType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMappedType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSMappedType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTemplateLiteralType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTemplateLiteralType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSLiteralType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSLiteralType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExpressionWithTypeArguments(node, opts) {
      if (!node) return false;
      if (node.type !== "TSExpressionWithTypeArguments") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInterfaceDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceBody(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInterfaceBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAliasDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeAliasDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInstantiationExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInstantiationExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAsExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSAsExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSatisfiesExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSSatisfiesExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAssertion(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeAssertion") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumBody(node, opts) {
      if (!node) return false;
      if (node.type !== "TSEnumBody") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSEnumDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumMember(node, opts) {
      if (!node) return false;
      if (node.type !== "TSEnumMember") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSModuleDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleBlock(node, opts) {
      if (!node) return false;
      if (node.type !== "TSModuleBlock") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSImportType") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportEqualsDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSImportEqualsDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExternalModuleReference(node, opts) {
      if (!node) return false;
      if (node.type !== "TSExternalModuleReference") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNonNullExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNonNullExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExportAssignment(node, opts) {
      if (!node) return false;
      if (node.type !== "TSExportAssignment") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamespaceExportDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNamespaceExportDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterInstantiation(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeParameterInstantiation") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeParameterDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameter(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeParameter") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStandardized(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportExpression":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Identifier":
            case "StringLiteral":
            case "BlockStatement":
            case "ClassBody":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpression(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ImportExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Expression":
            case "Identifier":
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinary(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BinaryExpression":
        case "LogicalExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isScopable(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockParent(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlock(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStatement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Statement":
            case "Declaration":
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTerminatorless(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCompletionStatement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditional(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ConditionalExpression":
        case "IfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLoop(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhile(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "WhileStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionWrapper(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFor(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForXStatement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunction(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionParent(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPureish(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
          break;
        case "Placeholder":
          if (node.expectedNode === "Declaration") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPatternLike(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLVal(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEntityName(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "TSQualifiedName":
          break;
        case "Placeholder":
          if (node.expectedNode === "Identifier") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLiteral(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImmutable(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUserWhitespacable(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMethod(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMember(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProperty(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryLike(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPattern(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
          break;
        case "Placeholder":
          if (node.expectedNode === "Pattern") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClass(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ClassExpression":
        case "ClassDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportOrExportDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleSpecifier(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAccessor(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ClassAccessorProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivate(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlow(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowType(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowBaseAnnotation(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowPredicate(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBody(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumMember(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSX(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMiscellaneous(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeScript(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumBody":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeElement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSType(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBaseType(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
      if (!node) return false;
      if (node.type !== "NumberLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
      if (!node) return false;
      if (node.type !== "RegexLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestProperty(node, opts) {
      (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
      if (!node) return false;
      if (node.type !== "RestProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
      if (!node) return false;
      if (node.type !== "SpreadProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
      return isImportOrExportDeclaration(node, opts);
    }
  }
});

// node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
  "node_modules/@babel/types/lib/validators/matchesPattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = matchesPattern;
    var _index = require_generated();
    function matchesPattern(member, match, allowPartial) {
      if (!(0, _index.isMemberExpression)(member)) return false;
      const parts = Array.isArray(match) ? match : match.split(".");
      const nodes = [];
      let node;
      for (node = member; (0, _index.isMemberExpression)(node); node = node.object) {
        nodes.push(node.property);
      }
      nodes.push(node);
      if (nodes.length < parts.length) return false;
      if (!allowPartial && nodes.length > parts.length) return false;
      for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        const node2 = nodes[j];
        let value;
        if ((0, _index.isIdentifier)(node2)) {
          value = node2.name;
        } else if ((0, _index.isStringLiteral)(node2)) {
          value = node2.value;
        } else if ((0, _index.isThisExpression)(node2)) {
          value = "this";
        } else {
          return false;
        }
        if (parts[i] !== value) return false;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = buildMatchMemberExpression;
    var _matchesPattern = require_matchesPattern();
    function buildMatchMemberExpression(match, allowPartial) {
      const parts = match.split(".");
      return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
    }
  }
});

// node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
    var _default = exports2.default = isReactComponent;
  }
});

// node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
  }
});

// node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
  "node_modules/@babel/types/lib/validators/isType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isType;
    var _index = require_definitions();
    function isType(nodeType, targetType) {
      if (nodeType === targetType) return true;
      if (nodeType == null) return false;
      if (_index.ALIAS_KEYS[targetType]) return false;
      const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType) return true;
        for (const alias of aliases) {
          if (nodeType === alias) return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
  "node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isPlaceholderType;
    var _index = require_definitions();
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType) return true;
      const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
      if (aliases) {
        for (const alias of aliases) {
          if (targetType === alias) return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
  "node_modules/@babel/types/lib/validators/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = is;
    var _shallowEqual = require_shallowEqual();
    var _isType = require_isType();
    var _isPlaceholderType = require_isPlaceholderType();
    var _index = require_definitions();
    function is(type, node, opts) {
      if (!node) return false;
      const matches = (0, _isType.default)(node.type, type);
      if (!matches) {
        if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
          return (0, _isPlaceholderType.default)(node.expectedNode, type);
        }
        return false;
      }
      if (opts === void 0) {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65) return code === 36;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48) return code === 36;
      if (code < 58) return true;
      if (code < 65) return false;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isKeyword = isKeyword;
    exports2.isReservedWord = isReservedWord;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isValidIdentifier;
    var _helperValidatorIdentifier = require_lib2();
    function isValidIdentifier(name, reserved = true) {
      if (typeof name !== "string") return false;
      if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
          return false;
        }
      }
      return (0, _helperValidatorIdentifier.isIdentifierName)(name);
    }
  }
});

// node_modules/@babel/helper-string-parser/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@babel/helper-string-parser/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.readCodePoint = readCodePoint;
    exports2.readInt = readInt;
    exports2.readStringContents = readStringContents;
    var _isDigit = function isDigit(code) {
      return code >= 48 && code <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCharCode(code));
        }
        case 117: {
          let code;
          ({
            code,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCodePoint(code));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code = input.charCodeAt(pos);
        let val;
        if (code === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code;
      if (ch === 123) {
        ++pos;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code !== null && code > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code,
        pos
      };
    }
  }
});

// node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS({
  "node_modules/@babel/types/lib/constants/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UPDATE_OPERATORS = exports2.UNARY_OPERATORS = exports2.STRING_UNARY_OPERATORS = exports2.STATEMENT_OR_BLOCK_KEYS = exports2.NUMBER_UNARY_OPERATORS = exports2.NUMBER_BINARY_OPERATORS = exports2.NOT_LOCAL_BINDING = exports2.LOGICAL_OPERATORS = exports2.INHERIT_KEYS = exports2.FOR_INIT_KEYS = exports2.FLATTENABLE_KEYS = exports2.EQUALITY_BINARY_OPERATORS = exports2.COMPARISON_BINARY_OPERATORS = exports2.COMMENT_KEYS = exports2.BOOLEAN_UNARY_OPERATORS = exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = exports2.BOOLEAN_BINARY_OPERATORS = exports2.BLOCK_SCOPED_SYMBOL = exports2.BINARY_OPERATORS = exports2.ASSIGNMENT_OPERATORS = void 0;
    var STATEMENT_OR_BLOCK_KEYS = exports2.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    var FLATTENABLE_KEYS = exports2.FLATTENABLE_KEYS = ["body", "expressions"];
    var FOR_INIT_KEYS = exports2.FOR_INIT_KEYS = ["left", "init"];
    var COMMENT_KEYS = exports2.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    var LOGICAL_OPERATORS = exports2.LOGICAL_OPERATORS = ["||", "&&", "??"];
    var UPDATE_OPERATORS = exports2.UPDATE_OPERATORS = ["++", "--"];
    var BOOLEAN_NUMBER_BINARY_OPERATORS = exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    var EQUALITY_BINARY_OPERATORS = exports2.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    var COMPARISON_BINARY_OPERATORS = exports2.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
    var BOOLEAN_BINARY_OPERATORS = exports2.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
    var NUMBER_BINARY_OPERATORS = exports2.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    var BINARY_OPERATORS = exports2.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
    var ASSIGNMENT_OPERATORS = exports2.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
    var BOOLEAN_UNARY_OPERATORS = exports2.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    var NUMBER_UNARY_OPERATORS = exports2.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    var STRING_UNARY_OPERATORS = exports2.STRING_UNARY_OPERATORS = ["typeof"];
    var UNARY_OPERATORS = exports2.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
    var INHERIT_KEYS = exports2.INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    var BLOCK_SCOPED_SYMBOL = exports2.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    var NOT_LOCAL_BINDING = exports2.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  }
});

// node_modules/@babel/types/lib/definitions/utils.js
var require_utils = __commonJS({
  "node_modules/@babel/types/lib/definitions/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VISITOR_KEYS = exports2.NODE_PARENT_VALIDATIONS = exports2.NODE_FIELDS = exports2.FLIPPED_ALIAS_KEYS = exports2.DEPRECATED_KEYS = exports2.BUILDER_KEYS = exports2.ALIAS_KEYS = void 0;
    exports2.arrayOf = arrayOf;
    exports2.arrayOfType = arrayOfType;
    exports2.assertEach = assertEach;
    exports2.assertNodeOrValueType = assertNodeOrValueType;
    exports2.assertNodeType = assertNodeType;
    exports2.assertOneOf = assertOneOf;
    exports2.assertOptionalChainStart = assertOptionalChainStart;
    exports2.assertShape = assertShape;
    exports2.assertValueType = assertValueType;
    exports2.chain = chain;
    exports2.default = defineType;
    exports2.defineAliasedType = defineAliasedType;
    exports2.validate = validate;
    exports2.validateArrayOfType = validateArrayOfType;
    exports2.validateOptional = validateOptional;
    exports2.validateOptionalType = validateOptionalType;
    exports2.validateType = validateType;
    var _is = require_is();
    var _validate = require_validate();
    var VISITOR_KEYS = exports2.VISITOR_KEYS = {};
    var ALIAS_KEYS = exports2.ALIAS_KEYS = {};
    var FLIPPED_ALIAS_KEYS = exports2.FLIPPED_ALIAS_KEYS = {};
    var NODE_FIELDS = exports2.NODE_FIELDS = {};
    var BUILDER_KEYS = exports2.BUILDER_KEYS = {};
    var DEPRECATED_KEYS = exports2.DEPRECATED_KEYS = {};
    var NODE_PARENT_VALIDATIONS = exports2.NODE_PARENT_VALIDATIONS = {};
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val;
      }
    }
    function validate(validate2) {
      return {
        validate: validate2
      };
    }
    function validateType(...typeNames) {
      return validate(assertNodeType(...typeNames));
    }
    function validateOptional(validate2) {
      return {
        validate: validate2,
        optional: true
      };
    }
    function validateOptionalType(...typeNames) {
      return {
        validate: assertNodeType(...typeNames),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(...typeNames) {
      return arrayOf(assertNodeType(...typeNames));
    }
    function validateArrayOfType(...typeNames) {
      return validate(arrayOfType(...typeNames));
    }
    function assertEach(callback) {
      const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {
      };
      function validator(node, key, val) {
        if (!Array.isArray(val)) return;
        for (let i = 0; i < val.length; i++) {
          const subkey = `${key}[${i}]`;
          const v = val[i];
          callback(node, subkey, v);
          childValidator(node, subkey, v);
        }
      }
      validator.each = callback;
      return validator;
    }
    function assertOneOf(...values) {
      function validate2(node, key, val) {
        if (!values.includes(val)) {
          throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
      }
      validate2.oneOf = values;
      return validate2;
    }
    function assertNodeType(...types) {
      function validate2(node, key, val) {
        for (const type of types) {
          if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeTypes = types;
      return validate2;
    }
    function assertNodeOrValueType(...types) {
      function validate2(node, key, val) {
        for (const type of types) {
          if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeOrValueTypes = types;
      return validate2;
    }
    function assertValueType(type) {
      function validate2(node, key, val) {
        const valid = getType(val) === type;
        if (!valid) {
          throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
        }
      }
      validate2.type = type;
      return validate2;
    }
    function assertShape(shape) {
      function validate2(node, key, val) {
        const errors = [];
        for (const property of Object.keys(shape)) {
          try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
        }
        if (errors.length) {
          throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
        }
      }
      validate2.shapeOf = shape;
      return validate2;
    }
    function assertOptionalChainStart() {
      function validate2(node) {
        var _current;
        let current = node;
        while (node) {
          const {
            type
          } = current;
          if (type === "OptionalCallExpression") {
            if (current.optional) return;
            current = current.callee;
            continue;
          }
          if (type === "OptionalMemberExpression") {
            if (current.optional) return;
            current = current.object;
            continue;
          }
          break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
      }
      return validate2;
    }
    function chain(...fns) {
      function validate2(...args) {
        for (const fn of fns) {
          fn(...args);
        }
      }
      validate2.chainOf = fns;
      if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
      }
      return validate2;
    }
    var validTypeOpts = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]);
    var validFieldKeys = /* @__PURE__ */ new Set(["default", "optional", "deprecated", "validate"]);
    var store = {};
    function defineAliasedType(...aliases) {
      return (type, opts = {}) => {
        let defined = opts.aliases;
        if (!defined) {
          var _store$opts$inherits$, _defined;
          if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
          (_defined = defined) != null ? _defined : defined = [];
          opts.aliases = defined;
        }
        const additional = aliases.filter((a) => !defined.includes(a));
        defined.unshift(...additional);
        defineType(type, opts);
      };
    }
    function defineType(type, opts = {}) {
      const inherits = opts.inherits && store[opts.inherits] || {};
      let fields = opts.fields;
      if (!fields) {
        fields = {};
        if (inherits.fields) {
          const keys = Object.getOwnPropertyNames(inherits.fields);
          for (const key of keys) {
            const field = inherits.fields[key];
            const def = field.default;
            if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
              throw new Error("field defaults can only be primitives or empty arrays currently");
            }
            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              deprecated: field.deprecated,
              validate: field.validate
            };
          }
        }
      }
      const visitor = opts.visitor || inherits.visitor || [];
      const aliases = opts.aliases || inherits.aliases || [];
      const builder = opts.builder || inherits.builder || opts.visitor || [];
      for (const k of Object.keys(opts)) {
        if (!validTypeOpts.has(k)) {
          throw new Error(`Unknown type option "${k}" on ${type}`);
        }
      }
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
      }
      for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
      }
      for (const key of Object.keys(fields)) {
        const field = fields[key];
        if (field.default !== void 0 && !builder.includes(key)) {
          field.optional = true;
        }
        if (field.default === void 0) {
          field.default = null;
        } else if (!field.validate && field.default != null) {
          field.validate = assertValueType(getType(field.default));
        }
        for (const k of Object.keys(field)) {
          if (!validFieldKeys.has(k)) {
            throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
          }
        }
      }
      VISITOR_KEYS[type] = opts.visitor = visitor;
      BUILDER_KEYS[type] = opts.builder = builder;
      NODE_FIELDS[type] = opts.fields = fields;
      ALIAS_KEYS[type] = opts.aliases = aliases;
      aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
      });
      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
      }
      store[type] = opts;
    }
  }
});

// node_modules/@babel/types/lib/definitions/core.js
var require_core = __commonJS({
  "node_modules/@babel/types/lib/definitions/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.patternLikeCommon = exports2.importAttributes = exports2.functionTypeAnnotationCommon = exports2.functionDeclarationCommon = exports2.functionCommon = exports2.classMethodOrPropertyCommon = exports2.classMethodOrDeclareMethodCommon = void 0;
    var _is = require_is();
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib2();
    var _helperStringParser = require_lib3();
    var _index = require_constants();
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("Standardized");
    defineType("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
          default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    defineType("AssignmentExpression", {
      fields: {
        operator: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function() {
            const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
            const pattern = (0, _utils.assertOneOf)("=");
            return function(node, key, val) {
              const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
              validator(node, key, val);
            };
          }(), {
            type: "string"
          })
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    defineType("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
        },
        left: {
          validate: function() {
            const expression = (0, _utils.assertNodeType)("Expression");
            const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.operator === "in" ? inOp : expression;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "PrivateName"]
            });
            return validator;
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    defineType("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    defineType("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _utils.arrayOfType)("Directive"),
          default: []
        },
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    defineType("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("CallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        }
      }, {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    defineType("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    defineType("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    defineType("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("DebuggerStatement", {
      aliases: ["Statement"]
    });
    defineType("DoWhileStatement", {
      builder: ["test", "body"],
      visitor: ["body", "test"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    defineType("EmptyStatement", {
      aliases: ["Statement"]
    });
    defineType("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    defineType("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
          }, {
            each: {
              oneOfNodeTypes: ["CommentBlock", "CommentLine"]
            }
          }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
          optional: true
        },
        tokens: {
          validate: (0, _utils.assertEach)(Object.assign(() => {
          }, {
            type: "any"
          })),
          optional: true
        }
      }
    });
    defineType("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        update: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    var functionCommon = () => ({
      params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
      generator: {
        default: false
      },
      async: {
        default: false
      }
    });
    exports2.functionCommon = functionCommon;
    var functionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    exports2.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    });
    exports2.functionDeclarationCommon = functionDeclarationCommon;
    defineType("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
      fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    var patternLikeCommon = () => ({
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    });
    exports2.patternLikeCommon = patternLikeCommon;
    defineType("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon(), {
        name: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!(0, _isValidIdentifier.default)(val, false)) {
              throw new TypeError(`"${val}" is not a valid identifier name`);
            }
          }, {
            type: "string"
          })) : (0, _utils.assertValueType)("string")
        }
      }),
      validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key, node) {
        const match = /\.(\w+)$/.exec(key);
        if (!match) return;
        const [, parentKey] = match;
        const nonComp = {
          computed: false
        };
        if (parentKey === "property") {
          if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
          if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
        } else if (parentKey === "key") {
          if ((0, _is.default)("Property", parent, nonComp)) return;
          if ((0, _is.default)("Method", parent, nonComp)) return;
        } else if (parentKey === "exported") {
          if ((0, _is.default)("ExportSpecifier", parent)) return;
        } else if (parentKey === "imported") {
          if ((0, _is.default)("ImportSpecifier", parent, {
            imported: node
          })) return;
        } else if (parentKey === "meta") {
          if ((0, _is.default)("MetaProperty", parent, {
            meta: node
          })) return;
        }
        if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
          throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
      } : void 0
    });
    defineType("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node, key, val) {
            if (1 / val < 0 || !Number.isFinite(val)) {
              const error = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${val}) instead.`);
              {
              }
            }
          }, {
            type: "number"
          }))
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)("string")
        },
        flags: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            const invalid = /[^gimsuy]/.exec(val);
            if (invalid) {
              throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
            }
          }, {
            type: "string"
          })) : (0, _utils.assertValueType)("string"),
          default: ""
        }
      }
    });
    defineType("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("MemberExpression", {
      builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: Object.assign({
        object: {
          validate: (0, _utils.assertNodeType)("Expression", "Super")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
            return validator;
          }()
        },
        computed: {
          default: false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      } : {})
    });
    defineType("NewExpression", {
      inherits: "CallExpression"
    });
    defineType("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceType: {
          validate: (0, _utils.assertOneOf)("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: true
        },
        directives: {
          validate: (0, _utils.arrayOfType)("Directive"),
          default: []
        },
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    defineType("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
      }
    });
    defineType("ObjectMethod", {
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          default: "method"
        } : {}),
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
            return validator;
          }()
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    defineType("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
      fields: {
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
            });
            return validator;
          }()
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, shorthand) {
            if (!shorthand) return;
            if (node.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
            if (!(0, _is.default)("Identifier", node.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }, {
            type: "boolean"
          })) : (0, _utils.assertValueType)("boolean"),
          default: false
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        }
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
          const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
          validator(node, "value", node.value);
        };
      }()
    });
    defineType("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["LVal", "PatternLike"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon(), {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        }
      }),
      validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key) {
        const match = /(\w+)\[(\d+)\]/.exec(key);
        if (!match) throw new Error("Internal Babel error: malformed key.");
        const [, listKey, index] = match;
        if (parent[listKey].length > +index + 1) {
          throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      } : void 0
    });
    defineType("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: (0, _utils.validateArrayOfType)("Expression")
      },
      aliases: ["Expression"]
    });
    defineType("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        consequent: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: (0, _utils.validateArrayOfType)("SwitchCase")
      }
    });
    defineType("ThisExpression", {
      aliases: ["Expression"]
    });
    defineType("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
            if (!node.handler && !node.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          }, {
            oneOfNodeTypes: ["BlockStatement"]
          })) : (0, _utils.assertNodeType)("BlockStatement")
        },
        handler: {
          optional: true,
          validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }
    });
    defineType("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    defineType("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    defineType("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        kind: {
          validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
        },
        declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
      },
      validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
        const withoutInit = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if ((0, _is.default)("ForXStatement", parent, {
            left: node
          })) {
            if (node.declarations.length !== 1) {
              throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
            }
          } else {
            node.declarations.forEach((decl) => {
              if (!decl.init) withoutInit(decl, "id", decl.id);
            });
          }
        };
      })() : void 0
    });
    defineType("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
        },
        definite: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        left: {
          validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        }
      })
    });
    defineType("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
        }
      })
    });
    defineType("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
          validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    defineType("ClassBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
      }
    });
    defineType("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        ["superTypeParameters"]: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        }
      }
    });
    defineType("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        ["superTypeParameters"]: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      },
      validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    var importAttributes = exports2.importAttributes = {
      attributes: {
        optional: true,
        validate: (0, _utils.arrayOfType)("ImportAttribute")
      },
      assertions: {
        deprecated: true,
        optional: true,
        validate: (0, _utils.arrayOfType)("ImportAttribute")
      }
    };
    defineType("ExportAllDeclaration", {
      builder: ["source"],
      visitor: ["source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: Object.assign({
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }, importAttributes)
    });
    defineType("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
      }
    });
    defineType("ExportNamedDeclaration", {
      builder: ["declaration", "specifiers", "source"],
      visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: Object.assign({
        declaration: {
          optional: true,
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
            if (val && node.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
            if (val && node.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          }, {
            oneOfNodeTypes: ["Declaration"]
          })) : (0, _utils.assertNodeType)("Declaration")
        }
      }, importAttributes, {
        specifiers: {
          default: [],
          validate: (0, _utils.arrayOf)(function() {
            const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
            return Object.assign(function(node, key, val) {
              const validator = node.source ? sourced : sourceless;
              validator(node, key, val);
            }, {
              oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
            });
          }())
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral"),
          optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      })
    });
    defineType("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }
            const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
            const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
            return Object.assign(function(node, key, val) {
              if ((0, _is.default)("VariableDeclaration", val)) {
                declaration(node, key, val);
              } else {
                lval(node, key, val);
              }
            }, {
              oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
            });
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
          default: false
        }
      }
    });
    defineType("ImportDeclaration", {
      builder: ["specifiers", "source"],
      visitor: ["specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
      fields: Object.assign({}, importAttributes, {
        module: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      })
    });
    defineType("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportSpecifier", {
      visitor: ["imported", "local"],
      builder: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportExpression", {
      visitor: ["source", "options"],
      aliases: ["Expression"],
      fields: {
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        source: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        options: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
            let property;
            switch (val.name) {
              case "function":
                property = "sent";
                break;
              case "new":
                property = "target";
                break;
              case "import":
                property = "meta";
                break;
            }
            if (!(0, _is.default)("Identifier", node.property, {
              name: property
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          }, {
            oneOfNodeTypes: ["Identifier"]
          })) : (0, _utils.assertNodeType)("Identifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = () => ({
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      static: {
        default: false
      },
      override: {
        default: false
      },
      computed: {
        default: false
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    });
    exports2.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    });
    exports2.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    defineType("ClassMethod", {
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("ObjectPattern", {
      visitor: ["properties", "typeAnnotation", "decorators"],
      builder: ["properties"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
      })
    });
    defineType("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Super", {
      aliases: ["Expression"]
    });
    defineType("TaggedTemplateExpression", {
      visitor: ["tag", "typeParameters", "quasi"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        ["typeParameters"]: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)("string")
            },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true
            }
          }), function templateElementCookedValidator(node) {
            const raw = node.value.raw;
            let unterminatedCalled = false;
            const error = () => {
              throw new Error("Internal @babel/types error.");
            };
            const {
              str,
              firstInvalidLoc
            } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
              unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            });
            if (!unterminatedCalled) throw new Error("Invalid raw");
            node.value.cooked = firstInvalidLoc ? null : str;
          })
        },
        tail: {
          default: false
        }
      }
    });
    defineType("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (val && !node.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }, {
            type: "boolean"
          })) : (0, _utils.assertValueType)("boolean"),
          default: false
        },
        argument: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Import", {
      aliases: ["Expression"]
    });
    defineType("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier"]
            });
            return validator;
          }()
        },
        computed: {
          default: false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        }
      }
    });
    defineType("OptionalCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        }
      }, {
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("ClassProperty", {
      visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassAccessorProperty", {
      visitor: ["decorators", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property", "Accessor"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassPrivateProperty", {
      visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        static: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      }
    });
    defineType("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method"
        },
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "FunctionParent"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS({
  "node_modules/@babel/types/lib/definitions/flow.js"() {
    "use strict";
    var _core = require_core();
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("Flow");
    var defineInterfaceishType = (name) => {
      const isDeclareClass = name === "DeclareClass";
      defineType(name, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign({
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
        }, isDeclareClass ? {
          mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
        } : {}, {
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        })
      });
    };
    defineType("AnyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["FlowType"],
      fields: {
        elementType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("BooleanTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("NullLiteralTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ClassImplements", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType("DeclareFunction", {
      builder: ["id"],
      visitor: ["id", "predicate"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
      }
    });
    defineType("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
      }
    });
    defineType("DeclareVariable", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source", "attributes"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }, _core.importAttributes)
    });
    defineType("DeclareExportAllDeclaration", {
      visitor: ["source", "attributes"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }, _core.importAttributes)
    });
    defineType("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["FlowPredicate"],
      fields: {
        value: (0, _utils.validateType)("Flow")
      }
    });
    defineType("ExistsTypeAnnotation", {
      aliases: ["FlowType"]
    });
    defineType("FunctionTypeAnnotation", {
      builder: ["typeParameters", "params", "rest", "returnType"],
      visitor: ["typeParameters", "this", "params", "rest", "returnType"],
      aliases: ["FlowType"],
      fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["FlowType"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineType("InferredPredicate", {
      aliases: ["FlowPredicate"]
    });
    defineType("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["FlowType"],
      fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
    defineType("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("MixedTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EmptyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowType"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
      }
    });
    defineType("NumberTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
        indexers: {
          validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
          optional: true,
          default: []
        },
        callProperties: {
          validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
          optional: true,
          default: []
        },
        internalSlots: {
          validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
          optional: true,
          default: []
        },
        exact: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeInternalSlot", {
      visitor: ["id", "value"],
      builder: ["id", "value", "optional", "static", "method"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["UserWhitespacable"],
      fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeIndexer", {
      visitor: ["variance", "id", "key", "value"],
      builder: ["id", "key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        key: (0, _utils.validateType)("Identifier", "StringLiteral"),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["UserWhitespacable"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("QualifiedTypeIdentifier", {
      visitor: ["qualification", "id"],
      builder: ["id", "qualification"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
      }
    });
    defineType("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
      }
    });
    defineType("StringTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("SymbolTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ThisTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["FlowType"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["ExpressionWrapper", "Expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("TypeParameter", {
      visitor: ["bound", "default", "variance"],
      fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("TypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
      }
    });
    defineType("TypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("Variance", {
      builder: ["kind"],
      fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
      }
    });
    defineType("VoidTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
      }
    });
    defineType("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumBooleanMember", {
      aliases: ["EnumMember"],
      builder: ["id"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
      }
    });
    defineType("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
      }
    });
    defineType("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("IndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OptionalIndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS({
  "node_modules/@babel/types/lib/definitions/jsx.js"() {
    "use strict";
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("JSX");
    defineType("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["Immutable", "Expression"],
      fields: Object.assign({
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
      }, {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    defineType("JSXEmptyExpression", {});
    defineType("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXMemberExpression", {
      visitor: ["object", "property"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      fields: {
        namespace: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "typeParameters", "typeArguments", "attributes"],
      aliases: ["Immutable"],
      fields: Object.assign({
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: false
        },
        attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        }
      }, {
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("JSXSpreadAttribute", {
      visitor: ["argument"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXText", {
      aliases: ["Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
          validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
      }
    });
    defineType("JSXOpeningFragment", {
      aliases: ["Immutable"]
    });
    defineType("JSXClosingFragment", {
      aliases: ["Immutable"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
  "node_modules/@babel/types/lib/definitions/placeholders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PLACEHOLDERS_FLIPPED_ALIAS = exports2.PLACEHOLDERS_ALIAS = exports2.PLACEHOLDERS = void 0;
    var _utils = require_utils();
    var PLACEHOLDERS = exports2.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    var PLACEHOLDERS_ALIAS = exports2.PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };
    for (const type of PLACEHOLDERS) {
      const alias = _utils.ALIAS_KEYS[type];
      if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
    }
    var PLACEHOLDERS_FLIPPED_ALIAS = exports2.PLACEHOLDERS_FLIPPED_ALIAS = {};
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
      PLACEHOLDERS_ALIAS[type].forEach((alias) => {
        if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });
  }
});

// node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
  "node_modules/@babel/types/lib/definitions/misc.js"() {
    "use strict";
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var _core = require_core();
    var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
    {
      defineType("Noop", {
        visitor: []
      });
    }
    defineType("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: Object.assign({
        name: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
          validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
      }, (0, _core.patternLikeCommon)())
    });
    defineType("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "node_modules/@babel/types/lib/definitions/experimental.js"() {
    "use strict";
    var _utils = require_utils();
    (0, _utils.default)("ArgumentPlaceholder", {});
    (0, _utils.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        },
        callee: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        }
      } : {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("ImportAttribute", {
      visitor: ["key", "value"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        }
      }
    });
    (0, _utils.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("DoExpression", {
      visitor: ["body"],
      builder: ["body", "async"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _utils.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
      }
    });
    (0, _utils.default)("TupleExpression", {
      fields: {
        elements: {
          validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    {
      (0, _utils.default)("DecimalLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
    }
    (0, _utils.default)("ModuleExpression", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("Program")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("TopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS({
  "node_modules/@babel/types/lib/definitions/typescript.js"() {
    "use strict";
    var _utils = require_utils();
    var _core = require_core();
    var _is = require_is();
    var defineType = (0, _utils.defineAliasedType)("TypeScript");
    var bool = (0, _utils.assertValueType)("boolean");
    var tSFunctionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    defineType("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        parameter: {
          validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSDeclareMethod", {
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
      }
    });
    var signatureDeclarationCommon = () => ({
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      ["parameters"]: (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
      ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    });
    var callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon()
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = () => ({
      key: (0, _utils.validateType)("Expression"),
      computed: {
        default: false
      },
      optional: (0, _utils.validateOptional)(bool)
    });
    defineType("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation"],
      fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        kind: {
          optional: true,
          validate: (0, _utils.assertOneOf)("get", "set")
        }
      })
    });
    defineType("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
      })
    });
    defineType("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (const type of tsKeywordTypes) {
      defineType(type, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    }
    defineType("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"]
    };
    defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon()
    }));
    defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool)
      })
    }));
    defineType("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName", "typeParameters"],
      fields: {
        exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
      }
    });
    defineType("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSNamedTupleMember", {
      visitor: ["label", "elementType"],
      builder: ["label", "elementType", "optional"],
      fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
          validate: bool,
          default: false
        },
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "nameType", "typeAnnotation"],
      builder: ["typeParameter", "typeAnnotation", "nameType"],
      fields: Object.assign({}, {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }, {
        readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
      })
    });
    defineType("TSTemplateLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["quasis", "types"],
      fields: {
        quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
        types: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of types.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: {
          validate: function() {
            const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
            const unaryOperator = (0, _utils.assertOneOf)("-");
            const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
            function validator(parent, key, node) {
              if ((0, _is.default)("UnaryExpression", node)) {
                unaryOperator(node, "operator", node.operator);
                unaryExpression(node, "argument", node.argument);
              } else {
                literal(parent, key, node);
              }
            }
            validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
            return validator;
          }()
        }
      }
    });
    {
      defineType("TSExpressionWithTypeArguments", {
        aliases: ["TSType"],
        visitor: ["expression", "typeParameters"],
        fields: {
          expression: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
    }
    defineType("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInstantiationExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    var TSTypeExpression = {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    };
    defineType("TSAsExpression", TSTypeExpression);
    defineType("TSSatisfiesExpression", TSTypeExpression);
    defineType("TSTypeAssertion", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSEnumBody", {
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSEnumMember")
      }
    });
    {
      defineType("TSEnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "members"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          const: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          members: (0, _utils.validateArrayOfType)("TSEnumMember"),
          initializer: (0, _utils.validateOptionalType)("Expression"),
          body: (0, _utils.validateOptionalType)("TSEnumBody")
        }
      });
    }
    defineType("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: Object.assign({
        kind: {
          validate: (0, _utils.assertOneOf)("global", "module", "namespace")
        },
        declare: (0, _utils.validateOptional)(bool)
      }, {
        global: (0, _utils.validateOptional)(bool)
      }, {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
      })
    });
    defineType("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: ["TSType"],
      builder: ["argument", "qualifier", "typeParameters"],
      visitor: ["argument", "options", "qualifier", "typeParameters"],
      fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),
        options: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "moduleReference"],
      fields: Object.assign({}, {
        isExport: (0, _utils.validate)(bool)
      }, {
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      })
    });
    defineType("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validateArrayOfType)("TSType")
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validateArrayOfType)("TSTypeParameter")
      }
    });
    defineType("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        },
        in: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        out: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        const: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        constraint: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        },
        default: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS({
  "node_modules/@babel/types/lib/definitions/deprecated-aliases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DEPRECATED_ALIASES = void 0;
    var DEPRECATED_ALIASES = exports2.DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
  }
});

// node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
  "node_modules/@babel/types/lib/definitions/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports2, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports2, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports2, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports2, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports2, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports2, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports2, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports2, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports2, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports2.TYPES = void 0;
    Object.defineProperty(exports2, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    require_core();
    require_flow();
    require_jsx();
    require_misc();
    require_experimental();
    require_typescript();
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var _deprecatedAliases = require_deprecated_aliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    var TYPES = exports2.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
  }
});

// node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS({
  "node_modules/@babel/types/lib/validators/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = validate;
    exports2.validateChild = validateChild;
    exports2.validateField = validateField;
    exports2.validateInternal = validateInternal;
    var _index = require_definitions();
    function validate(node, key, val) {
      if (!node) return;
      const fields = _index.NODE_FIELDS[node.type];
      if (!fields) return;
      const field = fields[key];
      validateField(node, key, val, field);
      validateChild(node, key, val);
    }
    function validateInternal(field, node, key, val, maybeNode) {
      if (!(field != null && field.validate)) return;
      if (field.optional && val == null) return;
      field.validate(node, key, val);
      if (maybeNode) {
        var _NODE_PARENT_VALIDATI;
        const type = val.type;
        if (type == null) return;
        (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
      }
    }
    function validateField(node, key, val, field) {
      if (!(field != null && field.validate)) return;
      if (field.optional && val == null) return;
      field.validate(node, key, val);
    }
    function validateChild(node, key, val) {
      var _NODE_PARENT_VALIDATI2;
      const type = val == null ? void 0 : val.type;
      if (type == null) return;
      (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/lowercase.js
var require_lowercase = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/lowercase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.anyTypeAnnotation = anyTypeAnnotation;
    exports2.argumentPlaceholder = argumentPlaceholder;
    exports2.arrayExpression = arrayExpression;
    exports2.arrayPattern = arrayPattern;
    exports2.arrayTypeAnnotation = arrayTypeAnnotation;
    exports2.arrowFunctionExpression = arrowFunctionExpression;
    exports2.assignmentExpression = assignmentExpression;
    exports2.assignmentPattern = assignmentPattern;
    exports2.awaitExpression = awaitExpression;
    exports2.bigIntLiteral = bigIntLiteral;
    exports2.binaryExpression = binaryExpression;
    exports2.bindExpression = bindExpression;
    exports2.blockStatement = blockStatement;
    exports2.booleanLiteral = booleanLiteral;
    exports2.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports2.booleanTypeAnnotation = booleanTypeAnnotation;
    exports2.breakStatement = breakStatement;
    exports2.callExpression = callExpression;
    exports2.catchClause = catchClause;
    exports2.classAccessorProperty = classAccessorProperty;
    exports2.classBody = classBody;
    exports2.classDeclaration = classDeclaration;
    exports2.classExpression = classExpression;
    exports2.classImplements = classImplements;
    exports2.classMethod = classMethod;
    exports2.classPrivateMethod = classPrivateMethod;
    exports2.classPrivateProperty = classPrivateProperty;
    exports2.classProperty = classProperty;
    exports2.conditionalExpression = conditionalExpression;
    exports2.continueStatement = continueStatement;
    exports2.debuggerStatement = debuggerStatement;
    exports2.decimalLiteral = decimalLiteral;
    exports2.declareClass = declareClass;
    exports2.declareExportAllDeclaration = declareExportAllDeclaration;
    exports2.declareExportDeclaration = declareExportDeclaration;
    exports2.declareFunction = declareFunction;
    exports2.declareInterface = declareInterface;
    exports2.declareModule = declareModule;
    exports2.declareModuleExports = declareModuleExports;
    exports2.declareOpaqueType = declareOpaqueType;
    exports2.declareTypeAlias = declareTypeAlias;
    exports2.declareVariable = declareVariable;
    exports2.declaredPredicate = declaredPredicate;
    exports2.decorator = decorator;
    exports2.directive = directive;
    exports2.directiveLiteral = directiveLiteral;
    exports2.doExpression = doExpression;
    exports2.doWhileStatement = doWhileStatement;
    exports2.emptyStatement = emptyStatement;
    exports2.emptyTypeAnnotation = emptyTypeAnnotation;
    exports2.enumBooleanBody = enumBooleanBody;
    exports2.enumBooleanMember = enumBooleanMember;
    exports2.enumDeclaration = enumDeclaration;
    exports2.enumDefaultedMember = enumDefaultedMember;
    exports2.enumNumberBody = enumNumberBody;
    exports2.enumNumberMember = enumNumberMember;
    exports2.enumStringBody = enumStringBody;
    exports2.enumStringMember = enumStringMember;
    exports2.enumSymbolBody = enumSymbolBody;
    exports2.existsTypeAnnotation = existsTypeAnnotation;
    exports2.exportAllDeclaration = exportAllDeclaration;
    exports2.exportDefaultDeclaration = exportDefaultDeclaration;
    exports2.exportDefaultSpecifier = exportDefaultSpecifier;
    exports2.exportNamedDeclaration = exportNamedDeclaration;
    exports2.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports2.exportSpecifier = exportSpecifier;
    exports2.expressionStatement = expressionStatement;
    exports2.file = file;
    exports2.forInStatement = forInStatement;
    exports2.forOfStatement = forOfStatement;
    exports2.forStatement = forStatement;
    exports2.functionDeclaration = functionDeclaration;
    exports2.functionExpression = functionExpression;
    exports2.functionTypeAnnotation = functionTypeAnnotation;
    exports2.functionTypeParam = functionTypeParam;
    exports2.genericTypeAnnotation = genericTypeAnnotation;
    exports2.identifier = identifier;
    exports2.ifStatement = ifStatement;
    exports2.import = _import;
    exports2.importAttribute = importAttribute;
    exports2.importDeclaration = importDeclaration;
    exports2.importDefaultSpecifier = importDefaultSpecifier;
    exports2.importExpression = importExpression;
    exports2.importNamespaceSpecifier = importNamespaceSpecifier;
    exports2.importSpecifier = importSpecifier;
    exports2.indexedAccessType = indexedAccessType;
    exports2.inferredPredicate = inferredPredicate;
    exports2.interfaceDeclaration = interfaceDeclaration;
    exports2.interfaceExtends = interfaceExtends;
    exports2.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports2.interpreterDirective = interpreterDirective;
    exports2.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports2.jSXAttribute = exports2.jsxAttribute = jsxAttribute;
    exports2.jSXClosingElement = exports2.jsxClosingElement = jsxClosingElement;
    exports2.jSXClosingFragment = exports2.jsxClosingFragment = jsxClosingFragment;
    exports2.jSXElement = exports2.jsxElement = jsxElement;
    exports2.jSXEmptyExpression = exports2.jsxEmptyExpression = jsxEmptyExpression;
    exports2.jSXExpressionContainer = exports2.jsxExpressionContainer = jsxExpressionContainer;
    exports2.jSXFragment = exports2.jsxFragment = jsxFragment;
    exports2.jSXIdentifier = exports2.jsxIdentifier = jsxIdentifier;
    exports2.jSXMemberExpression = exports2.jsxMemberExpression = jsxMemberExpression;
    exports2.jSXNamespacedName = exports2.jsxNamespacedName = jsxNamespacedName;
    exports2.jSXOpeningElement = exports2.jsxOpeningElement = jsxOpeningElement;
    exports2.jSXOpeningFragment = exports2.jsxOpeningFragment = jsxOpeningFragment;
    exports2.jSXSpreadAttribute = exports2.jsxSpreadAttribute = jsxSpreadAttribute;
    exports2.jSXSpreadChild = exports2.jsxSpreadChild = jsxSpreadChild;
    exports2.jSXText = exports2.jsxText = jsxText;
    exports2.labeledStatement = labeledStatement;
    exports2.logicalExpression = logicalExpression;
    exports2.memberExpression = memberExpression;
    exports2.metaProperty = metaProperty;
    exports2.mixedTypeAnnotation = mixedTypeAnnotation;
    exports2.moduleExpression = moduleExpression;
    exports2.newExpression = newExpression;
    exports2.noop = noop;
    exports2.nullLiteral = nullLiteral;
    exports2.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports2.nullableTypeAnnotation = nullableTypeAnnotation;
    exports2.numberLiteral = NumberLiteral;
    exports2.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports2.numberTypeAnnotation = numberTypeAnnotation;
    exports2.numericLiteral = numericLiteral;
    exports2.objectExpression = objectExpression;
    exports2.objectMethod = objectMethod;
    exports2.objectPattern = objectPattern;
    exports2.objectProperty = objectProperty;
    exports2.objectTypeAnnotation = objectTypeAnnotation;
    exports2.objectTypeCallProperty = objectTypeCallProperty;
    exports2.objectTypeIndexer = objectTypeIndexer;
    exports2.objectTypeInternalSlot = objectTypeInternalSlot;
    exports2.objectTypeProperty = objectTypeProperty;
    exports2.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports2.opaqueType = opaqueType;
    exports2.optionalCallExpression = optionalCallExpression;
    exports2.optionalIndexedAccessType = optionalIndexedAccessType;
    exports2.optionalMemberExpression = optionalMemberExpression;
    exports2.parenthesizedExpression = parenthesizedExpression;
    exports2.pipelineBareFunction = pipelineBareFunction;
    exports2.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports2.pipelineTopicExpression = pipelineTopicExpression;
    exports2.placeholder = placeholder;
    exports2.privateName = privateName;
    exports2.program = program3;
    exports2.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports2.recordExpression = recordExpression;
    exports2.regExpLiteral = regExpLiteral;
    exports2.regexLiteral = RegexLiteral;
    exports2.restElement = restElement;
    exports2.restProperty = RestProperty;
    exports2.returnStatement = returnStatement;
    exports2.sequenceExpression = sequenceExpression;
    exports2.spreadElement = spreadElement;
    exports2.spreadProperty = SpreadProperty;
    exports2.staticBlock = staticBlock;
    exports2.stringLiteral = stringLiteral;
    exports2.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports2.stringTypeAnnotation = stringTypeAnnotation;
    exports2.super = _super;
    exports2.switchCase = switchCase;
    exports2.switchStatement = switchStatement;
    exports2.symbolTypeAnnotation = symbolTypeAnnotation;
    exports2.taggedTemplateExpression = taggedTemplateExpression;
    exports2.templateElement = templateElement;
    exports2.templateLiteral = templateLiteral;
    exports2.thisExpression = thisExpression;
    exports2.thisTypeAnnotation = thisTypeAnnotation;
    exports2.throwStatement = throwStatement;
    exports2.topicReference = topicReference;
    exports2.tryStatement = tryStatement;
    exports2.tSAnyKeyword = exports2.tsAnyKeyword = tsAnyKeyword;
    exports2.tSArrayType = exports2.tsArrayType = tsArrayType;
    exports2.tSAsExpression = exports2.tsAsExpression = tsAsExpression;
    exports2.tSBigIntKeyword = exports2.tsBigIntKeyword = tsBigIntKeyword;
    exports2.tSBooleanKeyword = exports2.tsBooleanKeyword = tsBooleanKeyword;
    exports2.tSCallSignatureDeclaration = exports2.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports2.tSConditionalType = exports2.tsConditionalType = tsConditionalType;
    exports2.tSConstructSignatureDeclaration = exports2.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports2.tSConstructorType = exports2.tsConstructorType = tsConstructorType;
    exports2.tSDeclareFunction = exports2.tsDeclareFunction = tsDeclareFunction;
    exports2.tSDeclareMethod = exports2.tsDeclareMethod = tsDeclareMethod;
    exports2.tSEnumBody = exports2.tsEnumBody = tsEnumBody;
    exports2.tSEnumDeclaration = exports2.tsEnumDeclaration = tsEnumDeclaration;
    exports2.tSEnumMember = exports2.tsEnumMember = tsEnumMember;
    exports2.tSExportAssignment = exports2.tsExportAssignment = tsExportAssignment;
    exports2.tSExpressionWithTypeArguments = exports2.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports2.tSExternalModuleReference = exports2.tsExternalModuleReference = tsExternalModuleReference;
    exports2.tSFunctionType = exports2.tsFunctionType = tsFunctionType;
    exports2.tSImportEqualsDeclaration = exports2.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports2.tSImportType = exports2.tsImportType = tsImportType;
    exports2.tSIndexSignature = exports2.tsIndexSignature = tsIndexSignature;
    exports2.tSIndexedAccessType = exports2.tsIndexedAccessType = tsIndexedAccessType;
    exports2.tSInferType = exports2.tsInferType = tsInferType;
    exports2.tSInstantiationExpression = exports2.tsInstantiationExpression = tsInstantiationExpression;
    exports2.tSInterfaceBody = exports2.tsInterfaceBody = tsInterfaceBody;
    exports2.tSInterfaceDeclaration = exports2.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports2.tSIntersectionType = exports2.tsIntersectionType = tsIntersectionType;
    exports2.tSIntrinsicKeyword = exports2.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports2.tSLiteralType = exports2.tsLiteralType = tsLiteralType;
    exports2.tSMappedType = exports2.tsMappedType = tsMappedType;
    exports2.tSMethodSignature = exports2.tsMethodSignature = tsMethodSignature;
    exports2.tSModuleBlock = exports2.tsModuleBlock = tsModuleBlock;
    exports2.tSModuleDeclaration = exports2.tsModuleDeclaration = tsModuleDeclaration;
    exports2.tSNamedTupleMember = exports2.tsNamedTupleMember = tsNamedTupleMember;
    exports2.tSNamespaceExportDeclaration = exports2.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports2.tSNeverKeyword = exports2.tsNeverKeyword = tsNeverKeyword;
    exports2.tSNonNullExpression = exports2.tsNonNullExpression = tsNonNullExpression;
    exports2.tSNullKeyword = exports2.tsNullKeyword = tsNullKeyword;
    exports2.tSNumberKeyword = exports2.tsNumberKeyword = tsNumberKeyword;
    exports2.tSObjectKeyword = exports2.tsObjectKeyword = tsObjectKeyword;
    exports2.tSOptionalType = exports2.tsOptionalType = tsOptionalType;
    exports2.tSParameterProperty = exports2.tsParameterProperty = tsParameterProperty;
    exports2.tSParenthesizedType = exports2.tsParenthesizedType = tsParenthesizedType;
    exports2.tSPropertySignature = exports2.tsPropertySignature = tsPropertySignature;
    exports2.tSQualifiedName = exports2.tsQualifiedName = tsQualifiedName;
    exports2.tSRestType = exports2.tsRestType = tsRestType;
    exports2.tSSatisfiesExpression = exports2.tsSatisfiesExpression = tsSatisfiesExpression;
    exports2.tSStringKeyword = exports2.tsStringKeyword = tsStringKeyword;
    exports2.tSSymbolKeyword = exports2.tsSymbolKeyword = tsSymbolKeyword;
    exports2.tSTemplateLiteralType = exports2.tsTemplateLiteralType = tsTemplateLiteralType;
    exports2.tSThisType = exports2.tsThisType = tsThisType;
    exports2.tSTupleType = exports2.tsTupleType = tsTupleType;
    exports2.tSTypeAliasDeclaration = exports2.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports2.tSTypeAnnotation = exports2.tsTypeAnnotation = tsTypeAnnotation;
    exports2.tSTypeAssertion = exports2.tsTypeAssertion = tsTypeAssertion;
    exports2.tSTypeLiteral = exports2.tsTypeLiteral = tsTypeLiteral;
    exports2.tSTypeOperator = exports2.tsTypeOperator = tsTypeOperator;
    exports2.tSTypeParameter = exports2.tsTypeParameter = tsTypeParameter;
    exports2.tSTypeParameterDeclaration = exports2.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports2.tSTypeParameterInstantiation = exports2.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports2.tSTypePredicate = exports2.tsTypePredicate = tsTypePredicate;
    exports2.tSTypeQuery = exports2.tsTypeQuery = tsTypeQuery;
    exports2.tSTypeReference = exports2.tsTypeReference = tsTypeReference;
    exports2.tSUndefinedKeyword = exports2.tsUndefinedKeyword = tsUndefinedKeyword;
    exports2.tSUnionType = exports2.tsUnionType = tsUnionType;
    exports2.tSUnknownKeyword = exports2.tsUnknownKeyword = tsUnknownKeyword;
    exports2.tSVoidKeyword = exports2.tsVoidKeyword = tsVoidKeyword;
    exports2.tupleExpression = tupleExpression;
    exports2.tupleTypeAnnotation = tupleTypeAnnotation;
    exports2.typeAlias = typeAlias;
    exports2.typeAnnotation = typeAnnotation;
    exports2.typeCastExpression = typeCastExpression;
    exports2.typeParameter = typeParameter;
    exports2.typeParameterDeclaration = typeParameterDeclaration;
    exports2.typeParameterInstantiation = typeParameterInstantiation;
    exports2.typeofTypeAnnotation = typeofTypeAnnotation;
    exports2.unaryExpression = unaryExpression;
    exports2.unionTypeAnnotation = unionTypeAnnotation;
    exports2.updateExpression = updateExpression;
    exports2.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports2.variableDeclaration = variableDeclaration;
    exports2.variableDeclarator = variableDeclarator;
    exports2.variance = variance;
    exports2.voidTypeAnnotation = voidTypeAnnotation;
    exports2.whileStatement = whileStatement;
    exports2.withStatement = withStatement;
    exports2.yieldExpression = yieldExpression;
    var _validate = require_validate();
    var _deprecationWarning = require_deprecationWarning();
    var utils = require_utils();
    var {
      validateInternal: validate
    } = _validate;
    var {
      NODE_FIELDS
    } = utils;
    function arrayExpression(elements = []) {
      const node = {
        type: "ArrayExpression",
        elements
      };
      const defs = NODE_FIELDS.ArrayExpression;
      validate(defs.elements, node, "elements", elements, 1);
      return node;
    }
    function assignmentExpression(operator, left, right) {
      const node = {
        type: "AssignmentExpression",
        operator,
        left,
        right
      };
      const defs = NODE_FIELDS.AssignmentExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function binaryExpression(operator, left, right) {
      const node = {
        type: "BinaryExpression",
        operator,
        left,
        right
      };
      const defs = NODE_FIELDS.BinaryExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function interpreterDirective(value) {
      const node = {
        type: "InterpreterDirective",
        value
      };
      const defs = NODE_FIELDS.InterpreterDirective;
      validate(defs.value, node, "value", value);
      return node;
    }
    function directive(value) {
      const node = {
        type: "Directive",
        value
      };
      const defs = NODE_FIELDS.Directive;
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function directiveLiteral(value) {
      const node = {
        type: "DirectiveLiteral",
        value
      };
      const defs = NODE_FIELDS.DirectiveLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function blockStatement(body, directives = []) {
      const node = {
        type: "BlockStatement",
        body,
        directives
      };
      const defs = NODE_FIELDS.BlockStatement;
      validate(defs.body, node, "body", body, 1);
      validate(defs.directives, node, "directives", directives, 1);
      return node;
    }
    function breakStatement(label = null) {
      const node = {
        type: "BreakStatement",
        label
      };
      const defs = NODE_FIELDS.BreakStatement;
      validate(defs.label, node, "label", label, 1);
      return node;
    }
    function callExpression(callee, _arguments) {
      const node = {
        type: "CallExpression",
        callee,
        arguments: _arguments
      };
      const defs = NODE_FIELDS.CallExpression;
      validate(defs.callee, node, "callee", callee, 1);
      validate(defs.arguments, node, "arguments", _arguments, 1);
      return node;
    }
    function catchClause(param = null, body) {
      const node = {
        type: "CatchClause",
        param,
        body
      };
      const defs = NODE_FIELDS.CatchClause;
      validate(defs.param, node, "param", param, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function conditionalExpression(test, consequent, alternate) {
      const node = {
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      };
      const defs = NODE_FIELDS.ConditionalExpression;
      validate(defs.test, node, "test", test, 1);
      validate(defs.consequent, node, "consequent", consequent, 1);
      validate(defs.alternate, node, "alternate", alternate, 1);
      return node;
    }
    function continueStatement(label = null) {
      const node = {
        type: "ContinueStatement",
        label
      };
      const defs = NODE_FIELDS.ContinueStatement;
      validate(defs.label, node, "label", label, 1);
      return node;
    }
    function debuggerStatement() {
      return {
        type: "DebuggerStatement"
      };
    }
    function doWhileStatement(test, body) {
      const node = {
        type: "DoWhileStatement",
        test,
        body
      };
      const defs = NODE_FIELDS.DoWhileStatement;
      validate(defs.test, node, "test", test, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function emptyStatement() {
      return {
        type: "EmptyStatement"
      };
    }
    function expressionStatement(expression) {
      const node = {
        type: "ExpressionStatement",
        expression
      };
      const defs = NODE_FIELDS.ExpressionStatement;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function file(program4, comments = null, tokens = null) {
      const node = {
        type: "File",
        program: program4,
        comments,
        tokens
      };
      const defs = NODE_FIELDS.File;
      validate(defs.program, node, "program", program4, 1);
      validate(defs.comments, node, "comments", comments, 1);
      validate(defs.tokens, node, "tokens", tokens);
      return node;
    }
    function forInStatement(left, right, body) {
      const node = {
        type: "ForInStatement",
        left,
        right,
        body
      };
      const defs = NODE_FIELDS.ForInStatement;
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function forStatement(init = null, test = null, update = null, body) {
      const node = {
        type: "ForStatement",
        init,
        test,
        update,
        body
      };
      const defs = NODE_FIELDS.ForStatement;
      validate(defs.init, node, "init", init, 1);
      validate(defs.test, node, "test", test, 1);
      validate(defs.update, node, "update", update, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function functionDeclaration(id = null, params, body, generator = false, async = false) {
      const node = {
        type: "FunctionDeclaration",
        id,
        params,
        body,
        generator,
        async
      };
      const defs = NODE_FIELDS.FunctionDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.generator, node, "generator", generator);
      validate(defs.async, node, "async", async);
      return node;
    }
    function functionExpression(id = null, params, body, generator = false, async = false) {
      const node = {
        type: "FunctionExpression",
        id,
        params,
        body,
        generator,
        async
      };
      const defs = NODE_FIELDS.FunctionExpression;
      validate(defs.id, node, "id", id, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.generator, node, "generator", generator);
      validate(defs.async, node, "async", async);
      return node;
    }
    function identifier(name) {
      const node = {
        type: "Identifier",
        name
      };
      const defs = NODE_FIELDS.Identifier;
      validate(defs.name, node, "name", name);
      return node;
    }
    function ifStatement(test, consequent, alternate = null) {
      const node = {
        type: "IfStatement",
        test,
        consequent,
        alternate
      };
      const defs = NODE_FIELDS.IfStatement;
      validate(defs.test, node, "test", test, 1);
      validate(defs.consequent, node, "consequent", consequent, 1);
      validate(defs.alternate, node, "alternate", alternate, 1);
      return node;
    }
    function labeledStatement(label, body) {
      const node = {
        type: "LabeledStatement",
        label,
        body
      };
      const defs = NODE_FIELDS.LabeledStatement;
      validate(defs.label, node, "label", label, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function stringLiteral(value) {
      const node = {
        type: "StringLiteral",
        value
      };
      const defs = NODE_FIELDS.StringLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function numericLiteral(value) {
      const node = {
        type: "NumericLiteral",
        value
      };
      const defs = NODE_FIELDS.NumericLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function nullLiteral() {
      return {
        type: "NullLiteral"
      };
    }
    function booleanLiteral(value) {
      const node = {
        type: "BooleanLiteral",
        value
      };
      const defs = NODE_FIELDS.BooleanLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function regExpLiteral(pattern, flags = "") {
      const node = {
        type: "RegExpLiteral",
        pattern,
        flags
      };
      const defs = NODE_FIELDS.RegExpLiteral;
      validate(defs.pattern, node, "pattern", pattern);
      validate(defs.flags, node, "flags", flags);
      return node;
    }
    function logicalExpression(operator, left, right) {
      const node = {
        type: "LogicalExpression",
        operator,
        left,
        right
      };
      const defs = NODE_FIELDS.LogicalExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function memberExpression(object, property, computed = false, optional = null) {
      const node = {
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
      };
      const defs = NODE_FIELDS.MemberExpression;
      validate(defs.object, node, "object", object, 1);
      validate(defs.property, node, "property", property, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.optional, node, "optional", optional);
      return node;
    }
    function newExpression(callee, _arguments) {
      const node = {
        type: "NewExpression",
        callee,
        arguments: _arguments
      };
      const defs = NODE_FIELDS.NewExpression;
      validate(defs.callee, node, "callee", callee, 1);
      validate(defs.arguments, node, "arguments", _arguments, 1);
      return node;
    }
    function program3(body, directives = [], sourceType = "script", interpreter = null) {
      const node = {
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter
      };
      const defs = NODE_FIELDS.Program;
      validate(defs.body, node, "body", body, 1);
      validate(defs.directives, node, "directives", directives, 1);
      validate(defs.sourceType, node, "sourceType", sourceType);
      validate(defs.interpreter, node, "interpreter", interpreter, 1);
      return node;
    }
    function objectExpression(properties) {
      const node = {
        type: "ObjectExpression",
        properties
      };
      const defs = NODE_FIELDS.ObjectExpression;
      validate(defs.properties, node, "properties", properties, 1);
      return node;
    }
    function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
      const node = {
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async
      };
      const defs = NODE_FIELDS.ObjectMethod;
      validate(defs.kind, node, "kind", kind);
      validate(defs.key, node, "key", key, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.generator, node, "generator", generator);
      validate(defs.async, node, "async", async);
      return node;
    }
    function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
      const node = {
        type: "ObjectProperty",
        key,
        value,
        computed,
        shorthand,
        decorators
      };
      const defs = NODE_FIELDS.ObjectProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.shorthand, node, "shorthand", shorthand);
      validate(defs.decorators, node, "decorators", decorators, 1);
      return node;
    }
    function restElement(argument) {
      const node = {
        type: "RestElement",
        argument
      };
      const defs = NODE_FIELDS.RestElement;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function returnStatement(argument = null) {
      const node = {
        type: "ReturnStatement",
        argument
      };
      const defs = NODE_FIELDS.ReturnStatement;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function sequenceExpression(expressions) {
      const node = {
        type: "SequenceExpression",
        expressions
      };
      const defs = NODE_FIELDS.SequenceExpression;
      validate(defs.expressions, node, "expressions", expressions, 1);
      return node;
    }
    function parenthesizedExpression(expression) {
      const node = {
        type: "ParenthesizedExpression",
        expression
      };
      const defs = NODE_FIELDS.ParenthesizedExpression;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function switchCase(test = null, consequent) {
      const node = {
        type: "SwitchCase",
        test,
        consequent
      };
      const defs = NODE_FIELDS.SwitchCase;
      validate(defs.test, node, "test", test, 1);
      validate(defs.consequent, node, "consequent", consequent, 1);
      return node;
    }
    function switchStatement(discriminant, cases) {
      const node = {
        type: "SwitchStatement",
        discriminant,
        cases
      };
      const defs = NODE_FIELDS.SwitchStatement;
      validate(defs.discriminant, node, "discriminant", discriminant, 1);
      validate(defs.cases, node, "cases", cases, 1);
      return node;
    }
    function thisExpression() {
      return {
        type: "ThisExpression"
      };
    }
    function throwStatement(argument) {
      const node = {
        type: "ThrowStatement",
        argument
      };
      const defs = NODE_FIELDS.ThrowStatement;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function tryStatement(block, handler = null, finalizer = null) {
      const node = {
        type: "TryStatement",
        block,
        handler,
        finalizer
      };
      const defs = NODE_FIELDS.TryStatement;
      validate(defs.block, node, "block", block, 1);
      validate(defs.handler, node, "handler", handler, 1);
      validate(defs.finalizer, node, "finalizer", finalizer, 1);
      return node;
    }
    function unaryExpression(operator, argument, prefix = true) {
      const node = {
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      };
      const defs = NODE_FIELDS.UnaryExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.argument, node, "argument", argument, 1);
      validate(defs.prefix, node, "prefix", prefix);
      return node;
    }
    function updateExpression(operator, argument, prefix = false) {
      const node = {
        type: "UpdateExpression",
        operator,
        argument,
        prefix
      };
      const defs = NODE_FIELDS.UpdateExpression;
      validate(defs.operator, node, "operator", operator);
      validate(defs.argument, node, "argument", argument, 1);
      validate(defs.prefix, node, "prefix", prefix);
      return node;
    }
    function variableDeclaration(kind, declarations) {
      const node = {
        type: "VariableDeclaration",
        kind,
        declarations
      };
      const defs = NODE_FIELDS.VariableDeclaration;
      validate(defs.kind, node, "kind", kind);
      validate(defs.declarations, node, "declarations", declarations, 1);
      return node;
    }
    function variableDeclarator(id, init = null) {
      const node = {
        type: "VariableDeclarator",
        id,
        init
      };
      const defs = NODE_FIELDS.VariableDeclarator;
      validate(defs.id, node, "id", id, 1);
      validate(defs.init, node, "init", init, 1);
      return node;
    }
    function whileStatement(test, body) {
      const node = {
        type: "WhileStatement",
        test,
        body
      };
      const defs = NODE_FIELDS.WhileStatement;
      validate(defs.test, node, "test", test, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function withStatement(object, body) {
      const node = {
        type: "WithStatement",
        object,
        body
      };
      const defs = NODE_FIELDS.WithStatement;
      validate(defs.object, node, "object", object, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function assignmentPattern(left, right) {
      const node = {
        type: "AssignmentPattern",
        left,
        right
      };
      const defs = NODE_FIELDS.AssignmentPattern;
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function arrayPattern(elements) {
      const node = {
        type: "ArrayPattern",
        elements
      };
      const defs = NODE_FIELDS.ArrayPattern;
      validate(defs.elements, node, "elements", elements, 1);
      return node;
    }
    function arrowFunctionExpression(params, body, async = false) {
      const node = {
        type: "ArrowFunctionExpression",
        params,
        body,
        async,
        expression: null
      };
      const defs = NODE_FIELDS.ArrowFunctionExpression;
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.async, node, "async", async);
      return node;
    }
    function classBody(body) {
      const node = {
        type: "ClassBody",
        body
      };
      const defs = NODE_FIELDS.ClassBody;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function classExpression(id = null, superClass = null, body, decorators = null) {
      const node = {
        type: "ClassExpression",
        id,
        superClass,
        body,
        decorators
      };
      const defs = NODE_FIELDS.ClassExpression;
      validate(defs.id, node, "id", id, 1);
      validate(defs.superClass, node, "superClass", superClass, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      return node;
    }
    function classDeclaration(id = null, superClass = null, body, decorators = null) {
      const node = {
        type: "ClassDeclaration",
        id,
        superClass,
        body,
        decorators
      };
      const defs = NODE_FIELDS.ClassDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.superClass, node, "superClass", superClass, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      return node;
    }
    function exportAllDeclaration(source) {
      const node = {
        type: "ExportAllDeclaration",
        source
      };
      const defs = NODE_FIELDS.ExportAllDeclaration;
      validate(defs.source, node, "source", source, 1);
      return node;
    }
    function exportDefaultDeclaration(declaration) {
      const node = {
        type: "ExportDefaultDeclaration",
        declaration
      };
      const defs = NODE_FIELDS.ExportDefaultDeclaration;
      validate(defs.declaration, node, "declaration", declaration, 1);
      return node;
    }
    function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
      const node = {
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
      };
      const defs = NODE_FIELDS.ExportNamedDeclaration;
      validate(defs.declaration, node, "declaration", declaration, 1);
      validate(defs.specifiers, node, "specifiers", specifiers, 1);
      validate(defs.source, node, "source", source, 1);
      return node;
    }
    function exportSpecifier(local, exported) {
      const node = {
        type: "ExportSpecifier",
        local,
        exported
      };
      const defs = NODE_FIELDS.ExportSpecifier;
      validate(defs.local, node, "local", local, 1);
      validate(defs.exported, node, "exported", exported, 1);
      return node;
    }
    function forOfStatement(left, right, body, _await = false) {
      const node = {
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      };
      const defs = NODE_FIELDS.ForOfStatement;
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.await, node, "await", _await);
      return node;
    }
    function importDeclaration(specifiers, source) {
      const node = {
        type: "ImportDeclaration",
        specifiers,
        source
      };
      const defs = NODE_FIELDS.ImportDeclaration;
      validate(defs.specifiers, node, "specifiers", specifiers, 1);
      validate(defs.source, node, "source", source, 1);
      return node;
    }
    function importDefaultSpecifier(local) {
      const node = {
        type: "ImportDefaultSpecifier",
        local
      };
      const defs = NODE_FIELDS.ImportDefaultSpecifier;
      validate(defs.local, node, "local", local, 1);
      return node;
    }
    function importNamespaceSpecifier(local) {
      const node = {
        type: "ImportNamespaceSpecifier",
        local
      };
      const defs = NODE_FIELDS.ImportNamespaceSpecifier;
      validate(defs.local, node, "local", local, 1);
      return node;
    }
    function importSpecifier(local, imported) {
      const node = {
        type: "ImportSpecifier",
        local,
        imported
      };
      const defs = NODE_FIELDS.ImportSpecifier;
      validate(defs.local, node, "local", local, 1);
      validate(defs.imported, node, "imported", imported, 1);
      return node;
    }
    function importExpression(source, options = null) {
      const node = {
        type: "ImportExpression",
        source,
        options
      };
      const defs = NODE_FIELDS.ImportExpression;
      validate(defs.source, node, "source", source, 1);
      validate(defs.options, node, "options", options, 1);
      return node;
    }
    function metaProperty(meta, property) {
      const node = {
        type: "MetaProperty",
        meta,
        property
      };
      const defs = NODE_FIELDS.MetaProperty;
      validate(defs.meta, node, "meta", meta, 1);
      validate(defs.property, node, "property", property, 1);
      return node;
    }
    function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
      const node = {
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async
      };
      const defs = NODE_FIELDS.ClassMethod;
      validate(defs.kind, node, "kind", kind);
      validate(defs.key, node, "key", key, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.static, node, "static", _static);
      validate(defs.generator, node, "generator", generator);
      validate(defs.async, node, "async", async);
      return node;
    }
    function objectPattern(properties) {
      const node = {
        type: "ObjectPattern",
        properties
      };
      const defs = NODE_FIELDS.ObjectPattern;
      validate(defs.properties, node, "properties", properties, 1);
      return node;
    }
    function spreadElement(argument) {
      const node = {
        type: "SpreadElement",
        argument
      };
      const defs = NODE_FIELDS.SpreadElement;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function _super() {
      return {
        type: "Super"
      };
    }
    function taggedTemplateExpression(tag, quasi) {
      const node = {
        type: "TaggedTemplateExpression",
        tag,
        quasi
      };
      const defs = NODE_FIELDS.TaggedTemplateExpression;
      validate(defs.tag, node, "tag", tag, 1);
      validate(defs.quasi, node, "quasi", quasi, 1);
      return node;
    }
    function templateElement(value, tail = false) {
      const node = {
        type: "TemplateElement",
        value,
        tail
      };
      const defs = NODE_FIELDS.TemplateElement;
      validate(defs.value, node, "value", value);
      validate(defs.tail, node, "tail", tail);
      return node;
    }
    function templateLiteral(quasis, expressions) {
      const node = {
        type: "TemplateLiteral",
        quasis,
        expressions
      };
      const defs = NODE_FIELDS.TemplateLiteral;
      validate(defs.quasis, node, "quasis", quasis, 1);
      validate(defs.expressions, node, "expressions", expressions, 1);
      return node;
    }
    function yieldExpression(argument = null, delegate = false) {
      const node = {
        type: "YieldExpression",
        argument,
        delegate
      };
      const defs = NODE_FIELDS.YieldExpression;
      validate(defs.argument, node, "argument", argument, 1);
      validate(defs.delegate, node, "delegate", delegate);
      return node;
    }
    function awaitExpression(argument) {
      const node = {
        type: "AwaitExpression",
        argument
      };
      const defs = NODE_FIELDS.AwaitExpression;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function _import() {
      return {
        type: "Import"
      };
    }
    function bigIntLiteral(value) {
      const node = {
        type: "BigIntLiteral",
        value
      };
      const defs = NODE_FIELDS.BigIntLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function exportNamespaceSpecifier(exported) {
      const node = {
        type: "ExportNamespaceSpecifier",
        exported
      };
      const defs = NODE_FIELDS.ExportNamespaceSpecifier;
      validate(defs.exported, node, "exported", exported, 1);
      return node;
    }
    function optionalMemberExpression(object, property, computed = false, optional) {
      const node = {
        type: "OptionalMemberExpression",
        object,
        property,
        computed,
        optional
      };
      const defs = NODE_FIELDS.OptionalMemberExpression;
      validate(defs.object, node, "object", object, 1);
      validate(defs.property, node, "property", property, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.optional, node, "optional", optional);
      return node;
    }
    function optionalCallExpression(callee, _arguments, optional) {
      const node = {
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
      };
      const defs = NODE_FIELDS.OptionalCallExpression;
      validate(defs.callee, node, "callee", callee, 1);
      validate(defs.arguments, node, "arguments", _arguments, 1);
      validate(defs.optional, node, "optional", optional);
      return node;
    }
    function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      const node = {
        type: "ClassProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      };
      const defs = NODE_FIELDS.ClassProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.static, node, "static", _static);
      return node;
    }
    function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      const node = {
        type: "ClassAccessorProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      };
      const defs = NODE_FIELDS.ClassAccessorProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      validate(defs.computed, node, "computed", computed);
      validate(defs.static, node, "static", _static);
      return node;
    }
    function classPrivateProperty(key, value = null, decorators = null, _static = false) {
      const node = {
        type: "ClassPrivateProperty",
        key,
        value,
        decorators,
        static: _static
      };
      const defs = NODE_FIELDS.ClassPrivateProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.decorators, node, "decorators", decorators, 1);
      validate(defs.static, node, "static", _static);
      return node;
    }
    function classPrivateMethod(kind = "method", key, params, body, _static = false) {
      const node = {
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
      };
      const defs = NODE_FIELDS.ClassPrivateMethod;
      validate(defs.kind, node, "kind", kind);
      validate(defs.key, node, "key", key, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.static, node, "static", _static);
      return node;
    }
    function privateName(id) {
      const node = {
        type: "PrivateName",
        id
      };
      const defs = NODE_FIELDS.PrivateName;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function staticBlock(body) {
      const node = {
        type: "StaticBlock",
        body
      };
      const defs = NODE_FIELDS.StaticBlock;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function anyTypeAnnotation() {
      return {
        type: "AnyTypeAnnotation"
      };
    }
    function arrayTypeAnnotation(elementType) {
      const node = {
        type: "ArrayTypeAnnotation",
        elementType
      };
      const defs = NODE_FIELDS.ArrayTypeAnnotation;
      validate(defs.elementType, node, "elementType", elementType, 1);
      return node;
    }
    function booleanTypeAnnotation() {
      return {
        type: "BooleanTypeAnnotation"
      };
    }
    function booleanLiteralTypeAnnotation(value) {
      const node = {
        type: "BooleanLiteralTypeAnnotation",
        value
      };
      const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
      validate(defs.value, node, "value", value);
      return node;
    }
    function nullLiteralTypeAnnotation() {
      return {
        type: "NullLiteralTypeAnnotation"
      };
    }
    function classImplements(id, typeParameters = null) {
      const node = {
        type: "ClassImplements",
        id,
        typeParameters
      };
      const defs = NODE_FIELDS.ClassImplements;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function declareClass(id, typeParameters = null, _extends = null, body) {
      const node = {
        type: "DeclareClass",
        id,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.DeclareClass;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function declareFunction(id) {
      const node = {
        type: "DeclareFunction",
        id
      };
      const defs = NODE_FIELDS.DeclareFunction;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function declareInterface(id, typeParameters = null, _extends = null, body) {
      const node = {
        type: "DeclareInterface",
        id,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.DeclareInterface;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function declareModule(id, body, kind = null) {
      const node = {
        type: "DeclareModule",
        id,
        body,
        kind
      };
      const defs = NODE_FIELDS.DeclareModule;
      validate(defs.id, node, "id", id, 1);
      validate(defs.body, node, "body", body, 1);
      validate(defs.kind, node, "kind", kind);
      return node;
    }
    function declareModuleExports(typeAnnotation2) {
      const node = {
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.DeclareModuleExports;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function declareTypeAlias(id, typeParameters = null, right) {
      const node = {
        type: "DeclareTypeAlias",
        id,
        typeParameters,
        right
      };
      const defs = NODE_FIELDS.DeclareTypeAlias;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function declareOpaqueType(id, typeParameters = null, supertype = null) {
      const node = {
        type: "DeclareOpaqueType",
        id,
        typeParameters,
        supertype
      };
      const defs = NODE_FIELDS.DeclareOpaqueType;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.supertype, node, "supertype", supertype, 1);
      return node;
    }
    function declareVariable(id) {
      const node = {
        type: "DeclareVariable",
        id
      };
      const defs = NODE_FIELDS.DeclareVariable;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
      const node = {
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source,
        attributes
      };
      const defs = NODE_FIELDS.DeclareExportDeclaration;
      validate(defs.declaration, node, "declaration", declaration, 1);
      validate(defs.specifiers, node, "specifiers", specifiers, 1);
      validate(defs.source, node, "source", source, 1);
      validate(defs.attributes, node, "attributes", attributes, 1);
      return node;
    }
    function declareExportAllDeclaration(source, attributes = null) {
      const node = {
        type: "DeclareExportAllDeclaration",
        source,
        attributes
      };
      const defs = NODE_FIELDS.DeclareExportAllDeclaration;
      validate(defs.source, node, "source", source, 1);
      validate(defs.attributes, node, "attributes", attributes, 1);
      return node;
    }
    function declaredPredicate(value) {
      const node = {
        type: "DeclaredPredicate",
        value
      };
      const defs = NODE_FIELDS.DeclaredPredicate;
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function existsTypeAnnotation() {
      return {
        type: "ExistsTypeAnnotation"
      };
    }
    function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
      const node = {
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
      };
      const defs = NODE_FIELDS.FunctionTypeAnnotation;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.rest, node, "rest", rest, 1);
      validate(defs.returnType, node, "returnType", returnType, 1);
      return node;
    }
    function functionTypeParam(name = null, typeAnnotation2) {
      const node = {
        type: "FunctionTypeParam",
        name,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.FunctionTypeParam;
      validate(defs.name, node, "name", name, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function genericTypeAnnotation(id, typeParameters = null) {
      const node = {
        type: "GenericTypeAnnotation",
        id,
        typeParameters
      };
      const defs = NODE_FIELDS.GenericTypeAnnotation;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function inferredPredicate() {
      return {
        type: "InferredPredicate"
      };
    }
    function interfaceExtends(id, typeParameters = null) {
      const node = {
        type: "InterfaceExtends",
        id,
        typeParameters
      };
      const defs = NODE_FIELDS.InterfaceExtends;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      const node = {
        type: "InterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.InterfaceDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function interfaceTypeAnnotation(_extends = null, body) {
      const node = {
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.InterfaceTypeAnnotation;
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function intersectionTypeAnnotation(types) {
      const node = {
        type: "IntersectionTypeAnnotation",
        types
      };
      const defs = NODE_FIELDS.IntersectionTypeAnnotation;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function mixedTypeAnnotation() {
      return {
        type: "MixedTypeAnnotation"
      };
    }
    function emptyTypeAnnotation() {
      return {
        type: "EmptyTypeAnnotation"
      };
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      const node = {
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.NullableTypeAnnotation;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function numberLiteralTypeAnnotation(value) {
      const node = {
        type: "NumberLiteralTypeAnnotation",
        value
      };
      const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
      validate(defs.value, node, "value", value);
      return node;
    }
    function numberTypeAnnotation() {
      return {
        type: "NumberTypeAnnotation"
      };
    }
    function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
      const node = {
        type: "ObjectTypeAnnotation",
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact
      };
      const defs = NODE_FIELDS.ObjectTypeAnnotation;
      validate(defs.properties, node, "properties", properties, 1);
      validate(defs.indexers, node, "indexers", indexers, 1);
      validate(defs.callProperties, node, "callProperties", callProperties, 1);
      validate(defs.internalSlots, node, "internalSlots", internalSlots, 1);
      validate(defs.exact, node, "exact", exact);
      return node;
    }
    function objectTypeInternalSlot(id, value, optional, _static, method) {
      const node = {
        type: "ObjectTypeInternalSlot",
        id,
        value,
        optional,
        static: _static,
        method
      };
      const defs = NODE_FIELDS.ObjectTypeInternalSlot;
      validate(defs.id, node, "id", id, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.optional, node, "optional", optional);
      validate(defs.static, node, "static", _static);
      validate(defs.method, node, "method", method);
      return node;
    }
    function objectTypeCallProperty(value) {
      const node = {
        type: "ObjectTypeCallProperty",
        value,
        static: null
      };
      const defs = NODE_FIELDS.ObjectTypeCallProperty;
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function objectTypeIndexer(id = null, key, value, variance2 = null) {
      const node = {
        type: "ObjectTypeIndexer",
        id,
        key,
        value,
        variance: variance2,
        static: null
      };
      const defs = NODE_FIELDS.ObjectTypeIndexer;
      validate(defs.id, node, "id", id, 1);
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.variance, node, "variance", variance2, 1);
      return node;
    }
    function objectTypeProperty(key, value, variance2 = null) {
      const node = {
        type: "ObjectTypeProperty",
        key,
        value,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      };
      const defs = NODE_FIELDS.ObjectTypeProperty;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      validate(defs.variance, node, "variance", variance2, 1);
      return node;
    }
    function objectTypeSpreadProperty(argument) {
      const node = {
        type: "ObjectTypeSpreadProperty",
        argument
      };
      const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function opaqueType(id, typeParameters = null, supertype = null, impltype) {
      const node = {
        type: "OpaqueType",
        id,
        typeParameters,
        supertype,
        impltype
      };
      const defs = NODE_FIELDS.OpaqueType;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.supertype, node, "supertype", supertype, 1);
      validate(defs.impltype, node, "impltype", impltype, 1);
      return node;
    }
    function qualifiedTypeIdentifier(id, qualification) {
      const node = {
        type: "QualifiedTypeIdentifier",
        id,
        qualification
      };
      const defs = NODE_FIELDS.QualifiedTypeIdentifier;
      validate(defs.id, node, "id", id, 1);
      validate(defs.qualification, node, "qualification", qualification, 1);
      return node;
    }
    function stringLiteralTypeAnnotation(value) {
      const node = {
        type: "StringLiteralTypeAnnotation",
        value
      };
      const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
      validate(defs.value, node, "value", value);
      return node;
    }
    function stringTypeAnnotation() {
      return {
        type: "StringTypeAnnotation"
      };
    }
    function symbolTypeAnnotation() {
      return {
        type: "SymbolTypeAnnotation"
      };
    }
    function thisTypeAnnotation() {
      return {
        type: "ThisTypeAnnotation"
      };
    }
    function tupleTypeAnnotation(types) {
      const node = {
        type: "TupleTypeAnnotation",
        types
      };
      const defs = NODE_FIELDS.TupleTypeAnnotation;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function typeofTypeAnnotation(argument) {
      const node = {
        type: "TypeofTypeAnnotation",
        argument
      };
      const defs = NODE_FIELDS.TypeofTypeAnnotation;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function typeAlias(id, typeParameters = null, right) {
      const node = {
        type: "TypeAlias",
        id,
        typeParameters,
        right
      };
      const defs = NODE_FIELDS.TypeAlias;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function typeAnnotation(typeAnnotation2) {
      const node = {
        type: "TypeAnnotation",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TypeAnnotation;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function typeCastExpression(expression, typeAnnotation2) {
      const node = {
        type: "TypeCastExpression",
        expression,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TypeCastExpression;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function typeParameter(bound = null, _default = null, variance2 = null) {
      const node = {
        type: "TypeParameter",
        bound,
        default: _default,
        variance: variance2,
        name: null
      };
      const defs = NODE_FIELDS.TypeParameter;
      validate(defs.bound, node, "bound", bound, 1);
      validate(defs.default, node, "default", _default, 1);
      validate(defs.variance, node, "variance", variance2, 1);
      return node;
    }
    function typeParameterDeclaration(params) {
      const node = {
        type: "TypeParameterDeclaration",
        params
      };
      const defs = NODE_FIELDS.TypeParameterDeclaration;
      validate(defs.params, node, "params", params, 1);
      return node;
    }
    function typeParameterInstantiation(params) {
      const node = {
        type: "TypeParameterInstantiation",
        params
      };
      const defs = NODE_FIELDS.TypeParameterInstantiation;
      validate(defs.params, node, "params", params, 1);
      return node;
    }
    function unionTypeAnnotation(types) {
      const node = {
        type: "UnionTypeAnnotation",
        types
      };
      const defs = NODE_FIELDS.UnionTypeAnnotation;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function variance(kind) {
      const node = {
        type: "Variance",
        kind
      };
      const defs = NODE_FIELDS.Variance;
      validate(defs.kind, node, "kind", kind);
      return node;
    }
    function voidTypeAnnotation() {
      return {
        type: "VoidTypeAnnotation"
      };
    }
    function enumDeclaration(id, body) {
      const node = {
        type: "EnumDeclaration",
        id,
        body
      };
      const defs = NODE_FIELDS.EnumDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function enumBooleanBody(members) {
      const node = {
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumBooleanBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function enumNumberBody(members) {
      const node = {
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumNumberBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function enumStringBody(members) {
      const node = {
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumStringBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function enumSymbolBody(members) {
      const node = {
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumSymbolBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function enumBooleanMember(id) {
      const node = {
        type: "EnumBooleanMember",
        id,
        init: null
      };
      const defs = NODE_FIELDS.EnumBooleanMember;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function enumNumberMember(id, init) {
      const node = {
        type: "EnumNumberMember",
        id,
        init
      };
      const defs = NODE_FIELDS.EnumNumberMember;
      validate(defs.id, node, "id", id, 1);
      validate(defs.init, node, "init", init, 1);
      return node;
    }
    function enumStringMember(id, init) {
      const node = {
        type: "EnumStringMember",
        id,
        init
      };
      const defs = NODE_FIELDS.EnumStringMember;
      validate(defs.id, node, "id", id, 1);
      validate(defs.init, node, "init", init, 1);
      return node;
    }
    function enumDefaultedMember(id) {
      const node = {
        type: "EnumDefaultedMember",
        id
      };
      const defs = NODE_FIELDS.EnumDefaultedMember;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function indexedAccessType(objectType, indexType) {
      const node = {
        type: "IndexedAccessType",
        objectType,
        indexType
      };
      const defs = NODE_FIELDS.IndexedAccessType;
      validate(defs.objectType, node, "objectType", objectType, 1);
      validate(defs.indexType, node, "indexType", indexType, 1);
      return node;
    }
    function optionalIndexedAccessType(objectType, indexType) {
      const node = {
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
      };
      const defs = NODE_FIELDS.OptionalIndexedAccessType;
      validate(defs.objectType, node, "objectType", objectType, 1);
      validate(defs.indexType, node, "indexType", indexType, 1);
      return node;
    }
    function jsxAttribute(name, value = null) {
      const node = {
        type: "JSXAttribute",
        name,
        value
      };
      const defs = NODE_FIELDS.JSXAttribute;
      validate(defs.name, node, "name", name, 1);
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function jsxClosingElement(name) {
      const node = {
        type: "JSXClosingElement",
        name
      };
      const defs = NODE_FIELDS.JSXClosingElement;
      validate(defs.name, node, "name", name, 1);
      return node;
    }
    function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
      const node = {
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
      };
      const defs = NODE_FIELDS.JSXElement;
      validate(defs.openingElement, node, "openingElement", openingElement, 1);
      validate(defs.closingElement, node, "closingElement", closingElement, 1);
      validate(defs.children, node, "children", children, 1);
      validate(defs.selfClosing, node, "selfClosing", selfClosing);
      return node;
    }
    function jsxEmptyExpression() {
      return {
        type: "JSXEmptyExpression"
      };
    }
    function jsxExpressionContainer(expression) {
      const node = {
        type: "JSXExpressionContainer",
        expression
      };
      const defs = NODE_FIELDS.JSXExpressionContainer;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function jsxSpreadChild(expression) {
      const node = {
        type: "JSXSpreadChild",
        expression
      };
      const defs = NODE_FIELDS.JSXSpreadChild;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function jsxIdentifier(name) {
      const node = {
        type: "JSXIdentifier",
        name
      };
      const defs = NODE_FIELDS.JSXIdentifier;
      validate(defs.name, node, "name", name);
      return node;
    }
    function jsxMemberExpression(object, property) {
      const node = {
        type: "JSXMemberExpression",
        object,
        property
      };
      const defs = NODE_FIELDS.JSXMemberExpression;
      validate(defs.object, node, "object", object, 1);
      validate(defs.property, node, "property", property, 1);
      return node;
    }
    function jsxNamespacedName(namespace, name) {
      const node = {
        type: "JSXNamespacedName",
        namespace,
        name
      };
      const defs = NODE_FIELDS.JSXNamespacedName;
      validate(defs.namespace, node, "namespace", namespace, 1);
      validate(defs.name, node, "name", name, 1);
      return node;
    }
    function jsxOpeningElement(name, attributes, selfClosing = false) {
      const node = {
        type: "JSXOpeningElement",
        name,
        attributes,
        selfClosing
      };
      const defs = NODE_FIELDS.JSXOpeningElement;
      validate(defs.name, node, "name", name, 1);
      validate(defs.attributes, node, "attributes", attributes, 1);
      validate(defs.selfClosing, node, "selfClosing", selfClosing);
      return node;
    }
    function jsxSpreadAttribute(argument) {
      const node = {
        type: "JSXSpreadAttribute",
        argument
      };
      const defs = NODE_FIELDS.JSXSpreadAttribute;
      validate(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function jsxText(value) {
      const node = {
        type: "JSXText",
        value
      };
      const defs = NODE_FIELDS.JSXText;
      validate(defs.value, node, "value", value);
      return node;
    }
    function jsxFragment(openingFragment, closingFragment, children) {
      const node = {
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
      };
      const defs = NODE_FIELDS.JSXFragment;
      validate(defs.openingFragment, node, "openingFragment", openingFragment, 1);
      validate(defs.closingFragment, node, "closingFragment", closingFragment, 1);
      validate(defs.children, node, "children", children, 1);
      return node;
    }
    function jsxOpeningFragment() {
      return {
        type: "JSXOpeningFragment"
      };
    }
    function jsxClosingFragment() {
      return {
        type: "JSXClosingFragment"
      };
    }
    function noop() {
      return {
        type: "Noop"
      };
    }
    function placeholder(expectedNode, name) {
      const node = {
        type: "Placeholder",
        expectedNode,
        name
      };
      const defs = NODE_FIELDS.Placeholder;
      validate(defs.expectedNode, node, "expectedNode", expectedNode);
      validate(defs.name, node, "name", name, 1);
      return node;
    }
    function v8IntrinsicIdentifier(name) {
      const node = {
        type: "V8IntrinsicIdentifier",
        name
      };
      const defs = NODE_FIELDS.V8IntrinsicIdentifier;
      validate(defs.name, node, "name", name);
      return node;
    }
    function argumentPlaceholder() {
      return {
        type: "ArgumentPlaceholder"
      };
    }
    function bindExpression(object, callee) {
      const node = {
        type: "BindExpression",
        object,
        callee
      };
      const defs = NODE_FIELDS.BindExpression;
      validate(defs.object, node, "object", object, 1);
      validate(defs.callee, node, "callee", callee, 1);
      return node;
    }
    function importAttribute(key, value) {
      const node = {
        type: "ImportAttribute",
        key,
        value
      };
      const defs = NODE_FIELDS.ImportAttribute;
      validate(defs.key, node, "key", key, 1);
      validate(defs.value, node, "value", value, 1);
      return node;
    }
    function decorator(expression) {
      const node = {
        type: "Decorator",
        expression
      };
      const defs = NODE_FIELDS.Decorator;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function doExpression(body, async = false) {
      const node = {
        type: "DoExpression",
        body,
        async
      };
      const defs = NODE_FIELDS.DoExpression;
      validate(defs.body, node, "body", body, 1);
      validate(defs.async, node, "async", async);
      return node;
    }
    function exportDefaultSpecifier(exported) {
      const node = {
        type: "ExportDefaultSpecifier",
        exported
      };
      const defs = NODE_FIELDS.ExportDefaultSpecifier;
      validate(defs.exported, node, "exported", exported, 1);
      return node;
    }
    function recordExpression(properties) {
      const node = {
        type: "RecordExpression",
        properties
      };
      const defs = NODE_FIELDS.RecordExpression;
      validate(defs.properties, node, "properties", properties, 1);
      return node;
    }
    function tupleExpression(elements = []) {
      const node = {
        type: "TupleExpression",
        elements
      };
      const defs = NODE_FIELDS.TupleExpression;
      validate(defs.elements, node, "elements", elements, 1);
      return node;
    }
    function decimalLiteral(value) {
      const node = {
        type: "DecimalLiteral",
        value
      };
      const defs = NODE_FIELDS.DecimalLiteral;
      validate(defs.value, node, "value", value);
      return node;
    }
    function moduleExpression(body) {
      const node = {
        type: "ModuleExpression",
        body
      };
      const defs = NODE_FIELDS.ModuleExpression;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function topicReference() {
      return {
        type: "TopicReference"
      };
    }
    function pipelineTopicExpression(expression) {
      const node = {
        type: "PipelineTopicExpression",
        expression
      };
      const defs = NODE_FIELDS.PipelineTopicExpression;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function pipelineBareFunction(callee) {
      const node = {
        type: "PipelineBareFunction",
        callee
      };
      const defs = NODE_FIELDS.PipelineBareFunction;
      validate(defs.callee, node, "callee", callee, 1);
      return node;
    }
    function pipelinePrimaryTopicReference() {
      return {
        type: "PipelinePrimaryTopicReference"
      };
    }
    function tsParameterProperty(parameter) {
      const node = {
        type: "TSParameterProperty",
        parameter
      };
      const defs = NODE_FIELDS.TSParameterProperty;
      validate(defs.parameter, node, "parameter", parameter, 1);
      return node;
    }
    function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
      const node = {
        type: "TSDeclareFunction",
        id,
        typeParameters,
        params,
        returnType
      };
      const defs = NODE_FIELDS.TSDeclareFunction;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.returnType, node, "returnType", returnType, 1);
      return node;
    }
    function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
      const node = {
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
      };
      const defs = NODE_FIELDS.TSDeclareMethod;
      validate(defs.decorators, node, "decorators", decorators, 1);
      validate(defs.key, node, "key", key, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.params, node, "params", params, 1);
      validate(defs.returnType, node, "returnType", returnType, 1);
      return node;
    }
    function tsQualifiedName(left, right) {
      const node = {
        type: "TSQualifiedName",
        left,
        right
      };
      const defs = NODE_FIELDS.TSQualifiedName;
      validate(defs.left, node, "left", left, 1);
      validate(defs.right, node, "right", right, 1);
      return node;
    }
    function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSCallSignatureDeclaration;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsPropertySignature(key, typeAnnotation2 = null) {
      const node = {
        type: "TSPropertySignature",
        key,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSPropertySignature;
      validate(defs.key, node, "key", key, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2,
        kind: null
      };
      const defs = NODE_FIELDS.TSMethodSignature;
      validate(defs.key, node, "key", key, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsIndexSignature(parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSIndexSignature",
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSIndexSignature;
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsAnyKeyword() {
      return {
        type: "TSAnyKeyword"
      };
    }
    function tsBooleanKeyword() {
      return {
        type: "TSBooleanKeyword"
      };
    }
    function tsBigIntKeyword() {
      return {
        type: "TSBigIntKeyword"
      };
    }
    function tsIntrinsicKeyword() {
      return {
        type: "TSIntrinsicKeyword"
      };
    }
    function tsNeverKeyword() {
      return {
        type: "TSNeverKeyword"
      };
    }
    function tsNullKeyword() {
      return {
        type: "TSNullKeyword"
      };
    }
    function tsNumberKeyword() {
      return {
        type: "TSNumberKeyword"
      };
    }
    function tsObjectKeyword() {
      return {
        type: "TSObjectKeyword"
      };
    }
    function tsStringKeyword() {
      return {
        type: "TSStringKeyword"
      };
    }
    function tsSymbolKeyword() {
      return {
        type: "TSSymbolKeyword"
      };
    }
    function tsUndefinedKeyword() {
      return {
        type: "TSUndefinedKeyword"
      };
    }
    function tsUnknownKeyword() {
      return {
        type: "TSUnknownKeyword"
      };
    }
    function tsVoidKeyword() {
      return {
        type: "TSVoidKeyword"
      };
    }
    function tsThisType() {
      return {
        type: "TSThisType"
      };
    }
    function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSFunctionType;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node = {
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSConstructorType;
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsTypeReference(typeName, typeParameters = null) {
      const node = {
        type: "TSTypeReference",
        typeName,
        typeParameters
      };
      const defs = NODE_FIELDS.TSTypeReference;
      validate(defs.typeName, node, "typeName", typeName, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
      const node = {
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts
      };
      const defs = NODE_FIELDS.TSTypePredicate;
      validate(defs.parameterName, node, "parameterName", parameterName, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.asserts, node, "asserts", asserts);
      return node;
    }
    function tsTypeQuery(exprName, typeParameters = null) {
      const node = {
        type: "TSTypeQuery",
        exprName,
        typeParameters
      };
      const defs = NODE_FIELDS.TSTypeQuery;
      validate(defs.exprName, node, "exprName", exprName, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsTypeLiteral(members) {
      const node = {
        type: "TSTypeLiteral",
        members
      };
      const defs = NODE_FIELDS.TSTypeLiteral;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function tsArrayType(elementType) {
      const node = {
        type: "TSArrayType",
        elementType
      };
      const defs = NODE_FIELDS.TSArrayType;
      validate(defs.elementType, node, "elementType", elementType, 1);
      return node;
    }
    function tsTupleType(elementTypes) {
      const node = {
        type: "TSTupleType",
        elementTypes
      };
      const defs = NODE_FIELDS.TSTupleType;
      validate(defs.elementTypes, node, "elementTypes", elementTypes, 1);
      return node;
    }
    function tsOptionalType(typeAnnotation2) {
      const node = {
        type: "TSOptionalType",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSOptionalType;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsRestType(typeAnnotation2) {
      const node = {
        type: "TSRestType",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSRestType;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsNamedTupleMember(label, elementType, optional = false) {
      const node = {
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
      };
      const defs = NODE_FIELDS.TSNamedTupleMember;
      validate(defs.label, node, "label", label, 1);
      validate(defs.elementType, node, "elementType", elementType, 1);
      validate(defs.optional, node, "optional", optional);
      return node;
    }
    function tsUnionType(types) {
      const node = {
        type: "TSUnionType",
        types
      };
      const defs = NODE_FIELDS.TSUnionType;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function tsIntersectionType(types) {
      const node = {
        type: "TSIntersectionType",
        types
      };
      const defs = NODE_FIELDS.TSIntersectionType;
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      const node = {
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
      };
      const defs = NODE_FIELDS.TSConditionalType;
      validate(defs.checkType, node, "checkType", checkType, 1);
      validate(defs.extendsType, node, "extendsType", extendsType, 1);
      validate(defs.trueType, node, "trueType", trueType, 1);
      validate(defs.falseType, node, "falseType", falseType, 1);
      return node;
    }
    function tsInferType(typeParameter2) {
      const node = {
        type: "TSInferType",
        typeParameter: typeParameter2
      };
      const defs = NODE_FIELDS.TSInferType;
      validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1);
      return node;
    }
    function tsParenthesizedType(typeAnnotation2) {
      const node = {
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSParenthesizedType;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsTypeOperator(typeAnnotation2) {
      const node = {
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation2,
        operator: null
      };
      const defs = NODE_FIELDS.TSTypeOperator;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsIndexedAccessType(objectType, indexType) {
      const node = {
        type: "TSIndexedAccessType",
        objectType,
        indexType
      };
      const defs = NODE_FIELDS.TSIndexedAccessType;
      validate(defs.objectType, node, "objectType", objectType, 1);
      validate(defs.indexType, node, "indexType", indexType, 1);
      return node;
    }
    function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
      const node = {
        type: "TSMappedType",
        typeParameter: typeParameter2,
        typeAnnotation: typeAnnotation2,
        nameType
      };
      const defs = NODE_FIELDS.TSMappedType;
      validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.nameType, node, "nameType", nameType, 1);
      return node;
    }
    function tsTemplateLiteralType(quasis, types) {
      const node = {
        type: "TSTemplateLiteralType",
        quasis,
        types
      };
      const defs = NODE_FIELDS.TSTemplateLiteralType;
      validate(defs.quasis, node, "quasis", quasis, 1);
      validate(defs.types, node, "types", types, 1);
      return node;
    }
    function tsLiteralType(literal) {
      const node = {
        type: "TSLiteralType",
        literal
      };
      const defs = NODE_FIELDS.TSLiteralType;
      validate(defs.literal, node, "literal", literal, 1);
      return node;
    }
    function tsExpressionWithTypeArguments(expression, typeParameters = null) {
      const node = {
        type: "TSExpressionWithTypeArguments",
        expression,
        typeParameters
      };
      const defs = NODE_FIELDS.TSExpressionWithTypeArguments;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      const node = {
        type: "TSInterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.TSInterfaceDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.extends, node, "extends", _extends, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function tsInterfaceBody(body) {
      const node = {
        type: "TSInterfaceBody",
        body
      };
      const defs = NODE_FIELDS.TSInterfaceBody;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
      const node = {
        type: "TSTypeAliasDeclaration",
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSTypeAliasDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsInstantiationExpression(expression, typeParameters = null) {
      const node = {
        type: "TSInstantiationExpression",
        expression,
        typeParameters
      };
      const defs = NODE_FIELDS.TSInstantiationExpression;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsAsExpression(expression, typeAnnotation2) {
      const node = {
        type: "TSAsExpression",
        expression,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSAsExpression;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsSatisfiesExpression(expression, typeAnnotation2) {
      const node = {
        type: "TSSatisfiesExpression",
        expression,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSSatisfiesExpression;
      validate(defs.expression, node, "expression", expression, 1);
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsTypeAssertion(typeAnnotation2, expression) {
      const node = {
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation2,
        expression
      };
      const defs = NODE_FIELDS.TSTypeAssertion;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsEnumBody(members) {
      const node = {
        type: "TSEnumBody",
        members
      };
      const defs = NODE_FIELDS.TSEnumBody;
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function tsEnumDeclaration(id, members) {
      const node = {
        type: "TSEnumDeclaration",
        id,
        members
      };
      const defs = NODE_FIELDS.TSEnumDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.members, node, "members", members, 1);
      return node;
    }
    function tsEnumMember(id, initializer = null) {
      const node = {
        type: "TSEnumMember",
        id,
        initializer
      };
      const defs = NODE_FIELDS.TSEnumMember;
      validate(defs.id, node, "id", id, 1);
      validate(defs.initializer, node, "initializer", initializer, 1);
      return node;
    }
    function tsModuleDeclaration(id, body) {
      const node = {
        type: "TSModuleDeclaration",
        id,
        body,
        kind: null
      };
      const defs = NODE_FIELDS.TSModuleDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function tsModuleBlock(body) {
      const node = {
        type: "TSModuleBlock",
        body
      };
      const defs = NODE_FIELDS.TSModuleBlock;
      validate(defs.body, node, "body", body, 1);
      return node;
    }
    function tsImportType(argument, qualifier = null, typeParameters = null) {
      const node = {
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
      };
      const defs = NODE_FIELDS.TSImportType;
      validate(defs.argument, node, "argument", argument, 1);
      validate(defs.qualifier, node, "qualifier", qualifier, 1);
      validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
      return node;
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      const node = {
        type: "TSImportEqualsDeclaration",
        id,
        moduleReference,
        isExport: null
      };
      const defs = NODE_FIELDS.TSImportEqualsDeclaration;
      validate(defs.id, node, "id", id, 1);
      validate(defs.moduleReference, node, "moduleReference", moduleReference, 1);
      return node;
    }
    function tsExternalModuleReference(expression) {
      const node = {
        type: "TSExternalModuleReference",
        expression
      };
      const defs = NODE_FIELDS.TSExternalModuleReference;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsNonNullExpression(expression) {
      const node = {
        type: "TSNonNullExpression",
        expression
      };
      const defs = NODE_FIELDS.TSNonNullExpression;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsExportAssignment(expression) {
      const node = {
        type: "TSExportAssignment",
        expression
      };
      const defs = NODE_FIELDS.TSExportAssignment;
      validate(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsNamespaceExportDeclaration(id) {
      const node = {
        type: "TSNamespaceExportDeclaration",
        id
      };
      const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
      validate(defs.id, node, "id", id, 1);
      return node;
    }
    function tsTypeAnnotation(typeAnnotation2) {
      const node = {
        type: "TSTypeAnnotation",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSTypeAnnotation;
      validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
      return node;
    }
    function tsTypeParameterInstantiation(params) {
      const node = {
        type: "TSTypeParameterInstantiation",
        params
      };
      const defs = NODE_FIELDS.TSTypeParameterInstantiation;
      validate(defs.params, node, "params", params, 1);
      return node;
    }
    function tsTypeParameterDeclaration(params) {
      const node = {
        type: "TSTypeParameterDeclaration",
        params
      };
      const defs = NODE_FIELDS.TSTypeParameterDeclaration;
      validate(defs.params, node, "params", params, 1);
      return node;
    }
    function tsTypeParameter(constraint = null, _default = null, name) {
      const node = {
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name
      };
      const defs = NODE_FIELDS.TSTypeParameter;
      validate(defs.constraint, node, "constraint", constraint, 1);
      validate(defs.default, node, "default", _default, 1);
      validate(defs.name, node, "name", name);
      return node;
    }
    function NumberLiteral(value) {
      (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
      return numericLiteral(value);
    }
    function RegexLiteral(pattern, flags = "") {
      (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
      return regExpLiteral(pattern, flags);
    }
    function RestProperty(argument) {
      (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
      return restElement(argument);
    }
    function SpreadProperty(argument) {
      (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
      return spreadElement(argument);
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "AnyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.anyTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ArgumentPlaceholder", {
      enumerable: true,
      get: function() {
        return _lowercase.argumentPlaceholder;
      }
    });
    Object.defineProperty(exports2, "ArrayExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.arrayExpression;
      }
    });
    Object.defineProperty(exports2, "ArrayPattern", {
      enumerable: true,
      get: function() {
        return _lowercase.arrayPattern;
      }
    });
    Object.defineProperty(exports2, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.arrayTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ArrowFunctionExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.arrowFunctionExpression;
      }
    });
    Object.defineProperty(exports2, "AssignmentExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.assignmentExpression;
      }
    });
    Object.defineProperty(exports2, "AssignmentPattern", {
      enumerable: true,
      get: function() {
        return _lowercase.assignmentPattern;
      }
    });
    Object.defineProperty(exports2, "AwaitExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.awaitExpression;
      }
    });
    Object.defineProperty(exports2, "BigIntLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.bigIntLiteral;
      }
    });
    Object.defineProperty(exports2, "BinaryExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.binaryExpression;
      }
    });
    Object.defineProperty(exports2, "BindExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.bindExpression;
      }
    });
    Object.defineProperty(exports2, "BlockStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.blockStatement;
      }
    });
    Object.defineProperty(exports2, "BooleanLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.booleanLiteral;
      }
    });
    Object.defineProperty(exports2, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.booleanLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.booleanTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "BreakStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.breakStatement;
      }
    });
    Object.defineProperty(exports2, "CallExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.callExpression;
      }
    });
    Object.defineProperty(exports2, "CatchClause", {
      enumerable: true,
      get: function() {
        return _lowercase.catchClause;
      }
    });
    Object.defineProperty(exports2, "ClassAccessorProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.classAccessorProperty;
      }
    });
    Object.defineProperty(exports2, "ClassBody", {
      enumerable: true,
      get: function() {
        return _lowercase.classBody;
      }
    });
    Object.defineProperty(exports2, "ClassDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.classDeclaration;
      }
    });
    Object.defineProperty(exports2, "ClassExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.classExpression;
      }
    });
    Object.defineProperty(exports2, "ClassImplements", {
      enumerable: true,
      get: function() {
        return _lowercase.classImplements;
      }
    });
    Object.defineProperty(exports2, "ClassMethod", {
      enumerable: true,
      get: function() {
        return _lowercase.classMethod;
      }
    });
    Object.defineProperty(exports2, "ClassPrivateMethod", {
      enumerable: true,
      get: function() {
        return _lowercase.classPrivateMethod;
      }
    });
    Object.defineProperty(exports2, "ClassPrivateProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.classPrivateProperty;
      }
    });
    Object.defineProperty(exports2, "ClassProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.classProperty;
      }
    });
    Object.defineProperty(exports2, "ConditionalExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.conditionalExpression;
      }
    });
    Object.defineProperty(exports2, "ContinueStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.continueStatement;
      }
    });
    Object.defineProperty(exports2, "DebuggerStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.debuggerStatement;
      }
    });
    Object.defineProperty(exports2, "DecimalLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.decimalLiteral;
      }
    });
    Object.defineProperty(exports2, "DeclareClass", {
      enumerable: true,
      get: function() {
        return _lowercase.declareClass;
      }
    });
    Object.defineProperty(exports2, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.declareExportAllDeclaration;
      }
    });
    Object.defineProperty(exports2, "DeclareExportDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.declareExportDeclaration;
      }
    });
    Object.defineProperty(exports2, "DeclareFunction", {
      enumerable: true,
      get: function() {
        return _lowercase.declareFunction;
      }
    });
    Object.defineProperty(exports2, "DeclareInterface", {
      enumerable: true,
      get: function() {
        return _lowercase.declareInterface;
      }
    });
    Object.defineProperty(exports2, "DeclareModule", {
      enumerable: true,
      get: function() {
        return _lowercase.declareModule;
      }
    });
    Object.defineProperty(exports2, "DeclareModuleExports", {
      enumerable: true,
      get: function() {
        return _lowercase.declareModuleExports;
      }
    });
    Object.defineProperty(exports2, "DeclareOpaqueType", {
      enumerable: true,
      get: function() {
        return _lowercase.declareOpaqueType;
      }
    });
    Object.defineProperty(exports2, "DeclareTypeAlias", {
      enumerable: true,
      get: function() {
        return _lowercase.declareTypeAlias;
      }
    });
    Object.defineProperty(exports2, "DeclareVariable", {
      enumerable: true,
      get: function() {
        return _lowercase.declareVariable;
      }
    });
    Object.defineProperty(exports2, "DeclaredPredicate", {
      enumerable: true,
      get: function() {
        return _lowercase.declaredPredicate;
      }
    });
    Object.defineProperty(exports2, "Decorator", {
      enumerable: true,
      get: function() {
        return _lowercase.decorator;
      }
    });
    Object.defineProperty(exports2, "Directive", {
      enumerable: true,
      get: function() {
        return _lowercase.directive;
      }
    });
    Object.defineProperty(exports2, "DirectiveLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.directiveLiteral;
      }
    });
    Object.defineProperty(exports2, "DoExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.doExpression;
      }
    });
    Object.defineProperty(exports2, "DoWhileStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.doWhileStatement;
      }
    });
    Object.defineProperty(exports2, "EmptyStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.emptyStatement;
      }
    });
    Object.defineProperty(exports2, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.emptyTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "EnumBooleanBody", {
      enumerable: true,
      get: function() {
        return _lowercase.enumBooleanBody;
      }
    });
    Object.defineProperty(exports2, "EnumBooleanMember", {
      enumerable: true,
      get: function() {
        return _lowercase.enumBooleanMember;
      }
    });
    Object.defineProperty(exports2, "EnumDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.enumDeclaration;
      }
    });
    Object.defineProperty(exports2, "EnumDefaultedMember", {
      enumerable: true,
      get: function() {
        return _lowercase.enumDefaultedMember;
      }
    });
    Object.defineProperty(exports2, "EnumNumberBody", {
      enumerable: true,
      get: function() {
        return _lowercase.enumNumberBody;
      }
    });
    Object.defineProperty(exports2, "EnumNumberMember", {
      enumerable: true,
      get: function() {
        return _lowercase.enumNumberMember;
      }
    });
    Object.defineProperty(exports2, "EnumStringBody", {
      enumerable: true,
      get: function() {
        return _lowercase.enumStringBody;
      }
    });
    Object.defineProperty(exports2, "EnumStringMember", {
      enumerable: true,
      get: function() {
        return _lowercase.enumStringMember;
      }
    });
    Object.defineProperty(exports2, "EnumSymbolBody", {
      enumerable: true,
      get: function() {
        return _lowercase.enumSymbolBody;
      }
    });
    Object.defineProperty(exports2, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.existsTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.exportAllDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.exportDefaultDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.exportDefaultSpecifier;
      }
    });
    Object.defineProperty(exports2, "ExportNamedDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.exportNamedDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.exportNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports2, "ExportSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.exportSpecifier;
      }
    });
    Object.defineProperty(exports2, "ExpressionStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.expressionStatement;
      }
    });
    Object.defineProperty(exports2, "File", {
      enumerable: true,
      get: function() {
        return _lowercase.file;
      }
    });
    Object.defineProperty(exports2, "ForInStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.forInStatement;
      }
    });
    Object.defineProperty(exports2, "ForOfStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.forOfStatement;
      }
    });
    Object.defineProperty(exports2, "ForStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.forStatement;
      }
    });
    Object.defineProperty(exports2, "FunctionDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.functionDeclaration;
      }
    });
    Object.defineProperty(exports2, "FunctionExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.functionExpression;
      }
    });
    Object.defineProperty(exports2, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.functionTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "FunctionTypeParam", {
      enumerable: true,
      get: function() {
        return _lowercase.functionTypeParam;
      }
    });
    Object.defineProperty(exports2, "GenericTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.genericTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "Identifier", {
      enumerable: true,
      get: function() {
        return _lowercase.identifier;
      }
    });
    Object.defineProperty(exports2, "IfStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.ifStatement;
      }
    });
    Object.defineProperty(exports2, "Import", {
      enumerable: true,
      get: function() {
        return _lowercase.import;
      }
    });
    Object.defineProperty(exports2, "ImportAttribute", {
      enumerable: true,
      get: function() {
        return _lowercase.importAttribute;
      }
    });
    Object.defineProperty(exports2, "ImportDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.importDeclaration;
      }
    });
    Object.defineProperty(exports2, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.importDefaultSpecifier;
      }
    });
    Object.defineProperty(exports2, "ImportExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.importExpression;
      }
    });
    Object.defineProperty(exports2, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.importNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports2, "ImportSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.importSpecifier;
      }
    });
    Object.defineProperty(exports2, "IndexedAccessType", {
      enumerable: true,
      get: function() {
        return _lowercase.indexedAccessType;
      }
    });
    Object.defineProperty(exports2, "InferredPredicate", {
      enumerable: true,
      get: function() {
        return _lowercase.inferredPredicate;
      }
    });
    Object.defineProperty(exports2, "InterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.interfaceDeclaration;
      }
    });
    Object.defineProperty(exports2, "InterfaceExtends", {
      enumerable: true,
      get: function() {
        return _lowercase.interfaceExtends;
      }
    });
    Object.defineProperty(exports2, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.interfaceTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "InterpreterDirective", {
      enumerable: true,
      get: function() {
        return _lowercase.interpreterDirective;
      }
    });
    Object.defineProperty(exports2, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.intersectionTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "JSXAttribute", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxAttribute;
      }
    });
    Object.defineProperty(exports2, "JSXClosingElement", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxClosingElement;
      }
    });
    Object.defineProperty(exports2, "JSXClosingFragment", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxClosingFragment;
      }
    });
    Object.defineProperty(exports2, "JSXElement", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxElement;
      }
    });
    Object.defineProperty(exports2, "JSXEmptyExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxEmptyExpression;
      }
    });
    Object.defineProperty(exports2, "JSXExpressionContainer", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxExpressionContainer;
      }
    });
    Object.defineProperty(exports2, "JSXFragment", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxFragment;
      }
    });
    Object.defineProperty(exports2, "JSXIdentifier", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxIdentifier;
      }
    });
    Object.defineProperty(exports2, "JSXMemberExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxMemberExpression;
      }
    });
    Object.defineProperty(exports2, "JSXNamespacedName", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxNamespacedName;
      }
    });
    Object.defineProperty(exports2, "JSXOpeningElement", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxOpeningElement;
      }
    });
    Object.defineProperty(exports2, "JSXOpeningFragment", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxOpeningFragment;
      }
    });
    Object.defineProperty(exports2, "JSXSpreadAttribute", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxSpreadAttribute;
      }
    });
    Object.defineProperty(exports2, "JSXSpreadChild", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxSpreadChild;
      }
    });
    Object.defineProperty(exports2, "JSXText", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxText;
      }
    });
    Object.defineProperty(exports2, "LabeledStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.labeledStatement;
      }
    });
    Object.defineProperty(exports2, "LogicalExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.logicalExpression;
      }
    });
    Object.defineProperty(exports2, "MemberExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.memberExpression;
      }
    });
    Object.defineProperty(exports2, "MetaProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.metaProperty;
      }
    });
    Object.defineProperty(exports2, "MixedTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.mixedTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ModuleExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.moduleExpression;
      }
    });
    Object.defineProperty(exports2, "NewExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.newExpression;
      }
    });
    Object.defineProperty(exports2, "Noop", {
      enumerable: true,
      get: function() {
        return _lowercase.noop;
      }
    });
    Object.defineProperty(exports2, "NullLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.nullLiteral;
      }
    });
    Object.defineProperty(exports2, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.nullLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NullableTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.nullableTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NumberLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.numberLiteral;
      }
    });
    Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.numberLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NumberTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.numberTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NumericLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.numericLiteral;
      }
    });
    Object.defineProperty(exports2, "ObjectExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.objectExpression;
      }
    });
    Object.defineProperty(exports2, "ObjectMethod", {
      enumerable: true,
      get: function() {
        return _lowercase.objectMethod;
      }
    });
    Object.defineProperty(exports2, "ObjectPattern", {
      enumerable: true,
      get: function() {
        return _lowercase.objectPattern;
      }
    });
    Object.defineProperty(exports2, "ObjectProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.objectProperty;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeCallProperty;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeIndexer", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeIndexer;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeInternalSlot;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeProperty;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeSpreadProperty;
      }
    });
    Object.defineProperty(exports2, "OpaqueType", {
      enumerable: true,
      get: function() {
        return _lowercase.opaqueType;
      }
    });
    Object.defineProperty(exports2, "OptionalCallExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.optionalCallExpression;
      }
    });
    Object.defineProperty(exports2, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _lowercase.optionalIndexedAccessType;
      }
    });
    Object.defineProperty(exports2, "OptionalMemberExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.optionalMemberExpression;
      }
    });
    Object.defineProperty(exports2, "ParenthesizedExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.parenthesizedExpression;
      }
    });
    Object.defineProperty(exports2, "PipelineBareFunction", {
      enumerable: true,
      get: function() {
        return _lowercase.pipelineBareFunction;
      }
    });
    Object.defineProperty(exports2, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function() {
        return _lowercase.pipelinePrimaryTopicReference;
      }
    });
    Object.defineProperty(exports2, "PipelineTopicExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.pipelineTopicExpression;
      }
    });
    Object.defineProperty(exports2, "Placeholder", {
      enumerable: true,
      get: function() {
        return _lowercase.placeholder;
      }
    });
    Object.defineProperty(exports2, "PrivateName", {
      enumerable: true,
      get: function() {
        return _lowercase.privateName;
      }
    });
    Object.defineProperty(exports2, "Program", {
      enumerable: true,
      get: function() {
        return _lowercase.program;
      }
    });
    Object.defineProperty(exports2, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function() {
        return _lowercase.qualifiedTypeIdentifier;
      }
    });
    Object.defineProperty(exports2, "RecordExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.recordExpression;
      }
    });
    Object.defineProperty(exports2, "RegExpLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.regExpLiteral;
      }
    });
    Object.defineProperty(exports2, "RegexLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.regexLiteral;
      }
    });
    Object.defineProperty(exports2, "RestElement", {
      enumerable: true,
      get: function() {
        return _lowercase.restElement;
      }
    });
    Object.defineProperty(exports2, "RestProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.restProperty;
      }
    });
    Object.defineProperty(exports2, "ReturnStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.returnStatement;
      }
    });
    Object.defineProperty(exports2, "SequenceExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.sequenceExpression;
      }
    });
    Object.defineProperty(exports2, "SpreadElement", {
      enumerable: true,
      get: function() {
        return _lowercase.spreadElement;
      }
    });
    Object.defineProperty(exports2, "SpreadProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.spreadProperty;
      }
    });
    Object.defineProperty(exports2, "StaticBlock", {
      enumerable: true,
      get: function() {
        return _lowercase.staticBlock;
      }
    });
    Object.defineProperty(exports2, "StringLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.stringLiteral;
      }
    });
    Object.defineProperty(exports2, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.stringLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "StringTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.stringTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "Super", {
      enumerable: true,
      get: function() {
        return _lowercase.super;
      }
    });
    Object.defineProperty(exports2, "SwitchCase", {
      enumerable: true,
      get: function() {
        return _lowercase.switchCase;
      }
    });
    Object.defineProperty(exports2, "SwitchStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.switchStatement;
      }
    });
    Object.defineProperty(exports2, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.symbolTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TSAnyKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsAnyKeyword;
      }
    });
    Object.defineProperty(exports2, "TSArrayType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsArrayType;
      }
    });
    Object.defineProperty(exports2, "TSAsExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tsAsExpression;
      }
    });
    Object.defineProperty(exports2, "TSBigIntKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsBigIntKeyword;
      }
    });
    Object.defineProperty(exports2, "TSBooleanKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsBooleanKeyword;
      }
    });
    Object.defineProperty(exports2, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsCallSignatureDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSConditionalType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsConditionalType;
      }
    });
    Object.defineProperty(exports2, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsConstructSignatureDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSConstructorType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsConstructorType;
      }
    });
    Object.defineProperty(exports2, "TSDeclareFunction", {
      enumerable: true,
      get: function() {
        return _lowercase.tsDeclareFunction;
      }
    });
    Object.defineProperty(exports2, "TSDeclareMethod", {
      enumerable: true,
      get: function() {
        return _lowercase.tsDeclareMethod;
      }
    });
    Object.defineProperty(exports2, "TSEnumBody", {
      enumerable: true,
      get: function() {
        return _lowercase.tsEnumBody;
      }
    });
    Object.defineProperty(exports2, "TSEnumDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsEnumDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSEnumMember", {
      enumerable: true,
      get: function() {
        return _lowercase.tsEnumMember;
      }
    });
    Object.defineProperty(exports2, "TSExportAssignment", {
      enumerable: true,
      get: function() {
        return _lowercase.tsExportAssignment;
      }
    });
    Object.defineProperty(exports2, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function() {
        return _lowercase.tsExpressionWithTypeArguments;
      }
    });
    Object.defineProperty(exports2, "TSExternalModuleReference", {
      enumerable: true,
      get: function() {
        return _lowercase.tsExternalModuleReference;
      }
    });
    Object.defineProperty(exports2, "TSFunctionType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsFunctionType;
      }
    });
    Object.defineProperty(exports2, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsImportEqualsDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSImportType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsImportType;
      }
    });
    Object.defineProperty(exports2, "TSIndexSignature", {
      enumerable: true,
      get: function() {
        return _lowercase.tsIndexSignature;
      }
    });
    Object.defineProperty(exports2, "TSIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsIndexedAccessType;
      }
    });
    Object.defineProperty(exports2, "TSInferType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsInferType;
      }
    });
    Object.defineProperty(exports2, "TSInstantiationExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tsInstantiationExpression;
      }
    });
    Object.defineProperty(exports2, "TSInterfaceBody", {
      enumerable: true,
      get: function() {
        return _lowercase.tsInterfaceBody;
      }
    });
    Object.defineProperty(exports2, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsInterfaceDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSIntersectionType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsIntersectionType;
      }
    });
    Object.defineProperty(exports2, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsIntrinsicKeyword;
      }
    });
    Object.defineProperty(exports2, "TSLiteralType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsLiteralType;
      }
    });
    Object.defineProperty(exports2, "TSMappedType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsMappedType;
      }
    });
    Object.defineProperty(exports2, "TSMethodSignature", {
      enumerable: true,
      get: function() {
        return _lowercase.tsMethodSignature;
      }
    });
    Object.defineProperty(exports2, "TSModuleBlock", {
      enumerable: true,
      get: function() {
        return _lowercase.tsModuleBlock;
      }
    });
    Object.defineProperty(exports2, "TSModuleDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsModuleDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSNamedTupleMember", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNamedTupleMember;
      }
    });
    Object.defineProperty(exports2, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNamespaceExportDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSNeverKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNeverKeyword;
      }
    });
    Object.defineProperty(exports2, "TSNonNullExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNonNullExpression;
      }
    });
    Object.defineProperty(exports2, "TSNullKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNullKeyword;
      }
    });
    Object.defineProperty(exports2, "TSNumberKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNumberKeyword;
      }
    });
    Object.defineProperty(exports2, "TSObjectKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsObjectKeyword;
      }
    });
    Object.defineProperty(exports2, "TSOptionalType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsOptionalType;
      }
    });
    Object.defineProperty(exports2, "TSParameterProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.tsParameterProperty;
      }
    });
    Object.defineProperty(exports2, "TSParenthesizedType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsParenthesizedType;
      }
    });
    Object.defineProperty(exports2, "TSPropertySignature", {
      enumerable: true,
      get: function() {
        return _lowercase.tsPropertySignature;
      }
    });
    Object.defineProperty(exports2, "TSQualifiedName", {
      enumerable: true,
      get: function() {
        return _lowercase.tsQualifiedName;
      }
    });
    Object.defineProperty(exports2, "TSRestType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsRestType;
      }
    });
    Object.defineProperty(exports2, "TSSatisfiesExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tsSatisfiesExpression;
      }
    });
    Object.defineProperty(exports2, "TSStringKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsStringKeyword;
      }
    });
    Object.defineProperty(exports2, "TSSymbolKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsSymbolKeyword;
      }
    });
    Object.defineProperty(exports2, "TSTemplateLiteralType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTemplateLiteralType;
      }
    });
    Object.defineProperty(exports2, "TSThisType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsThisType;
      }
    });
    Object.defineProperty(exports2, "TSTupleType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTupleType;
      }
    });
    Object.defineProperty(exports2, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeAliasDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TSTypeAssertion", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeAssertion;
      }
    });
    Object.defineProperty(exports2, "TSTypeLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeLiteral;
      }
    });
    Object.defineProperty(exports2, "TSTypeOperator", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeOperator;
      }
    });
    Object.defineProperty(exports2, "TSTypeParameter", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeParameter;
      }
    });
    Object.defineProperty(exports2, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeParameterDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeParameterInstantiation;
      }
    });
    Object.defineProperty(exports2, "TSTypePredicate", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypePredicate;
      }
    });
    Object.defineProperty(exports2, "TSTypeQuery", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeQuery;
      }
    });
    Object.defineProperty(exports2, "TSTypeReference", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeReference;
      }
    });
    Object.defineProperty(exports2, "TSUndefinedKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsUndefinedKeyword;
      }
    });
    Object.defineProperty(exports2, "TSUnionType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsUnionType;
      }
    });
    Object.defineProperty(exports2, "TSUnknownKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsUnknownKeyword;
      }
    });
    Object.defineProperty(exports2, "TSVoidKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsVoidKeyword;
      }
    });
    Object.defineProperty(exports2, "TaggedTemplateExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.taggedTemplateExpression;
      }
    });
    Object.defineProperty(exports2, "TemplateElement", {
      enumerable: true,
      get: function() {
        return _lowercase.templateElement;
      }
    });
    Object.defineProperty(exports2, "TemplateLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.templateLiteral;
      }
    });
    Object.defineProperty(exports2, "ThisExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.thisExpression;
      }
    });
    Object.defineProperty(exports2, "ThisTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.thisTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ThrowStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.throwStatement;
      }
    });
    Object.defineProperty(exports2, "TopicReference", {
      enumerable: true,
      get: function() {
        return _lowercase.topicReference;
      }
    });
    Object.defineProperty(exports2, "TryStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.tryStatement;
      }
    });
    Object.defineProperty(exports2, "TupleExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tupleExpression;
      }
    });
    Object.defineProperty(exports2, "TupleTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.tupleTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TypeAlias", {
      enumerable: true,
      get: function() {
        return _lowercase.typeAlias;
      }
    });
    Object.defineProperty(exports2, "TypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.typeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TypeCastExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.typeCastExpression;
      }
    });
    Object.defineProperty(exports2, "TypeParameter", {
      enumerable: true,
      get: function() {
        return _lowercase.typeParameter;
      }
    });
    Object.defineProperty(exports2, "TypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.typeParameterDeclaration;
      }
    });
    Object.defineProperty(exports2, "TypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _lowercase.typeParameterInstantiation;
      }
    });
    Object.defineProperty(exports2, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.typeofTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "UnaryExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.unaryExpression;
      }
    });
    Object.defineProperty(exports2, "UnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.unionTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "UpdateExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.updateExpression;
      }
    });
    Object.defineProperty(exports2, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function() {
        return _lowercase.v8IntrinsicIdentifier;
      }
    });
    Object.defineProperty(exports2, "VariableDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.variableDeclaration;
      }
    });
    Object.defineProperty(exports2, "VariableDeclarator", {
      enumerable: true,
      get: function() {
        return _lowercase.variableDeclarator;
      }
    });
    Object.defineProperty(exports2, "Variance", {
      enumerable: true,
      get: function() {
        return _lowercase.variance;
      }
    });
    Object.defineProperty(exports2, "VoidTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.voidTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "WhileStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.whileStatement;
      }
    });
    Object.defineProperty(exports2, "WithStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.withStatement;
      }
    });
    Object.defineProperty(exports2, "YieldExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.yieldExpression;
      }
    });
    var _lowercase = require_lowercase();
  }
});

// node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _lowercase = require_lowercase();
    Object.keys(_lowercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _lowercase[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _lowercase[key];
        }
      });
    });
    var _uppercase = require_uppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _uppercase[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
  }
});

// node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
  "node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cleanJSXElementLiteralChild;
    var _index = require_generated2();
    var _index2 = require_lib4();
    function cleanJSXElementLiteralChild(child, args) {
      const lines = child.value.split(/\r\n|\n|\r/);
      let lastNonEmptyLine = 0;
      for (let i = 0; i < lines.length; i++) {
        if (/[^ \t]/.exec(lines[i])) {
          lastNonEmptyLine = i;
        }
      }
      let str = "";
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^ +/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/ +$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
    }
  }
});

// node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
  "node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = buildChildren;
    var _index = require_generated();
    var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
    function buildChildren(node) {
      const elements = [];
      for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i];
        if ((0, _index.isJSXText)(child)) {
          (0, _cleanJSXElementLiteralChild.default)(child, elements);
          continue;
        }
        if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
        if ((0, _index.isJSXEmptyExpression)(child)) continue;
        elements.push(child);
      }
      return elements;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
  "node_modules/@babel/types/lib/validators/isNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isNode;
    var _index = require_definitions();
    function isNode(node) {
      return !!(node && _index.VISITOR_KEYS[node.type]);
    }
  }
});

// node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
  "node_modules/@babel/types/lib/asserts/assertNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = assertNode;
    var _isNode = require_isNode();
    function assertNode(node) {
      if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
      }
    }
  }
});

// node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
  "node_modules/@babel/types/lib/asserts/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertAccessor = assertAccessor;
    exports2.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    exports2.assertArgumentPlaceholder = assertArgumentPlaceholder;
    exports2.assertArrayExpression = assertArrayExpression;
    exports2.assertArrayPattern = assertArrayPattern;
    exports2.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    exports2.assertArrowFunctionExpression = assertArrowFunctionExpression;
    exports2.assertAssignmentExpression = assertAssignmentExpression;
    exports2.assertAssignmentPattern = assertAssignmentPattern;
    exports2.assertAwaitExpression = assertAwaitExpression;
    exports2.assertBigIntLiteral = assertBigIntLiteral;
    exports2.assertBinary = assertBinary;
    exports2.assertBinaryExpression = assertBinaryExpression;
    exports2.assertBindExpression = assertBindExpression;
    exports2.assertBlock = assertBlock;
    exports2.assertBlockParent = assertBlockParent;
    exports2.assertBlockStatement = assertBlockStatement;
    exports2.assertBooleanLiteral = assertBooleanLiteral;
    exports2.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    exports2.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    exports2.assertBreakStatement = assertBreakStatement;
    exports2.assertCallExpression = assertCallExpression;
    exports2.assertCatchClause = assertCatchClause;
    exports2.assertClass = assertClass;
    exports2.assertClassAccessorProperty = assertClassAccessorProperty;
    exports2.assertClassBody = assertClassBody;
    exports2.assertClassDeclaration = assertClassDeclaration;
    exports2.assertClassExpression = assertClassExpression;
    exports2.assertClassImplements = assertClassImplements;
    exports2.assertClassMethod = assertClassMethod;
    exports2.assertClassPrivateMethod = assertClassPrivateMethod;
    exports2.assertClassPrivateProperty = assertClassPrivateProperty;
    exports2.assertClassProperty = assertClassProperty;
    exports2.assertCompletionStatement = assertCompletionStatement;
    exports2.assertConditional = assertConditional;
    exports2.assertConditionalExpression = assertConditionalExpression;
    exports2.assertContinueStatement = assertContinueStatement;
    exports2.assertDebuggerStatement = assertDebuggerStatement;
    exports2.assertDecimalLiteral = assertDecimalLiteral;
    exports2.assertDeclaration = assertDeclaration;
    exports2.assertDeclareClass = assertDeclareClass;
    exports2.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    exports2.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    exports2.assertDeclareFunction = assertDeclareFunction;
    exports2.assertDeclareInterface = assertDeclareInterface;
    exports2.assertDeclareModule = assertDeclareModule;
    exports2.assertDeclareModuleExports = assertDeclareModuleExports;
    exports2.assertDeclareOpaqueType = assertDeclareOpaqueType;
    exports2.assertDeclareTypeAlias = assertDeclareTypeAlias;
    exports2.assertDeclareVariable = assertDeclareVariable;
    exports2.assertDeclaredPredicate = assertDeclaredPredicate;
    exports2.assertDecorator = assertDecorator;
    exports2.assertDirective = assertDirective;
    exports2.assertDirectiveLiteral = assertDirectiveLiteral;
    exports2.assertDoExpression = assertDoExpression;
    exports2.assertDoWhileStatement = assertDoWhileStatement;
    exports2.assertEmptyStatement = assertEmptyStatement;
    exports2.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    exports2.assertEnumBody = assertEnumBody;
    exports2.assertEnumBooleanBody = assertEnumBooleanBody;
    exports2.assertEnumBooleanMember = assertEnumBooleanMember;
    exports2.assertEnumDeclaration = assertEnumDeclaration;
    exports2.assertEnumDefaultedMember = assertEnumDefaultedMember;
    exports2.assertEnumMember = assertEnumMember;
    exports2.assertEnumNumberBody = assertEnumNumberBody;
    exports2.assertEnumNumberMember = assertEnumNumberMember;
    exports2.assertEnumStringBody = assertEnumStringBody;
    exports2.assertEnumStringMember = assertEnumStringMember;
    exports2.assertEnumSymbolBody = assertEnumSymbolBody;
    exports2.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    exports2.assertExportAllDeclaration = assertExportAllDeclaration;
    exports2.assertExportDeclaration = assertExportDeclaration;
    exports2.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    exports2.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    exports2.assertExportNamedDeclaration = assertExportNamedDeclaration;
    exports2.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    exports2.assertExportSpecifier = assertExportSpecifier;
    exports2.assertExpression = assertExpression;
    exports2.assertExpressionStatement = assertExpressionStatement;
    exports2.assertExpressionWrapper = assertExpressionWrapper;
    exports2.assertFile = assertFile;
    exports2.assertFlow = assertFlow;
    exports2.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    exports2.assertFlowDeclaration = assertFlowDeclaration;
    exports2.assertFlowPredicate = assertFlowPredicate;
    exports2.assertFlowType = assertFlowType;
    exports2.assertFor = assertFor;
    exports2.assertForInStatement = assertForInStatement;
    exports2.assertForOfStatement = assertForOfStatement;
    exports2.assertForStatement = assertForStatement;
    exports2.assertForXStatement = assertForXStatement;
    exports2.assertFunction = assertFunction;
    exports2.assertFunctionDeclaration = assertFunctionDeclaration;
    exports2.assertFunctionExpression = assertFunctionExpression;
    exports2.assertFunctionParent = assertFunctionParent;
    exports2.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    exports2.assertFunctionTypeParam = assertFunctionTypeParam;
    exports2.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    exports2.assertIdentifier = assertIdentifier;
    exports2.assertIfStatement = assertIfStatement;
    exports2.assertImmutable = assertImmutable;
    exports2.assertImport = assertImport;
    exports2.assertImportAttribute = assertImportAttribute;
    exports2.assertImportDeclaration = assertImportDeclaration;
    exports2.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    exports2.assertImportExpression = assertImportExpression;
    exports2.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    exports2.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
    exports2.assertImportSpecifier = assertImportSpecifier;
    exports2.assertIndexedAccessType = assertIndexedAccessType;
    exports2.assertInferredPredicate = assertInferredPredicate;
    exports2.assertInterfaceDeclaration = assertInterfaceDeclaration;
    exports2.assertInterfaceExtends = assertInterfaceExtends;
    exports2.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    exports2.assertInterpreterDirective = assertInterpreterDirective;
    exports2.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    exports2.assertJSX = assertJSX;
    exports2.assertJSXAttribute = assertJSXAttribute;
    exports2.assertJSXClosingElement = assertJSXClosingElement;
    exports2.assertJSXClosingFragment = assertJSXClosingFragment;
    exports2.assertJSXElement = assertJSXElement;
    exports2.assertJSXEmptyExpression = assertJSXEmptyExpression;
    exports2.assertJSXExpressionContainer = assertJSXExpressionContainer;
    exports2.assertJSXFragment = assertJSXFragment;
    exports2.assertJSXIdentifier = assertJSXIdentifier;
    exports2.assertJSXMemberExpression = assertJSXMemberExpression;
    exports2.assertJSXNamespacedName = assertJSXNamespacedName;
    exports2.assertJSXOpeningElement = assertJSXOpeningElement;
    exports2.assertJSXOpeningFragment = assertJSXOpeningFragment;
    exports2.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    exports2.assertJSXSpreadChild = assertJSXSpreadChild;
    exports2.assertJSXText = assertJSXText;
    exports2.assertLVal = assertLVal;
    exports2.assertLabeledStatement = assertLabeledStatement;
    exports2.assertLiteral = assertLiteral;
    exports2.assertLogicalExpression = assertLogicalExpression;
    exports2.assertLoop = assertLoop;
    exports2.assertMemberExpression = assertMemberExpression;
    exports2.assertMetaProperty = assertMetaProperty;
    exports2.assertMethod = assertMethod;
    exports2.assertMiscellaneous = assertMiscellaneous;
    exports2.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    exports2.assertModuleDeclaration = assertModuleDeclaration;
    exports2.assertModuleExpression = assertModuleExpression;
    exports2.assertModuleSpecifier = assertModuleSpecifier;
    exports2.assertNewExpression = assertNewExpression;
    exports2.assertNoop = assertNoop;
    exports2.assertNullLiteral = assertNullLiteral;
    exports2.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    exports2.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    exports2.assertNumberLiteral = assertNumberLiteral;
    exports2.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    exports2.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    exports2.assertNumericLiteral = assertNumericLiteral;
    exports2.assertObjectExpression = assertObjectExpression;
    exports2.assertObjectMember = assertObjectMember;
    exports2.assertObjectMethod = assertObjectMethod;
    exports2.assertObjectPattern = assertObjectPattern;
    exports2.assertObjectProperty = assertObjectProperty;
    exports2.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    exports2.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    exports2.assertObjectTypeIndexer = assertObjectTypeIndexer;
    exports2.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    exports2.assertObjectTypeProperty = assertObjectTypeProperty;
    exports2.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    exports2.assertOpaqueType = assertOpaqueType;
    exports2.assertOptionalCallExpression = assertOptionalCallExpression;
    exports2.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    exports2.assertOptionalMemberExpression = assertOptionalMemberExpression;
    exports2.assertParenthesizedExpression = assertParenthesizedExpression;
    exports2.assertPattern = assertPattern;
    exports2.assertPatternLike = assertPatternLike;
    exports2.assertPipelineBareFunction = assertPipelineBareFunction;
    exports2.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    exports2.assertPipelineTopicExpression = assertPipelineTopicExpression;
    exports2.assertPlaceholder = assertPlaceholder;
    exports2.assertPrivate = assertPrivate;
    exports2.assertPrivateName = assertPrivateName;
    exports2.assertProgram = assertProgram;
    exports2.assertProperty = assertProperty;
    exports2.assertPureish = assertPureish;
    exports2.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    exports2.assertRecordExpression = assertRecordExpression;
    exports2.assertRegExpLiteral = assertRegExpLiteral;
    exports2.assertRegexLiteral = assertRegexLiteral;
    exports2.assertRestElement = assertRestElement;
    exports2.assertRestProperty = assertRestProperty;
    exports2.assertReturnStatement = assertReturnStatement;
    exports2.assertScopable = assertScopable;
    exports2.assertSequenceExpression = assertSequenceExpression;
    exports2.assertSpreadElement = assertSpreadElement;
    exports2.assertSpreadProperty = assertSpreadProperty;
    exports2.assertStandardized = assertStandardized;
    exports2.assertStatement = assertStatement;
    exports2.assertStaticBlock = assertStaticBlock;
    exports2.assertStringLiteral = assertStringLiteral;
    exports2.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    exports2.assertStringTypeAnnotation = assertStringTypeAnnotation;
    exports2.assertSuper = assertSuper;
    exports2.assertSwitchCase = assertSwitchCase;
    exports2.assertSwitchStatement = assertSwitchStatement;
    exports2.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    exports2.assertTSAnyKeyword = assertTSAnyKeyword;
    exports2.assertTSArrayType = assertTSArrayType;
    exports2.assertTSAsExpression = assertTSAsExpression;
    exports2.assertTSBaseType = assertTSBaseType;
    exports2.assertTSBigIntKeyword = assertTSBigIntKeyword;
    exports2.assertTSBooleanKeyword = assertTSBooleanKeyword;
    exports2.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    exports2.assertTSConditionalType = assertTSConditionalType;
    exports2.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    exports2.assertTSConstructorType = assertTSConstructorType;
    exports2.assertTSDeclareFunction = assertTSDeclareFunction;
    exports2.assertTSDeclareMethod = assertTSDeclareMethod;
    exports2.assertTSEntityName = assertTSEntityName;
    exports2.assertTSEnumBody = assertTSEnumBody;
    exports2.assertTSEnumDeclaration = assertTSEnumDeclaration;
    exports2.assertTSEnumMember = assertTSEnumMember;
    exports2.assertTSExportAssignment = assertTSExportAssignment;
    exports2.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    exports2.assertTSExternalModuleReference = assertTSExternalModuleReference;
    exports2.assertTSFunctionType = assertTSFunctionType;
    exports2.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    exports2.assertTSImportType = assertTSImportType;
    exports2.assertTSIndexSignature = assertTSIndexSignature;
    exports2.assertTSIndexedAccessType = assertTSIndexedAccessType;
    exports2.assertTSInferType = assertTSInferType;
    exports2.assertTSInstantiationExpression = assertTSInstantiationExpression;
    exports2.assertTSInterfaceBody = assertTSInterfaceBody;
    exports2.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    exports2.assertTSIntersectionType = assertTSIntersectionType;
    exports2.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    exports2.assertTSLiteralType = assertTSLiteralType;
    exports2.assertTSMappedType = assertTSMappedType;
    exports2.assertTSMethodSignature = assertTSMethodSignature;
    exports2.assertTSModuleBlock = assertTSModuleBlock;
    exports2.assertTSModuleDeclaration = assertTSModuleDeclaration;
    exports2.assertTSNamedTupleMember = assertTSNamedTupleMember;
    exports2.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    exports2.assertTSNeverKeyword = assertTSNeverKeyword;
    exports2.assertTSNonNullExpression = assertTSNonNullExpression;
    exports2.assertTSNullKeyword = assertTSNullKeyword;
    exports2.assertTSNumberKeyword = assertTSNumberKeyword;
    exports2.assertTSObjectKeyword = assertTSObjectKeyword;
    exports2.assertTSOptionalType = assertTSOptionalType;
    exports2.assertTSParameterProperty = assertTSParameterProperty;
    exports2.assertTSParenthesizedType = assertTSParenthesizedType;
    exports2.assertTSPropertySignature = assertTSPropertySignature;
    exports2.assertTSQualifiedName = assertTSQualifiedName;
    exports2.assertTSRestType = assertTSRestType;
    exports2.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    exports2.assertTSStringKeyword = assertTSStringKeyword;
    exports2.assertTSSymbolKeyword = assertTSSymbolKeyword;
    exports2.assertTSTemplateLiteralType = assertTSTemplateLiteralType;
    exports2.assertTSThisType = assertTSThisType;
    exports2.assertTSTupleType = assertTSTupleType;
    exports2.assertTSType = assertTSType;
    exports2.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    exports2.assertTSTypeAnnotation = assertTSTypeAnnotation;
    exports2.assertTSTypeAssertion = assertTSTypeAssertion;
    exports2.assertTSTypeElement = assertTSTypeElement;
    exports2.assertTSTypeLiteral = assertTSTypeLiteral;
    exports2.assertTSTypeOperator = assertTSTypeOperator;
    exports2.assertTSTypeParameter = assertTSTypeParameter;
    exports2.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    exports2.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    exports2.assertTSTypePredicate = assertTSTypePredicate;
    exports2.assertTSTypeQuery = assertTSTypeQuery;
    exports2.assertTSTypeReference = assertTSTypeReference;
    exports2.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    exports2.assertTSUnionType = assertTSUnionType;
    exports2.assertTSUnknownKeyword = assertTSUnknownKeyword;
    exports2.assertTSVoidKeyword = assertTSVoidKeyword;
    exports2.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    exports2.assertTemplateElement = assertTemplateElement;
    exports2.assertTemplateLiteral = assertTemplateLiteral;
    exports2.assertTerminatorless = assertTerminatorless;
    exports2.assertThisExpression = assertThisExpression;
    exports2.assertThisTypeAnnotation = assertThisTypeAnnotation;
    exports2.assertThrowStatement = assertThrowStatement;
    exports2.assertTopicReference = assertTopicReference;
    exports2.assertTryStatement = assertTryStatement;
    exports2.assertTupleExpression = assertTupleExpression;
    exports2.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    exports2.assertTypeAlias = assertTypeAlias;
    exports2.assertTypeAnnotation = assertTypeAnnotation;
    exports2.assertTypeCastExpression = assertTypeCastExpression;
    exports2.assertTypeParameter = assertTypeParameter;
    exports2.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    exports2.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    exports2.assertTypeScript = assertTypeScript;
    exports2.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    exports2.assertUnaryExpression = assertUnaryExpression;
    exports2.assertUnaryLike = assertUnaryLike;
    exports2.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    exports2.assertUpdateExpression = assertUpdateExpression;
    exports2.assertUserWhitespacable = assertUserWhitespacable;
    exports2.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    exports2.assertVariableDeclaration = assertVariableDeclaration;
    exports2.assertVariableDeclarator = assertVariableDeclarator;
    exports2.assertVariance = assertVariance;
    exports2.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    exports2.assertWhile = assertWhile;
    exports2.assertWhileStatement = assertWhileStatement;
    exports2.assertWithStatement = assertWithStatement;
    exports2.assertYieldExpression = assertYieldExpression;
    var _is = require_is();
    var _deprecationWarning = require_deprecationWarning();
    function assert(type, node, opts) {
      if (!(0, _is.default)(type, node, opts)) {
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
      }
    }
    function assertArrayExpression(node, opts) {
      assert("ArrayExpression", node, opts);
    }
    function assertAssignmentExpression(node, opts) {
      assert("AssignmentExpression", node, opts);
    }
    function assertBinaryExpression(node, opts) {
      assert("BinaryExpression", node, opts);
    }
    function assertInterpreterDirective(node, opts) {
      assert("InterpreterDirective", node, opts);
    }
    function assertDirective(node, opts) {
      assert("Directive", node, opts);
    }
    function assertDirectiveLiteral(node, opts) {
      assert("DirectiveLiteral", node, opts);
    }
    function assertBlockStatement(node, opts) {
      assert("BlockStatement", node, opts);
    }
    function assertBreakStatement(node, opts) {
      assert("BreakStatement", node, opts);
    }
    function assertCallExpression(node, opts) {
      assert("CallExpression", node, opts);
    }
    function assertCatchClause(node, opts) {
      assert("CatchClause", node, opts);
    }
    function assertConditionalExpression(node, opts) {
      assert("ConditionalExpression", node, opts);
    }
    function assertContinueStatement(node, opts) {
      assert("ContinueStatement", node, opts);
    }
    function assertDebuggerStatement(node, opts) {
      assert("DebuggerStatement", node, opts);
    }
    function assertDoWhileStatement(node, opts) {
      assert("DoWhileStatement", node, opts);
    }
    function assertEmptyStatement(node, opts) {
      assert("EmptyStatement", node, opts);
    }
    function assertExpressionStatement(node, opts) {
      assert("ExpressionStatement", node, opts);
    }
    function assertFile(node, opts) {
      assert("File", node, opts);
    }
    function assertForInStatement(node, opts) {
      assert("ForInStatement", node, opts);
    }
    function assertForStatement(node, opts) {
      assert("ForStatement", node, opts);
    }
    function assertFunctionDeclaration(node, opts) {
      assert("FunctionDeclaration", node, opts);
    }
    function assertFunctionExpression(node, opts) {
      assert("FunctionExpression", node, opts);
    }
    function assertIdentifier(node, opts) {
      assert("Identifier", node, opts);
    }
    function assertIfStatement(node, opts) {
      assert("IfStatement", node, opts);
    }
    function assertLabeledStatement(node, opts) {
      assert("LabeledStatement", node, opts);
    }
    function assertStringLiteral(node, opts) {
      assert("StringLiteral", node, opts);
    }
    function assertNumericLiteral(node, opts) {
      assert("NumericLiteral", node, opts);
    }
    function assertNullLiteral(node, opts) {
      assert("NullLiteral", node, opts);
    }
    function assertBooleanLiteral(node, opts) {
      assert("BooleanLiteral", node, opts);
    }
    function assertRegExpLiteral(node, opts) {
      assert("RegExpLiteral", node, opts);
    }
    function assertLogicalExpression(node, opts) {
      assert("LogicalExpression", node, opts);
    }
    function assertMemberExpression(node, opts) {
      assert("MemberExpression", node, opts);
    }
    function assertNewExpression(node, opts) {
      assert("NewExpression", node, opts);
    }
    function assertProgram(node, opts) {
      assert("Program", node, opts);
    }
    function assertObjectExpression(node, opts) {
      assert("ObjectExpression", node, opts);
    }
    function assertObjectMethod(node, opts) {
      assert("ObjectMethod", node, opts);
    }
    function assertObjectProperty(node, opts) {
      assert("ObjectProperty", node, opts);
    }
    function assertRestElement(node, opts) {
      assert("RestElement", node, opts);
    }
    function assertReturnStatement(node, opts) {
      assert("ReturnStatement", node, opts);
    }
    function assertSequenceExpression(node, opts) {
      assert("SequenceExpression", node, opts);
    }
    function assertParenthesizedExpression(node, opts) {
      assert("ParenthesizedExpression", node, opts);
    }
    function assertSwitchCase(node, opts) {
      assert("SwitchCase", node, opts);
    }
    function assertSwitchStatement(node, opts) {
      assert("SwitchStatement", node, opts);
    }
    function assertThisExpression(node, opts) {
      assert("ThisExpression", node, opts);
    }
    function assertThrowStatement(node, opts) {
      assert("ThrowStatement", node, opts);
    }
    function assertTryStatement(node, opts) {
      assert("TryStatement", node, opts);
    }
    function assertUnaryExpression(node, opts) {
      assert("UnaryExpression", node, opts);
    }
    function assertUpdateExpression(node, opts) {
      assert("UpdateExpression", node, opts);
    }
    function assertVariableDeclaration(node, opts) {
      assert("VariableDeclaration", node, opts);
    }
    function assertVariableDeclarator(node, opts) {
      assert("VariableDeclarator", node, opts);
    }
    function assertWhileStatement(node, opts) {
      assert("WhileStatement", node, opts);
    }
    function assertWithStatement(node, opts) {
      assert("WithStatement", node, opts);
    }
    function assertAssignmentPattern(node, opts) {
      assert("AssignmentPattern", node, opts);
    }
    function assertArrayPattern(node, opts) {
      assert("ArrayPattern", node, opts);
    }
    function assertArrowFunctionExpression(node, opts) {
      assert("ArrowFunctionExpression", node, opts);
    }
    function assertClassBody(node, opts) {
      assert("ClassBody", node, opts);
    }
    function assertClassExpression(node, opts) {
      assert("ClassExpression", node, opts);
    }
    function assertClassDeclaration(node, opts) {
      assert("ClassDeclaration", node, opts);
    }
    function assertExportAllDeclaration(node, opts) {
      assert("ExportAllDeclaration", node, opts);
    }
    function assertExportDefaultDeclaration(node, opts) {
      assert("ExportDefaultDeclaration", node, opts);
    }
    function assertExportNamedDeclaration(node, opts) {
      assert("ExportNamedDeclaration", node, opts);
    }
    function assertExportSpecifier(node, opts) {
      assert("ExportSpecifier", node, opts);
    }
    function assertForOfStatement(node, opts) {
      assert("ForOfStatement", node, opts);
    }
    function assertImportDeclaration(node, opts) {
      assert("ImportDeclaration", node, opts);
    }
    function assertImportDefaultSpecifier(node, opts) {
      assert("ImportDefaultSpecifier", node, opts);
    }
    function assertImportNamespaceSpecifier(node, opts) {
      assert("ImportNamespaceSpecifier", node, opts);
    }
    function assertImportSpecifier(node, opts) {
      assert("ImportSpecifier", node, opts);
    }
    function assertImportExpression(node, opts) {
      assert("ImportExpression", node, opts);
    }
    function assertMetaProperty(node, opts) {
      assert("MetaProperty", node, opts);
    }
    function assertClassMethod(node, opts) {
      assert("ClassMethod", node, opts);
    }
    function assertObjectPattern(node, opts) {
      assert("ObjectPattern", node, opts);
    }
    function assertSpreadElement(node, opts) {
      assert("SpreadElement", node, opts);
    }
    function assertSuper(node, opts) {
      assert("Super", node, opts);
    }
    function assertTaggedTemplateExpression(node, opts) {
      assert("TaggedTemplateExpression", node, opts);
    }
    function assertTemplateElement(node, opts) {
      assert("TemplateElement", node, opts);
    }
    function assertTemplateLiteral(node, opts) {
      assert("TemplateLiteral", node, opts);
    }
    function assertYieldExpression(node, opts) {
      assert("YieldExpression", node, opts);
    }
    function assertAwaitExpression(node, opts) {
      assert("AwaitExpression", node, opts);
    }
    function assertImport(node, opts) {
      assert("Import", node, opts);
    }
    function assertBigIntLiteral(node, opts) {
      assert("BigIntLiteral", node, opts);
    }
    function assertExportNamespaceSpecifier(node, opts) {
      assert("ExportNamespaceSpecifier", node, opts);
    }
    function assertOptionalMemberExpression(node, opts) {
      assert("OptionalMemberExpression", node, opts);
    }
    function assertOptionalCallExpression(node, opts) {
      assert("OptionalCallExpression", node, opts);
    }
    function assertClassProperty(node, opts) {
      assert("ClassProperty", node, opts);
    }
    function assertClassAccessorProperty(node, opts) {
      assert("ClassAccessorProperty", node, opts);
    }
    function assertClassPrivateProperty(node, opts) {
      assert("ClassPrivateProperty", node, opts);
    }
    function assertClassPrivateMethod(node, opts) {
      assert("ClassPrivateMethod", node, opts);
    }
    function assertPrivateName(node, opts) {
      assert("PrivateName", node, opts);
    }
    function assertStaticBlock(node, opts) {
      assert("StaticBlock", node, opts);
    }
    function assertAnyTypeAnnotation(node, opts) {
      assert("AnyTypeAnnotation", node, opts);
    }
    function assertArrayTypeAnnotation(node, opts) {
      assert("ArrayTypeAnnotation", node, opts);
    }
    function assertBooleanTypeAnnotation(node, opts) {
      assert("BooleanTypeAnnotation", node, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node, opts) {
      assert("BooleanLiteralTypeAnnotation", node, opts);
    }
    function assertNullLiteralTypeAnnotation(node, opts) {
      assert("NullLiteralTypeAnnotation", node, opts);
    }
    function assertClassImplements(node, opts) {
      assert("ClassImplements", node, opts);
    }
    function assertDeclareClass(node, opts) {
      assert("DeclareClass", node, opts);
    }
    function assertDeclareFunction(node, opts) {
      assert("DeclareFunction", node, opts);
    }
    function assertDeclareInterface(node, opts) {
      assert("DeclareInterface", node, opts);
    }
    function assertDeclareModule(node, opts) {
      assert("DeclareModule", node, opts);
    }
    function assertDeclareModuleExports(node, opts) {
      assert("DeclareModuleExports", node, opts);
    }
    function assertDeclareTypeAlias(node, opts) {
      assert("DeclareTypeAlias", node, opts);
    }
    function assertDeclareOpaqueType(node, opts) {
      assert("DeclareOpaqueType", node, opts);
    }
    function assertDeclareVariable(node, opts) {
      assert("DeclareVariable", node, opts);
    }
    function assertDeclareExportDeclaration(node, opts) {
      assert("DeclareExportDeclaration", node, opts);
    }
    function assertDeclareExportAllDeclaration(node, opts) {
      assert("DeclareExportAllDeclaration", node, opts);
    }
    function assertDeclaredPredicate(node, opts) {
      assert("DeclaredPredicate", node, opts);
    }
    function assertExistsTypeAnnotation(node, opts) {
      assert("ExistsTypeAnnotation", node, opts);
    }
    function assertFunctionTypeAnnotation(node, opts) {
      assert("FunctionTypeAnnotation", node, opts);
    }
    function assertFunctionTypeParam(node, opts) {
      assert("FunctionTypeParam", node, opts);
    }
    function assertGenericTypeAnnotation(node, opts) {
      assert("GenericTypeAnnotation", node, opts);
    }
    function assertInferredPredicate(node, opts) {
      assert("InferredPredicate", node, opts);
    }
    function assertInterfaceExtends(node, opts) {
      assert("InterfaceExtends", node, opts);
    }
    function assertInterfaceDeclaration(node, opts) {
      assert("InterfaceDeclaration", node, opts);
    }
    function assertInterfaceTypeAnnotation(node, opts) {
      assert("InterfaceTypeAnnotation", node, opts);
    }
    function assertIntersectionTypeAnnotation(node, opts) {
      assert("IntersectionTypeAnnotation", node, opts);
    }
    function assertMixedTypeAnnotation(node, opts) {
      assert("MixedTypeAnnotation", node, opts);
    }
    function assertEmptyTypeAnnotation(node, opts) {
      assert("EmptyTypeAnnotation", node, opts);
    }
    function assertNullableTypeAnnotation(node, opts) {
      assert("NullableTypeAnnotation", node, opts);
    }
    function assertNumberLiteralTypeAnnotation(node, opts) {
      assert("NumberLiteralTypeAnnotation", node, opts);
    }
    function assertNumberTypeAnnotation(node, opts) {
      assert("NumberTypeAnnotation", node, opts);
    }
    function assertObjectTypeAnnotation(node, opts) {
      assert("ObjectTypeAnnotation", node, opts);
    }
    function assertObjectTypeInternalSlot(node, opts) {
      assert("ObjectTypeInternalSlot", node, opts);
    }
    function assertObjectTypeCallProperty(node, opts) {
      assert("ObjectTypeCallProperty", node, opts);
    }
    function assertObjectTypeIndexer(node, opts) {
      assert("ObjectTypeIndexer", node, opts);
    }
    function assertObjectTypeProperty(node, opts) {
      assert("ObjectTypeProperty", node, opts);
    }
    function assertObjectTypeSpreadProperty(node, opts) {
      assert("ObjectTypeSpreadProperty", node, opts);
    }
    function assertOpaqueType(node, opts) {
      assert("OpaqueType", node, opts);
    }
    function assertQualifiedTypeIdentifier(node, opts) {
      assert("QualifiedTypeIdentifier", node, opts);
    }
    function assertStringLiteralTypeAnnotation(node, opts) {
      assert("StringLiteralTypeAnnotation", node, opts);
    }
    function assertStringTypeAnnotation(node, opts) {
      assert("StringTypeAnnotation", node, opts);
    }
    function assertSymbolTypeAnnotation(node, opts) {
      assert("SymbolTypeAnnotation", node, opts);
    }
    function assertThisTypeAnnotation(node, opts) {
      assert("ThisTypeAnnotation", node, opts);
    }
    function assertTupleTypeAnnotation(node, opts) {
      assert("TupleTypeAnnotation", node, opts);
    }
    function assertTypeofTypeAnnotation(node, opts) {
      assert("TypeofTypeAnnotation", node, opts);
    }
    function assertTypeAlias(node, opts) {
      assert("TypeAlias", node, opts);
    }
    function assertTypeAnnotation(node, opts) {
      assert("TypeAnnotation", node, opts);
    }
    function assertTypeCastExpression(node, opts) {
      assert("TypeCastExpression", node, opts);
    }
    function assertTypeParameter(node, opts) {
      assert("TypeParameter", node, opts);
    }
    function assertTypeParameterDeclaration(node, opts) {
      assert("TypeParameterDeclaration", node, opts);
    }
    function assertTypeParameterInstantiation(node, opts) {
      assert("TypeParameterInstantiation", node, opts);
    }
    function assertUnionTypeAnnotation(node, opts) {
      assert("UnionTypeAnnotation", node, opts);
    }
    function assertVariance(node, opts) {
      assert("Variance", node, opts);
    }
    function assertVoidTypeAnnotation(node, opts) {
      assert("VoidTypeAnnotation", node, opts);
    }
    function assertEnumDeclaration(node, opts) {
      assert("EnumDeclaration", node, opts);
    }
    function assertEnumBooleanBody(node, opts) {
      assert("EnumBooleanBody", node, opts);
    }
    function assertEnumNumberBody(node, opts) {
      assert("EnumNumberBody", node, opts);
    }
    function assertEnumStringBody(node, opts) {
      assert("EnumStringBody", node, opts);
    }
    function assertEnumSymbolBody(node, opts) {
      assert("EnumSymbolBody", node, opts);
    }
    function assertEnumBooleanMember(node, opts) {
      assert("EnumBooleanMember", node, opts);
    }
    function assertEnumNumberMember(node, opts) {
      assert("EnumNumberMember", node, opts);
    }
    function assertEnumStringMember(node, opts) {
      assert("EnumStringMember", node, opts);
    }
    function assertEnumDefaultedMember(node, opts) {
      assert("EnumDefaultedMember", node, opts);
    }
    function assertIndexedAccessType(node, opts) {
      assert("IndexedAccessType", node, opts);
    }
    function assertOptionalIndexedAccessType(node, opts) {
      assert("OptionalIndexedAccessType", node, opts);
    }
    function assertJSXAttribute(node, opts) {
      assert("JSXAttribute", node, opts);
    }
    function assertJSXClosingElement(node, opts) {
      assert("JSXClosingElement", node, opts);
    }
    function assertJSXElement(node, opts) {
      assert("JSXElement", node, opts);
    }
    function assertJSXEmptyExpression(node, opts) {
      assert("JSXEmptyExpression", node, opts);
    }
    function assertJSXExpressionContainer(node, opts) {
      assert("JSXExpressionContainer", node, opts);
    }
    function assertJSXSpreadChild(node, opts) {
      assert("JSXSpreadChild", node, opts);
    }
    function assertJSXIdentifier(node, opts) {
      assert("JSXIdentifier", node, opts);
    }
    function assertJSXMemberExpression(node, opts) {
      assert("JSXMemberExpression", node, opts);
    }
    function assertJSXNamespacedName(node, opts) {
      assert("JSXNamespacedName", node, opts);
    }
    function assertJSXOpeningElement(node, opts) {
      assert("JSXOpeningElement", node, opts);
    }
    function assertJSXSpreadAttribute(node, opts) {
      assert("JSXSpreadAttribute", node, opts);
    }
    function assertJSXText(node, opts) {
      assert("JSXText", node, opts);
    }
    function assertJSXFragment(node, opts) {
      assert("JSXFragment", node, opts);
    }
    function assertJSXOpeningFragment(node, opts) {
      assert("JSXOpeningFragment", node, opts);
    }
    function assertJSXClosingFragment(node, opts) {
      assert("JSXClosingFragment", node, opts);
    }
    function assertNoop(node, opts) {
      assert("Noop", node, opts);
    }
    function assertPlaceholder(node, opts) {
      assert("Placeholder", node, opts);
    }
    function assertV8IntrinsicIdentifier(node, opts) {
      assert("V8IntrinsicIdentifier", node, opts);
    }
    function assertArgumentPlaceholder(node, opts) {
      assert("ArgumentPlaceholder", node, opts);
    }
    function assertBindExpression(node, opts) {
      assert("BindExpression", node, opts);
    }
    function assertImportAttribute(node, opts) {
      assert("ImportAttribute", node, opts);
    }
    function assertDecorator(node, opts) {
      assert("Decorator", node, opts);
    }
    function assertDoExpression(node, opts) {
      assert("DoExpression", node, opts);
    }
    function assertExportDefaultSpecifier(node, opts) {
      assert("ExportDefaultSpecifier", node, opts);
    }
    function assertRecordExpression(node, opts) {
      assert("RecordExpression", node, opts);
    }
    function assertTupleExpression(node, opts) {
      assert("TupleExpression", node, opts);
    }
    function assertDecimalLiteral(node, opts) {
      assert("DecimalLiteral", node, opts);
    }
    function assertModuleExpression(node, opts) {
      assert("ModuleExpression", node, opts);
    }
    function assertTopicReference(node, opts) {
      assert("TopicReference", node, opts);
    }
    function assertPipelineTopicExpression(node, opts) {
      assert("PipelineTopicExpression", node, opts);
    }
    function assertPipelineBareFunction(node, opts) {
      assert("PipelineBareFunction", node, opts);
    }
    function assertPipelinePrimaryTopicReference(node, opts) {
      assert("PipelinePrimaryTopicReference", node, opts);
    }
    function assertTSParameterProperty(node, opts) {
      assert("TSParameterProperty", node, opts);
    }
    function assertTSDeclareFunction(node, opts) {
      assert("TSDeclareFunction", node, opts);
    }
    function assertTSDeclareMethod(node, opts) {
      assert("TSDeclareMethod", node, opts);
    }
    function assertTSQualifiedName(node, opts) {
      assert("TSQualifiedName", node, opts);
    }
    function assertTSCallSignatureDeclaration(node, opts) {
      assert("TSCallSignatureDeclaration", node, opts);
    }
    function assertTSConstructSignatureDeclaration(node, opts) {
      assert("TSConstructSignatureDeclaration", node, opts);
    }
    function assertTSPropertySignature(node, opts) {
      assert("TSPropertySignature", node, opts);
    }
    function assertTSMethodSignature(node, opts) {
      assert("TSMethodSignature", node, opts);
    }
    function assertTSIndexSignature(node, opts) {
      assert("TSIndexSignature", node, opts);
    }
    function assertTSAnyKeyword(node, opts) {
      assert("TSAnyKeyword", node, opts);
    }
    function assertTSBooleanKeyword(node, opts) {
      assert("TSBooleanKeyword", node, opts);
    }
    function assertTSBigIntKeyword(node, opts) {
      assert("TSBigIntKeyword", node, opts);
    }
    function assertTSIntrinsicKeyword(node, opts) {
      assert("TSIntrinsicKeyword", node, opts);
    }
    function assertTSNeverKeyword(node, opts) {
      assert("TSNeverKeyword", node, opts);
    }
    function assertTSNullKeyword(node, opts) {
      assert("TSNullKeyword", node, opts);
    }
    function assertTSNumberKeyword(node, opts) {
      assert("TSNumberKeyword", node, opts);
    }
    function assertTSObjectKeyword(node, opts) {
      assert("TSObjectKeyword", node, opts);
    }
    function assertTSStringKeyword(node, opts) {
      assert("TSStringKeyword", node, opts);
    }
    function assertTSSymbolKeyword(node, opts) {
      assert("TSSymbolKeyword", node, opts);
    }
    function assertTSUndefinedKeyword(node, opts) {
      assert("TSUndefinedKeyword", node, opts);
    }
    function assertTSUnknownKeyword(node, opts) {
      assert("TSUnknownKeyword", node, opts);
    }
    function assertTSVoidKeyword(node, opts) {
      assert("TSVoidKeyword", node, opts);
    }
    function assertTSThisType(node, opts) {
      assert("TSThisType", node, opts);
    }
    function assertTSFunctionType(node, opts) {
      assert("TSFunctionType", node, opts);
    }
    function assertTSConstructorType(node, opts) {
      assert("TSConstructorType", node, opts);
    }
    function assertTSTypeReference(node, opts) {
      assert("TSTypeReference", node, opts);
    }
    function assertTSTypePredicate(node, opts) {
      assert("TSTypePredicate", node, opts);
    }
    function assertTSTypeQuery(node, opts) {
      assert("TSTypeQuery", node, opts);
    }
    function assertTSTypeLiteral(node, opts) {
      assert("TSTypeLiteral", node, opts);
    }
    function assertTSArrayType(node, opts) {
      assert("TSArrayType", node, opts);
    }
    function assertTSTupleType(node, opts) {
      assert("TSTupleType", node, opts);
    }
    function assertTSOptionalType(node, opts) {
      assert("TSOptionalType", node, opts);
    }
    function assertTSRestType(node, opts) {
      assert("TSRestType", node, opts);
    }
    function assertTSNamedTupleMember(node, opts) {
      assert("TSNamedTupleMember", node, opts);
    }
    function assertTSUnionType(node, opts) {
      assert("TSUnionType", node, opts);
    }
    function assertTSIntersectionType(node, opts) {
      assert("TSIntersectionType", node, opts);
    }
    function assertTSConditionalType(node, opts) {
      assert("TSConditionalType", node, opts);
    }
    function assertTSInferType(node, opts) {
      assert("TSInferType", node, opts);
    }
    function assertTSParenthesizedType(node, opts) {
      assert("TSParenthesizedType", node, opts);
    }
    function assertTSTypeOperator(node, opts) {
      assert("TSTypeOperator", node, opts);
    }
    function assertTSIndexedAccessType(node, opts) {
      assert("TSIndexedAccessType", node, opts);
    }
    function assertTSMappedType(node, opts) {
      assert("TSMappedType", node, opts);
    }
    function assertTSTemplateLiteralType(node, opts) {
      assert("TSTemplateLiteralType", node, opts);
    }
    function assertTSLiteralType(node, opts) {
      assert("TSLiteralType", node, opts);
    }
    function assertTSExpressionWithTypeArguments(node, opts) {
      assert("TSExpressionWithTypeArguments", node, opts);
    }
    function assertTSInterfaceDeclaration(node, opts) {
      assert("TSInterfaceDeclaration", node, opts);
    }
    function assertTSInterfaceBody(node, opts) {
      assert("TSInterfaceBody", node, opts);
    }
    function assertTSTypeAliasDeclaration(node, opts) {
      assert("TSTypeAliasDeclaration", node, opts);
    }
    function assertTSInstantiationExpression(node, opts) {
      assert("TSInstantiationExpression", node, opts);
    }
    function assertTSAsExpression(node, opts) {
      assert("TSAsExpression", node, opts);
    }
    function assertTSSatisfiesExpression(node, opts) {
      assert("TSSatisfiesExpression", node, opts);
    }
    function assertTSTypeAssertion(node, opts) {
      assert("TSTypeAssertion", node, opts);
    }
    function assertTSEnumBody(node, opts) {
      assert("TSEnumBody", node, opts);
    }
    function assertTSEnumDeclaration(node, opts) {
      assert("TSEnumDeclaration", node, opts);
    }
    function assertTSEnumMember(node, opts) {
      assert("TSEnumMember", node, opts);
    }
    function assertTSModuleDeclaration(node, opts) {
      assert("TSModuleDeclaration", node, opts);
    }
    function assertTSModuleBlock(node, opts) {
      assert("TSModuleBlock", node, opts);
    }
    function assertTSImportType(node, opts) {
      assert("TSImportType", node, opts);
    }
    function assertTSImportEqualsDeclaration(node, opts) {
      assert("TSImportEqualsDeclaration", node, opts);
    }
    function assertTSExternalModuleReference(node, opts) {
      assert("TSExternalModuleReference", node, opts);
    }
    function assertTSNonNullExpression(node, opts) {
      assert("TSNonNullExpression", node, opts);
    }
    function assertTSExportAssignment(node, opts) {
      assert("TSExportAssignment", node, opts);
    }
    function assertTSNamespaceExportDeclaration(node, opts) {
      assert("TSNamespaceExportDeclaration", node, opts);
    }
    function assertTSTypeAnnotation(node, opts) {
      assert("TSTypeAnnotation", node, opts);
    }
    function assertTSTypeParameterInstantiation(node, opts) {
      assert("TSTypeParameterInstantiation", node, opts);
    }
    function assertTSTypeParameterDeclaration(node, opts) {
      assert("TSTypeParameterDeclaration", node, opts);
    }
    function assertTSTypeParameter(node, opts) {
      assert("TSTypeParameter", node, opts);
    }
    function assertStandardized(node, opts) {
      assert("Standardized", node, opts);
    }
    function assertExpression(node, opts) {
      assert("Expression", node, opts);
    }
    function assertBinary(node, opts) {
      assert("Binary", node, opts);
    }
    function assertScopable(node, opts) {
      assert("Scopable", node, opts);
    }
    function assertBlockParent(node, opts) {
      assert("BlockParent", node, opts);
    }
    function assertBlock(node, opts) {
      assert("Block", node, opts);
    }
    function assertStatement(node, opts) {
      assert("Statement", node, opts);
    }
    function assertTerminatorless(node, opts) {
      assert("Terminatorless", node, opts);
    }
    function assertCompletionStatement(node, opts) {
      assert("CompletionStatement", node, opts);
    }
    function assertConditional(node, opts) {
      assert("Conditional", node, opts);
    }
    function assertLoop(node, opts) {
      assert("Loop", node, opts);
    }
    function assertWhile(node, opts) {
      assert("While", node, opts);
    }
    function assertExpressionWrapper(node, opts) {
      assert("ExpressionWrapper", node, opts);
    }
    function assertFor(node, opts) {
      assert("For", node, opts);
    }
    function assertForXStatement(node, opts) {
      assert("ForXStatement", node, opts);
    }
    function assertFunction(node, opts) {
      assert("Function", node, opts);
    }
    function assertFunctionParent(node, opts) {
      assert("FunctionParent", node, opts);
    }
    function assertPureish(node, opts) {
      assert("Pureish", node, opts);
    }
    function assertDeclaration(node, opts) {
      assert("Declaration", node, opts);
    }
    function assertPatternLike(node, opts) {
      assert("PatternLike", node, opts);
    }
    function assertLVal(node, opts) {
      assert("LVal", node, opts);
    }
    function assertTSEntityName(node, opts) {
      assert("TSEntityName", node, opts);
    }
    function assertLiteral(node, opts) {
      assert("Literal", node, opts);
    }
    function assertImmutable(node, opts) {
      assert("Immutable", node, opts);
    }
    function assertUserWhitespacable(node, opts) {
      assert("UserWhitespacable", node, opts);
    }
    function assertMethod(node, opts) {
      assert("Method", node, opts);
    }
    function assertObjectMember(node, opts) {
      assert("ObjectMember", node, opts);
    }
    function assertProperty(node, opts) {
      assert("Property", node, opts);
    }
    function assertUnaryLike(node, opts) {
      assert("UnaryLike", node, opts);
    }
    function assertPattern(node, opts) {
      assert("Pattern", node, opts);
    }
    function assertClass(node, opts) {
      assert("Class", node, opts);
    }
    function assertImportOrExportDeclaration(node, opts) {
      assert("ImportOrExportDeclaration", node, opts);
    }
    function assertExportDeclaration(node, opts) {
      assert("ExportDeclaration", node, opts);
    }
    function assertModuleSpecifier(node, opts) {
      assert("ModuleSpecifier", node, opts);
    }
    function assertAccessor(node, opts) {
      assert("Accessor", node, opts);
    }
    function assertPrivate(node, opts) {
      assert("Private", node, opts);
    }
    function assertFlow(node, opts) {
      assert("Flow", node, opts);
    }
    function assertFlowType(node, opts) {
      assert("FlowType", node, opts);
    }
    function assertFlowBaseAnnotation(node, opts) {
      assert("FlowBaseAnnotation", node, opts);
    }
    function assertFlowDeclaration(node, opts) {
      assert("FlowDeclaration", node, opts);
    }
    function assertFlowPredicate(node, opts) {
      assert("FlowPredicate", node, opts);
    }
    function assertEnumBody(node, opts) {
      assert("EnumBody", node, opts);
    }
    function assertEnumMember(node, opts) {
      assert("EnumMember", node, opts);
    }
    function assertJSX(node, opts) {
      assert("JSX", node, opts);
    }
    function assertMiscellaneous(node, opts) {
      assert("Miscellaneous", node, opts);
    }
    function assertTypeScript(node, opts) {
      assert("TypeScript", node, opts);
    }
    function assertTSTypeElement(node, opts) {
      assert("TSTypeElement", node, opts);
    }
    function assertTSType(node, opts) {
      assert("TSType", node, opts);
    }
    function assertTSBaseType(node, opts) {
      assert("TSBaseType", node, opts);
    }
    function assertNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
      assert("NumberLiteral", node, opts);
    }
    function assertRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
      assert("RegexLiteral", node, opts);
    }
    function assertRestProperty(node, opts) {
      (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
      assert("RestProperty", node, opts);
    }
    function assertSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
      assert("SpreadProperty", node, opts);
    }
    function assertModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
      assert("ModuleDeclaration", node, opts);
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_generated2();
    var _default = exports2.default = createTypeAnnotationBasedOnTypeof;
    function createTypeAnnotationBasedOnTypeof(type) {
      switch (type) {
        case "string":
          return (0, _index.stringTypeAnnotation)();
        case "number":
          return (0, _index.numberTypeAnnotation)();
        case "undefined":
          return (0, _index.voidTypeAnnotation)();
        case "boolean":
          return (0, _index.booleanTypeAnnotation)();
        case "function":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
        case "object":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
        case "symbol":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
        case "bigint":
          return (0, _index.anyTypeAnnotation)();
      }
      throw new Error("Invalid typeof value: " + type);
    }
  }
});

// node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
  "node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node) {
      return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node) continue;
        if (types.includes(node)) {
          continue;
        }
        if ((0, _index.isAnyTypeAnnotation)(node)) {
          return [node];
        }
        if ((0, _index.isFlowBaseAnnotation)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _index.isUnionTypeAnnotation)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes.push(...node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        if ((0, _index.isGenericTypeAnnotation)(node)) {
          const name = getQualifiedName(node.id);
          if (generics.has(name)) {
            let existing = generics.get(name);
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params.push(...node.typeParameters.params);
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics.set(name, node);
          }
          continue;
        }
        types.push(node);
      }
      for (const [, baseType] of bases) {
        types.push(baseType);
      }
      for (const [, genericName] of generics) {
        types.push(genericName);
      }
      return types;
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createFlowUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    function createFlowUnionType(types) {
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.unionTypeAnnotation)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
  "node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node) {
      return (0, _index.isIdentifier)(node) ? node.name : (0, _index.isThisExpression)(node) ? "this" : `${node.right.name}.${getQualifiedName(node.left)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node) continue;
        if (types.includes(node)) {
          continue;
        }
        if ((0, _index.isTSAnyKeyword)(node)) {
          return [node];
        }
        if ((0, _index.isTSBaseType)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _index.isTSUnionType)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes.push(...node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        const typeArgumentsKey = "typeParameters";
        if ((0, _index.isTSTypeReference)(node) && node[typeArgumentsKey]) {
          const typeArguments = node[typeArgumentsKey];
          const name = getQualifiedName(node.typeName);
          if (generics.has(name)) {
            let existing = generics.get(name);
            const existingTypeArguments = existing[typeArgumentsKey];
            if (existingTypeArguments) {
              existingTypeArguments.params.push(...typeArguments.params);
              existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params);
            } else {
              existing = typeArguments;
            }
          } else {
            generics.set(name, node);
          }
          continue;
        }
        types.push(node);
      }
      for (const [, baseType] of bases) {
        types.push(baseType);
      }
      for (const [, genericName] of generics) {
        types.push(genericName);
      }
      return types;
    }
  }
});

// node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createTSUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates2();
    var _index2 = require_generated();
    function createTSUnionType(typeAnnotations) {
      const types = typeAnnotations.map((type) => {
        return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
      });
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.tsUnionType)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS({
  "node_modules/@babel/types/lib/builders/productions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildUndefinedNode = buildUndefinedNode;
    var _index = require_generated2();
    function buildUndefinedNode() {
      return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneNode;
    var _index = require_definitions();
    var _index2 = require_generated();
    var {
      hasOwn
    } = {
      hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
    };
    function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
      if (obj && typeof obj.type === "string") {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
      }
      return obj;
    }
    function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
      if (Array.isArray(obj)) {
        return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
      }
      return cloneIfNode(obj, deep, withoutLoc, commentsCache);
    }
    function cloneNode(node, deep = true, withoutLoc = false) {
      return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
    }
    function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
      if (!node) return node;
      const {
        type
      } = node;
      const newNode = {
        type: node.type
      };
      if ((0, _index2.isIdentifier)(node)) {
        newNode.name = node.name;
        if (hasOwn(node, "optional") && typeof node.optional === "boolean") {
          newNode.optional = node.optional;
        }
        if (hasOwn(node, "typeAnnotation")) {
          newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
        }
        if (hasOwn(node, "decorators")) {
          newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
        }
      } else if (!hasOwn(_index.NODE_FIELDS, type)) {
        throw new Error(`Unknown node type: "${type}"`);
      } else {
        for (const field of Object.keys(_index.NODE_FIELDS[type])) {
          if (hasOwn(node, field)) {
            if (deep) {
              newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
            } else {
              newNode[field] = node[field];
            }
          }
        }
      }
      if (hasOwn(node, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node.loc;
        }
      }
      if (hasOwn(node, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
      }
      if (hasOwn(node, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
      }
      if (hasOwn(node, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
      }
      if (hasOwn(node, "extra")) {
        newNode.extra = Object.assign({}, node.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
      if (!comments || !deep) {
        return comments;
      }
      return comments.map((comment) => {
        const cache = commentsCache.get(comment);
        if (cache) return cache;
        const {
          type,
          value,
          loc
        } = comment;
        const ret = {
          type,
          value,
          loc
        };
        if (withoutLoc) {
          ret.loc = null;
        }
        commentsCache.set(comment, ret);
        return ret;
      });
    }
  }
});

// node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS({
  "node_modules/@babel/types/lib/clone/clone.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = clone;
    var _cloneNode = require_cloneNode();
    function clone(node) {
      return (0, _cloneNode.default)(node, false);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneDeep;
    var _cloneNode = require_cloneNode();
    function cloneDeep(node) {
      return (0, _cloneNode.default)(node);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneDeepWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneDeepWithoutLoc(node) {
      return (0, _cloneNode.default)(node, true, true);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneWithoutLoc(node) {
      return (0, _cloneNode.default)(node, false, true);
    }
  }
});

// node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
  "node_modules/@babel/types/lib/comments/addComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = addComments;
    function addComments(node, type, comments) {
      if (!comments || !node) return node;
      const key = `${type}Comments`;
      if (node[key]) {
        if (type === "leading") {
          node[key] = comments.concat(node[key]);
        } else {
          node[key].push(...comments);
        }
      } else {
        node[key] = comments;
      }
      return node;
    }
  }
});

// node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
  "node_modules/@babel/types/lib/comments/addComment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = addComment;
    var _addComments = require_addComments();
    function addComment(node, type, content, line) {
      return (0, _addComments.default)(node, type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }
  }
});

// node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
  "node_modules/@babel/types/lib/utils/inherit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inherit;
    function inherit(key, child, parent) {
      if (child && parent) {
        child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
      }
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritInnerComments;
    var _inherit = require_inherit();
    function inheritInnerComments(child, parent) {
      (0, _inherit.default)("innerComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritLeadingComments;
    var _inherit = require_inherit();
    function inheritLeadingComments(child, parent) {
      (0, _inherit.default)("leadingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritTrailingComments;
    var _inherit = require_inherit();
    function inheritTrailingComments(child, parent) {
      (0, _inherit.default)("trailingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritsComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritsComments;
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritInnerComments = require_inheritInnerComments();
    function inheritsComments(child, parent) {
      (0, _inheritTrailingComments.default)(child, parent);
      (0, _inheritLeadingComments.default)(child, parent);
      (0, _inheritInnerComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
  "node_modules/@babel/types/lib/comments/removeComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeComments;
    var _index = require_constants();
    function removeComments(node) {
      _index.COMMENT_KEYS.forEach((key) => {
        node[key] = null;
      });
      return node;
    }
  }
});

// node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
  "node_modules/@babel/types/lib/constants/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WHILE_TYPES = exports2.USERWHITESPACABLE_TYPES = exports2.UNARYLIKE_TYPES = exports2.TYPESCRIPT_TYPES = exports2.TSTYPE_TYPES = exports2.TSTYPEELEMENT_TYPES = exports2.TSENTITYNAME_TYPES = exports2.TSBASETYPE_TYPES = exports2.TERMINATORLESS_TYPES = exports2.STATEMENT_TYPES = exports2.STANDARDIZED_TYPES = exports2.SCOPABLE_TYPES = exports2.PUREISH_TYPES = exports2.PROPERTY_TYPES = exports2.PRIVATE_TYPES = exports2.PATTERN_TYPES = exports2.PATTERNLIKE_TYPES = exports2.OBJECTMEMBER_TYPES = exports2.MODULESPECIFIER_TYPES = exports2.MODULEDECLARATION_TYPES = exports2.MISCELLANEOUS_TYPES = exports2.METHOD_TYPES = exports2.LVAL_TYPES = exports2.LOOP_TYPES = exports2.LITERAL_TYPES = exports2.JSX_TYPES = exports2.IMPORTOREXPORTDECLARATION_TYPES = exports2.IMMUTABLE_TYPES = exports2.FUNCTION_TYPES = exports2.FUNCTIONPARENT_TYPES = exports2.FOR_TYPES = exports2.FORXSTATEMENT_TYPES = exports2.FLOW_TYPES = exports2.FLOWTYPE_TYPES = exports2.FLOWPREDICATE_TYPES = exports2.FLOWDECLARATION_TYPES = exports2.FLOWBASEANNOTATION_TYPES = exports2.EXPRESSION_TYPES = exports2.EXPRESSIONWRAPPER_TYPES = exports2.EXPORTDECLARATION_TYPES = exports2.ENUMMEMBER_TYPES = exports2.ENUMBODY_TYPES = exports2.DECLARATION_TYPES = exports2.CONDITIONAL_TYPES = exports2.COMPLETIONSTATEMENT_TYPES = exports2.CLASS_TYPES = exports2.BLOCK_TYPES = exports2.BLOCKPARENT_TYPES = exports2.BINARY_TYPES = exports2.ACCESSOR_TYPES = void 0;
    var _index = require_definitions();
    var STANDARDIZED_TYPES = exports2.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
    var EXPRESSION_TYPES = exports2.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
    var BINARY_TYPES = exports2.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
    var SCOPABLE_TYPES = exports2.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
    var BLOCKPARENT_TYPES = exports2.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
    var BLOCK_TYPES = exports2.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
    var STATEMENT_TYPES = exports2.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
    var TERMINATORLESS_TYPES = exports2.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
    var COMPLETIONSTATEMENT_TYPES = exports2.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    var CONDITIONAL_TYPES = exports2.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
    var LOOP_TYPES = exports2.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
    var WHILE_TYPES = exports2.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
    var EXPRESSIONWRAPPER_TYPES = exports2.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    var FOR_TYPES = exports2.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
    var FORXSTATEMENT_TYPES = exports2.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
    var FUNCTION_TYPES = exports2.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
    var FUNCTIONPARENT_TYPES = exports2.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
    var PUREISH_TYPES = exports2.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
    var DECLARATION_TYPES = exports2.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
    var PATTERNLIKE_TYPES = exports2.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
    var LVAL_TYPES = exports2.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
    var TSENTITYNAME_TYPES = exports2.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
    var LITERAL_TYPES = exports2.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
    var IMMUTABLE_TYPES = exports2.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
    var USERWHITESPACABLE_TYPES = exports2.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    var METHOD_TYPES = exports2.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
    var OBJECTMEMBER_TYPES = exports2.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
    var PROPERTY_TYPES = exports2.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
    var UNARYLIKE_TYPES = exports2.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
    var PATTERN_TYPES = exports2.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
    var CLASS_TYPES = exports2.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
    var IMPORTOREXPORTDECLARATION_TYPES = exports2.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
    var EXPORTDECLARATION_TYPES = exports2.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    var MODULESPECIFIER_TYPES = exports2.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    var ACCESSOR_TYPES = exports2.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
    var PRIVATE_TYPES = exports2.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
    var FLOW_TYPES = exports2.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
    var FLOWTYPE_TYPES = exports2.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
    var FLOWBASEANNOTATION_TYPES = exports2.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    var FLOWDECLARATION_TYPES = exports2.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    var FLOWPREDICATE_TYPES = exports2.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    var ENUMBODY_TYPES = exports2.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
    var ENUMMEMBER_TYPES = exports2.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
    var JSX_TYPES = exports2.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
    var MISCELLANEOUS_TYPES = exports2.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
    var TYPESCRIPT_TYPES = exports2.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
    var TSTYPEELEMENT_TYPES = exports2.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    var TSTYPE_TYPES = exports2.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
    var TSBASETYPE_TYPES = exports2.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
    var MODULEDECLARATION_TYPES = exports2.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
  }
});

// node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/toBlock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toBlock;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toBlock(node, parent) {
      if ((0, _index.isBlockStatement)(node)) {
        return node;
      }
      let blockNodes = [];
      if ((0, _index.isEmptyStatement)(node)) {
        blockNodes = [];
      } else {
        if (!(0, _index.isStatement)(node)) {
          if ((0, _index.isFunction)(parent)) {
            node = (0, _index2.returnStatement)(node);
          } else {
            node = (0, _index2.expressionStatement)(node);
          }
        }
        blockNodes = [node];
      }
      return (0, _index2.blockStatement)(blockNodes);
    }
  }
});

// node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/ensureBlock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = ensureBlock;
    var _toBlock = require_toBlock();
    function ensureBlock(node, key = "body") {
      const result = (0, _toBlock.default)(node[key], node);
      node[key] = result;
      return result;
    }
  }
});

// node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
  "node_modules/@babel/types/lib/converters/toIdentifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toIdentifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib2();
    function toIdentifier(input) {
      input = input + "";
      let name = "";
      for (const c of input) {
        name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
      }
      name = name.replace(/^[-0-9]+/, "");
      name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
      });
      if (!(0, _isValidIdentifier.default)(name)) {
        name = `_${name}`;
      }
      return name || "_";
    }
  }
});

// node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
  "node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toBindingIdentifierName;
    var _toIdentifier = require_toIdentifier();
    function toBindingIdentifierName(name) {
      name = (0, _toIdentifier.default)(name);
      if (name === "eval" || name === "arguments") name = "_" + name;
      return name;
    }
  }
});

// node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
  "node_modules/@babel/types/lib/converters/toComputedKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toComputedKey;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toComputedKey(node, key = node.key || node.property) {
      if (!node.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);
      return key;
    }
  }
});

// node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_generated();
    var _default = exports2.default = toExpression;
    function toExpression(node) {
      if ((0, _index.isExpressionStatement)(node)) {
        node = node.expression;
      }
      if ((0, _index.isExpression)(node)) {
        return node;
      }
      if ((0, _index.isClass)(node)) {
        node.type = "ClassExpression";
      } else if ((0, _index.isFunction)(node)) {
        node.type = "FunctionExpression";
      }
      if (!(0, _index.isExpression)(node)) {
        throw new Error(`cannot turn ${node.type} to an expression`);
      }
      return node;
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverseFast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = traverseFast;
    var _index = require_definitions();
    function traverseFast(node, enter, opts) {
      if (!node) return;
      const keys = _index.VISITOR_KEYS[node.type];
      if (!keys) return;
      opts = opts || {};
      enter(node, opts);
      for (const key of keys) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (const node2 of subNode) {
            traverseFast(node2, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
  "node_modules/@babel/types/lib/modifications/removeProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeProperties;
    var _index = require_constants();
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
    function removeProperties(node, opts = {}) {
      const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (const key of map) {
        if (node[key] != null) node[key] = void 0;
      }
      for (const key of Object.keys(node)) {
        if (key[0] === "_" && node[key] != null) node[key] = void 0;
      }
      const symbols = Object.getOwnPropertySymbols(node);
      for (const sym of symbols) {
        node[sym] = null;
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
  "node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removePropertiesDeep;
    var _traverseFast = require_traverseFast();
    var _removeProperties = require_removeProperties();
    function removePropertiesDeep(tree, opts) {
      (0, _traverseFast.default)(tree, _removeProperties.default, opts);
      return tree;
    }
  }
});

// node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
  "node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toKeyAlias;
    var _index = require_generated();
    var _cloneNode = require_cloneNode();
    var _removePropertiesDeep = require_removePropertiesDeep();
    function toKeyAlias(node, key = node.key) {
      let alias;
      if (node.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if ((0, _index.isIdentifier)(key)) {
        alias = key.name;
      } else if ((0, _index.isStringLiteral)(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
      }
      if (node.computed) {
        alias = `[${alias}]`;
      }
      if (node.static) {
        alias = `static:${alias}`;
      }
      return alias;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
  }
});

// node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
  "node_modules/@babel/types/lib/converters/toStatement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_generated();
    var _index2 = require_generated2();
    var _default = exports2.default = toStatement;
    function toStatement(node, ignore) {
      if ((0, _index.isStatement)(node)) {
        return node;
      }
      let mustHaveId = false;
      let newType;
      if ((0, _index.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if ((0, _index.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if ((0, _index.isAssignmentExpression)(node)) {
        return (0, _index2.expressionStatement)(node);
      }
      if (mustHaveId && !node.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error(`cannot turn ${node.type} to a statement`);
        }
      }
      node.type = newType;
      return node;
    }
  }
});

// node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
  "node_modules/@babel/types/lib/converters/valueToNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _isValidIdentifier = require_isValidIdentifier();
    var _index = require_generated2();
    var _default = exports2.default = valueToNode;
    var objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value) {
      return objectToString(value) === "[object RegExp]";
    }
    function isPlainObject(value) {
      if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      return proto === null || Object.getPrototypeOf(proto) === null;
    }
    function valueToNode(value) {
      if (value === void 0) {
        return (0, _index.identifier)("undefined");
      }
      if (value === true || value === false) {
        return (0, _index.booleanLiteral)(value);
      }
      if (value === null) {
        return (0, _index.nullLiteral)();
      }
      if (typeof value === "string") {
        return (0, _index.stringLiteral)(value);
      }
      if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) {
          result = (0, _index.numericLiteral)(Math.abs(value));
        } else {
          let numerator;
          if (Number.isNaN(value)) {
            numerator = (0, _index.numericLiteral)(0);
          } else {
            numerator = (0, _index.numericLiteral)(1);
          }
          result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) {
          result = (0, _index.unaryExpression)("-", result);
        }
        return result;
      }
      if (isRegExp(value)) {
        const pattern = value.source;
        const flags = /\/([a-z]*)$/.exec(value.toString())[1];
        return (0, _index.regExpLiteral)(pattern, flags);
      }
      if (Array.isArray(value)) {
        return (0, _index.arrayExpression)(value.map(valueToNode));
      }
      if (isPlainObject(value)) {
        const props = [];
        for (const key of Object.keys(value)) {
          let nodeKey;
          if ((0, _isValidIdentifier.default)(key)) {
            nodeKey = (0, _index.identifier)(key);
          } else {
            nodeKey = (0, _index.stringLiteral)(key);
          }
          props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key])));
        }
        return (0, _index.objectExpression)(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
  }
});

// node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = appendToMemberExpression;
    var _index = require_generated2();
    function appendToMemberExpression(member, append, computed = false) {
      member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }
  }
});

// node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/types/lib/modifications/inherits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inherits;
    var _index = require_constants();
    var _inheritsComments = require_inheritsComments();
    function inherits(child, parent) {
      if (!child || !parent) return child;
      for (const key of _index.INHERIT_KEYS.optional) {
        if (child[key] == null) {
          child[key] = parent[key];
        }
      }
      for (const key of Object.keys(parent)) {
        if (key[0] === "_" && key !== "__clone") {
          child[key] = parent[key];
        }
      }
      for (const key of _index.INHERIT_KEYS.force) {
        child[key] = parent[key];
      }
      (0, _inheritsComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = prependToMemberExpression;
    var _index = require_generated2();
    var _index2 = require_lib4();
    function prependToMemberExpression(member, prepend) {
      if ((0, _index2.isSuper)(member.object)) {
        throw new Error("Cannot prepend node to super property access (`super.foo`).");
      }
      member.object = (0, _index.memberExpression)(prepend, member.object);
      return member;
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var require_getAssignmentIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getAssignmentIdentifiers;
    function getAssignmentIdentifiers(node) {
      const search = [].concat(node);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.pop();
        if (!id) continue;
        switch (id.type) {
          case "ArrayPattern":
            search.push(...id.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            search.push(id.left);
            break;
          case "ObjectPattern":
            search.push(...id.properties);
            break;
          case "ObjectProperty":
            search.push(id.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            search.push(id.argument);
            break;
          case "UnaryExpression":
            if (id.operator === "delete") {
              search.push(id.argument);
            }
            break;
          case "Identifier":
            ids[id.name] = id;
            break;
          default:
            break;
        }
      }
      return ids;
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getBindingIdentifiers;
    var _index = require_generated();
    function getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {
      const search = [].concat(node);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id) continue;
        if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {
          continue;
        }
        if ((0, _index.isIdentifier)(id)) {
          if (duplicates) {
            const _ids = ids[id.name] = ids[id.name] || [];
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
          if ((0, _index.isDeclaration)(id.declaration)) {
            search.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if ((0, _index.isFunctionDeclaration)(id)) {
            search.push(id.id);
            continue;
          }
          if ((0, _index.isFunctionExpression)(id)) {
            continue;
          }
        }
        const keys2 = getBindingIdentifiers.keys[id.type];
        if (keys2) {
          for (let i = 0; i < keys2.length; i++) {
            const key = keys2[i];
            const nodes = id[key];
            if (nodes) {
              if (Array.isArray(nodes)) {
                search.push(...nodes);
              } else {
                search.push(nodes);
              }
            }
          }
        }
      }
      return ids;
    }
    var keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      TSImportEqualsDeclaration: ["id"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ClassPrivateMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
    getBindingIdentifiers.keys = keys;
  }
});

// node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _default = exports2.default = getOuterBindingIdentifiers;
    function getOuterBindingIdentifiers(node, duplicates) {
      return (0, _getBindingIdentifiers.default)(node, duplicates, true);
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getFunctionName.js
var require_getFunctionName = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getFunctionName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getFunctionName;
    var _index = require_generated();
    function getNameFromLiteralId(id) {
      if ((0, _index.isNullLiteral)(id)) {
        return "null";
      }
      if ((0, _index.isRegExpLiteral)(id)) {
        return `/${id.pattern}/${id.flags}`;
      }
      if ((0, _index.isTemplateLiteral)(id)) {
        return id.quasis.map((quasi) => quasi.value.raw).join("");
      }
      if (id.value !== void 0) {
        return String(id.value);
      }
      return null;
    }
    function getObjectMemberKey(node) {
      if (!node.computed || (0, _index.isLiteral)(node.key)) {
        return node.key;
      }
    }
    function getFunctionName(node, parent) {
      if ("id" in node && node.id) {
        return {
          name: node.id.name,
          originalNode: node.id
        };
      }
      let prefix = "";
      let id;
      if ((0, _index.isObjectProperty)(parent, {
        value: node
      })) {
        id = getObjectMemberKey(parent);
      } else if ((0, _index.isObjectMethod)(node) || (0, _index.isClassMethod)(node)) {
        id = getObjectMemberKey(node);
        if (node.kind === "get") prefix = "get ";
        else if (node.kind === "set") prefix = "set ";
      } else if ((0, _index.isVariableDeclarator)(parent, {
        init: node
      })) {
        id = parent.id;
      } else if ((0, _index.isAssignmentExpression)(parent, {
        operator: "=",
        right: node
      })) {
        id = parent.left;
      }
      if (!id) return null;
      const name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;
      if (name == null) return null;
      return {
        name: prefix + name,
        originalNode: id
      };
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = traverse3;
    var _index = require_definitions();
    function traverse3(node, handlers, state) {
      if (typeof handlers === "function") {
        handlers = {
          enter: handlers
        };
      }
      const {
        enter,
        exit
      } = handlers;
      traverseSimpleImpl(node, enter, exit, state, []);
    }
    function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      const keys = _index.VISITOR_KEYS[node.type];
      if (!keys) return;
      if (enter) enter(node, ancestors, state);
      for (const key of keys) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (let i = 0; i < subNode.length; i++) {
            const child = subNode[i];
            if (!child) continue;
            ancestors.push({
              node,
              key,
              index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node,
            key
          });
          traverseSimpleImpl(subNode, enter, exit, state, ancestors);
          ancestors.pop();
        }
      }
      if (exit) exit(node, ancestors, state);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
  "node_modules/@babel/types/lib/validators/isBinding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBinding;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    function isBinding(node, parent, grandparent) {
      if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }
      const keys = _getBindingIdentifiers.default.keys[parent.type];
      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const val = parent[key];
          if (Array.isArray(val)) {
            if (val.includes(node)) return true;
          } else {
            if (val === node) return true;
          }
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
  "node_modules/@babel/types/lib/validators/isLet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isLet;
    var _index = require_generated();
    var _index2 = require_constants();
    function isLet(node) {
      return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[_index2.BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
  "node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBlockScoped;
    var _index = require_generated();
    var _isLet = require_isLet();
    function isBlockScoped(node) {
      return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);
    }
  }
});

// node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
  "node_modules/@babel/types/lib/validators/isImmutable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isImmutable;
    var _isType = require_isType();
    var _index = require_generated();
    function isImmutable(node) {
      if ((0, _isType.default)(node.type, "Immutable")) return true;
      if ((0, _index.isIdentifier)(node)) {
        if (node.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
  "node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isNodesEquivalent;
    var _index = require_definitions();
    function isNodesEquivalent(a, b) {
      if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
      const visitorKeys = _index.VISITOR_KEYS[a.type];
      for (const field of fields) {
        const val_a = a[field];
        const val_b = b[field];
        if (typeof val_a !== typeof val_b) {
          return false;
        }
        if (val_a == null && val_b == null) {
          continue;
        } else if (val_a == null || val_b == null) {
          return false;
        }
        if (Array.isArray(val_a)) {
          if (!Array.isArray(val_b)) {
            return false;
          }
          if (val_a.length !== val_b.length) {
            return false;
          }
          for (let i = 0; i < val_a.length; i++) {
            if (!isNodesEquivalent(val_a[i], val_b[i])) {
              return false;
            }
          }
          continue;
        }
        if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
          for (const key of Object.keys(val_a)) {
            if (val_a[key] !== val_b[key]) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(val_a, val_b)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
  "node_modules/@babel/types/lib/validators/isReferenced.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isReferenced;
    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node) {
            return !!parent.computed;
          }
          return parent.object === node;
        case "JSXMemberExpression":
          return parent.object === node;
        case "VariableDeclarator":
          return parent.init === node;
        case "ArrowFunctionExpression":
          return parent.body === node;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent != null && grandparent.source) {
            return false;
          }
          return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node;
        case "TSEnumMember":
          return parent.id !== node;
        case "TSPropertySignature":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
  "node_modules/@babel/types/lib/validators/isScope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isScope;
    var _index = require_generated();
    function isScope(node, parent) {
      if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return false;
      }
      if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return true;
      }
      return (0, _index.isScopable)(node);
    }
  }
});

// node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
  "node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isSpecifierDefault;
    var _index = require_generated();
    function isSpecifierDefault(specifier) {
      return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
  }
});

// node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isValidES3Identifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name) {
      return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
    }
  }
});

// node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
  "node_modules/@babel/types/lib/validators/isVar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isVar;
    var _index = require_generated();
    var _index2 = require_constants();
    function isVar(node) {
      return (0, _index.isVariableDeclaration)(node, {
        kind: "var"
      }) && !node[_index2.BLOCK_SCOPED_SYMBOL];
    }
  }
});

// node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
  "node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = gatherSequenceExpressions;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _index = require_generated();
    var _index2 = require_generated2();
    var _productions = require_productions();
    var _cloneNode = require_cloneNode();
    function gatherSequenceExpressions(nodes, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!(0, _index.isEmptyStatement)(node)) {
          ensureLastUndefined = false;
        }
        if ((0, _index.isExpression)(node)) {
          exprs.push(node);
        } else if ((0, _index.isExpressionStatement)(node)) {
          exprs.push(node.expression);
        } else if ((0, _index.isVariableDeclaration)(node)) {
          if (node.kind !== "var") return;
          for (const declar of node.declarations) {
            const bindings = (0, _getBindingIdentifiers.default)(declar);
            for (const key of Object.keys(bindings)) {
              declars.push({
                kind: node.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            }
            if (declar.init) {
              exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if ((0, _index.isIfStatement)(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : (0, _productions.buildUndefinedNode)();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : (0, _productions.buildUndefinedNode)();
          if (!consequent || !alternate) return;
          exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _index.isBlockStatement)(node)) {
          const body = gatherSequenceExpressions(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if ((0, _index.isEmptyStatement)(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) {
        exprs.push((0, _productions.buildUndefinedNode)());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return (0, _index2.sequenceExpression)(exprs);
      }
    }
  }
});

// node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toSequenceExpression;
    var _gatherSequenceExpressions = require_gatherSequenceExpressions();
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length)) return;
      const declars = [];
      const result = (0, _gatherSequenceExpressions.default)(nodes, declars);
      if (!result) return;
      for (const declar of declars) {
        scope.push(declar);
      }
      return result;
    }
  }
});

// node_modules/@babel/types/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@babel/types/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getAssignmentIdentifiers: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      getFunctionName: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports2, "__internal__deprecationWarning", {
      enumerable: true,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports2, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports2, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports2, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports2, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports2, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports2, "clone", {
      enumerable: true,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports2, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports2, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports2, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports2, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports2, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports2, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports2, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports2, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports2, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports2, "getAssignmentIdentifiers", {
      enumerable: true,
      get: function() {
        return _getAssignmentIdentifiers.default;
      }
    });
    Object.defineProperty(exports2, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports2, "getFunctionName", {
      enumerable: true,
      get: function() {
        return _getFunctionName.default;
      }
    });
    Object.defineProperty(exports2, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports2, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports2, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports2, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports2, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits.default;
      }
    });
    Object.defineProperty(exports2, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports2, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports2, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports2, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports2, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports2, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports2, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports2, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports2, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports2, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports2, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports2, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports2, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports2, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports2, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports2, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports2, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports2.react = void 0;
    Object.defineProperty(exports2, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports2, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports2, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports2, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports2, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports2, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports2, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports2, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports2, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports2, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports2, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports2, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports2, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports2, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = require_isReactComponent();
    var _isCompatTag = require_isCompatTag();
    var _buildChildren = require_buildChildren();
    var _assertNode = require_assertNode();
    var _index = require_generated3();
    Object.keys(_index).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = require_createFlowUnionType();
    var _createTSUnionType = require_createTSUnionType();
    var _productions = require_productions();
    Object.keys(_productions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _productions[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _productions[key];
        }
      });
    });
    var _index2 = require_generated2();
    Object.keys(_index2).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index2[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index2[key];
        }
      });
    });
    var _cloneNode = require_cloneNode();
    var _clone = require_clone();
    var _cloneDeep = require_cloneDeep();
    var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
    var _cloneWithoutLoc = require_cloneWithoutLoc();
    var _addComment = require_addComment();
    var _addComments = require_addComments();
    var _inheritInnerComments = require_inheritInnerComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritsComments = require_inheritsComments();
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _removeComments = require_removeComments();
    var _index3 = require_generated4();
    Object.keys(_index3).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index3[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index3[key];
        }
      });
    });
    var _index4 = require_constants();
    Object.keys(_index4).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index4[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index4[key];
        }
      });
    });
    var _ensureBlock = require_ensureBlock();
    var _toBindingIdentifierName = require_toBindingIdentifierName();
    var _toBlock = require_toBlock();
    var _toComputedKey = require_toComputedKey();
    var _toExpression = require_toExpression();
    var _toIdentifier = require_toIdentifier();
    var _toKeyAlias = require_toKeyAlias();
    var _toStatement = require_toStatement();
    var _valueToNode = require_valueToNode();
    var _index5 = require_definitions();
    Object.keys(_index5).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index5[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index5[key];
        }
      });
    });
    var _appendToMemberExpression = require_appendToMemberExpression();
    var _inherits = require_inherits();
    var _prependToMemberExpression = require_prependToMemberExpression();
    var _removeProperties = require_removeProperties();
    var _removePropertiesDeep = require_removePropertiesDeep();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    var _getAssignmentIdentifiers = require_getAssignmentIdentifiers();
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
    var _getFunctionName = require_getFunctionName();
    var _traverse = require_traverse();
    Object.keys(_traverse).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _traverse[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = require_traverseFast();
    var _shallowEqual = require_shallowEqual();
    var _is = require_is();
    var _isBinding = require_isBinding();
    var _isBlockScoped = require_isBlockScoped();
    var _isImmutable = require_isImmutable();
    var _isLet = require_isLet();
    var _isNode = require_isNode();
    var _isNodesEquivalent = require_isNodesEquivalent();
    var _isPlaceholderType = require_isPlaceholderType();
    var _isReferenced = require_isReferenced();
    var _isScope = require_isScope();
    var _isSpecifierDefault = require_isSpecifierDefault();
    var _isType = require_isType();
    var _isValidES3Identifier = require_isValidES3Identifier();
    var _isValidIdentifier = require_isValidIdentifier();
    var _isVar = require_isVar();
    var _matchesPattern = require_matchesPattern();
    var _validate = require_validate();
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var _index6 = require_generated();
    Object.keys(_index6).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index6[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index6[key];
        }
      });
    });
    var _deprecationWarning = require_deprecationWarning();
    var _toSequenceExpression = require_toSequenceExpression();
    var react = exports2.react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    {
      exports2.toSequenceExpression = _toSequenceExpression.default;
    }
    if (process.env.BABEL_TYPES_8_BREAKING) {
      console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
    }
  }
});

// node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var require_virtual_types_validator = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isBindingIdentifier = isBindingIdentifier;
    exports2.isBlockScoped = isBlockScoped;
    exports2.isExpression = isExpression;
    exports2.isFlow = isFlow;
    exports2.isForAwaitStatement = isForAwaitStatement;
    exports2.isGenerated = isGenerated;
    exports2.isPure = isPure;
    exports2.isReferenced = isReferenced;
    exports2.isReferencedIdentifier = isReferencedIdentifier;
    exports2.isReferencedMemberExpression = isReferencedMemberExpression;
    exports2.isRestProperty = isRestProperty;
    exports2.isScope = isScope;
    exports2.isSpreadProperty = isSpreadProperty;
    exports2.isStatement = isStatement;
    exports2.isUser = isUser;
    exports2.isVar = isVar;
    var _t = require_lib4();
    var {
      isBinding,
      isBlockScoped: nodeIsBlockScoped,
      isExportDeclaration,
      isExpression: nodeIsExpression,
      isFlow: nodeIsFlow,
      isForStatement,
      isForXStatement,
      isIdentifier,
      isImportDeclaration,
      isImportSpecifier,
      isJSXIdentifier: isJSXIdentifier2,
      isJSXMemberExpression: isJSXMemberExpression2,
      isMemberExpression,
      isRestElement: nodeIsRestElement,
      isReferenced: nodeIsReferenced,
      isScope: nodeIsScope,
      isStatement: nodeIsStatement,
      isVar: nodeIsVar,
      isVariableDeclaration,
      react,
      isForOfStatement
    } = _t;
    var {
      isCompatTag
    } = react;
    function isReferencedIdentifier(opts) {
      const {
        node,
        parent
      } = this;
      if (!isIdentifier(node, opts) && !isJSXMemberExpression2(parent, opts)) {
        if (isJSXIdentifier2(node, opts)) {
          if (isCompatTag(node.name)) return false;
        } else {
          return false;
        }
      }
      return nodeIsReferenced(node, parent, this.parentPath.parent);
    }
    function isReferencedMemberExpression() {
      const {
        node,
        parent
      } = this;
      return isMemberExpression(node) && nodeIsReferenced(node, parent);
    }
    function isBindingIdentifier() {
      const {
        node,
        parent
      } = this;
      const grandparent = this.parentPath.parent;
      return isIdentifier(node) && isBinding(node, parent, grandparent);
    }
    function isStatement() {
      const {
        node,
        parent
      } = this;
      if (nodeIsStatement(node)) {
        if (isVariableDeclaration(node)) {
          if (isForXStatement(parent, {
            left: node
          })) return false;
          if (isForStatement(parent, {
            init: node
          })) return false;
        }
        return true;
      } else {
        return false;
      }
    }
    function isExpression() {
      if (this.isIdentifier()) {
        return this.isReferencedIdentifier();
      } else {
        return nodeIsExpression(this.node);
      }
    }
    function isScope() {
      return nodeIsScope(this.node, this.parent);
    }
    function isReferenced() {
      return nodeIsReferenced(this.node, this.parent);
    }
    function isBlockScoped() {
      return nodeIsBlockScoped(this.node);
    }
    function isVar() {
      return nodeIsVar(this.node);
    }
    function isUser() {
      return this.node && !!this.node.loc;
    }
    function isGenerated() {
      return !this.isUser();
    }
    function isPure(constantsOnly) {
      return this.scope.isPure(this.node, constantsOnly);
    }
    function isFlow() {
      const {
        node
      } = this;
      if (nodeIsFlow(node)) {
        return true;
      } else if (isImportDeclaration(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else if (isExportDeclaration(node)) {
        return node.exportKind === "type";
      } else if (isImportSpecifier(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else {
        return false;
      }
    }
    function isRestProperty() {
      var _this$parentPath;
      return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
    }
    function isSpreadProperty() {
      var _this$parentPath2;
      return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
    }
    function isForAwaitStatement() {
      return isForOfStatement(this.node, {
        await: true
      });
    }
    {
      exports2.isExistentialTypeParam = function isExistentialTypeParam() {
        throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
      };
      exports2.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
        throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
      };
    }
  }
});

// node_modules/@babel/traverse/lib/visitors.js
var require_visitors = __commonJS({
  "node_modules/@babel/traverse/lib/visitors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.environmentVisitor = environmentVisitor;
    exports2.explode = explode$1;
    exports2.isExplodedVisitor = isExplodedVisitor;
    exports2.merge = merge;
    exports2.verify = verify$1;
    var virtualTypes = require_virtual_types();
    var virtualTypesValidators = require_virtual_types_validator();
    var _t = require_lib4();
    var _context = require_context2();
    var {
      DEPRECATED_KEYS,
      DEPRECATED_ALIASES,
      FLIPPED_ALIAS_KEYS,
      TYPES,
      __internal__deprecationWarning: deprecationWarning
    } = _t;
    function isVirtualType(type) {
      return type in virtualTypes;
    }
    function isExplodedVisitor(visitor) {
      return visitor == null ? void 0 : visitor._exploded;
    }
    function explode$1(visitor) {
      if (isExplodedVisitor(visitor)) return visitor;
      visitor._exploded = true;
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        const parts = nodeType.split("|");
        if (parts.length === 1) continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const part of parts) {
          visitor[part] = fns;
        }
      }
      verify$1(visitor);
      delete visitor.__esModule;
      ensureEntranceObjects(visitor);
      ensureCallbackArrays(visitor);
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        if (!isVirtualType(nodeType)) continue;
        const fns = visitor[nodeType];
        for (const type of Object.keys(fns)) {
          fns[type] = wrapCheck(nodeType, fns[type]);
        }
        delete visitor[nodeType];
        const types = virtualTypes[nodeType];
        if (types !== null) {
          for (const type of types) {
            if (visitor[type]) {
              mergePair(visitor[type], fns);
            } else {
              visitor[type] = fns;
            }
          }
        } else {
          mergePair(visitor, fns);
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        let aliases = FLIPPED_ALIAS_KEYS[nodeType];
        if (nodeType in DEPRECATED_KEYS) {
          const deprecatedKey = DEPRECATED_KEYS[nodeType];
          deprecationWarning(nodeType, deprecatedKey, "Visitor ");
          aliases = [deprecatedKey];
        } else if (nodeType in DEPRECATED_ALIASES) {
          const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
          deprecationWarning(nodeType, deprecatedAlias, "Visitor ");
          aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
        }
        if (!aliases) continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const alias of aliases) {
          const existing = visitor[alias];
          if (existing) {
            mergePair(existing, fns);
          } else {
            visitor[alias] = Object.assign({}, fns);
          }
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        ensureCallbackArrays(visitor[nodeType]);
      }
      return visitor;
    }
    function verify$1(visitor) {
      if (visitor._verified) return;
      if (typeof visitor === "function") {
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      }
      for (const nodeType of Object.keys(visitor)) {
        if (nodeType === "enter" || nodeType === "exit") {
          validateVisitorMethods(nodeType, visitor[nodeType]);
        }
        if (shouldIgnoreKey(nodeType)) continue;
        if (!TYPES.includes(nodeType)) {
          throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${"7.26.9"}`);
        }
        const visitors = visitor[nodeType];
        if (typeof visitors === "object") {
          for (const visitorKey of Object.keys(visitors)) {
            if (visitorKey === "enter" || visitorKey === "exit") {
              validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
            } else {
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
            }
          }
        }
      }
      visitor._verified = true;
    }
    function validateVisitorMethods(path3, val) {
      const fns = [].concat(val);
      for (const fn of fns) {
        if (typeof fn !== "function") {
          throw new TypeError(`Non-function found defined in ${path3} with type ${typeof fn}`);
        }
      }
    }
    function merge(visitors, states = [], wrapper) {
      const mergedVisitor = {
        _verified: true,
        _exploded: true
      };
      {
        Object.defineProperty(mergedVisitor, "_exploded", {
          enumerable: false
        });
        Object.defineProperty(mergedVisitor, "_verified", {
          enumerable: false
        });
      }
      for (let i = 0; i < visitors.length; i++) {
        const visitor = explode$1(visitors[i]);
        const state = states[i];
        let topVisitor = visitor;
        if (state || wrapper) {
          topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
        }
        mergePair(mergedVisitor, topVisitor);
        for (const key of Object.keys(visitor)) {
          if (shouldIgnoreKey(key)) continue;
          let typeVisitor = visitor[key];
          if (state || wrapper) {
            typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
          }
          const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
          mergePair(nodeVisitor, typeVisitor);
        }
      }
      return mergedVisitor;
    }
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      const newVisitor = {};
      for (const phase of ["enter", "exit"]) {
        let fns = oldVisitor[phase];
        if (!Array.isArray(fns)) continue;
        fns = fns.map(function(fn) {
          let newFn = fn;
          if (state) {
            newFn = function(path3) {
              fn.call(state, path3, state);
            };
          }
          if (wrapper) {
            newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
          }
          if (newFn !== fn) {
            newFn.toString = () => fn.toString();
          }
          return newFn;
        });
        newVisitor[phase] = fns;
      }
      return newVisitor;
    }
    function ensureEntranceObjects(obj) {
      for (const key of Object.keys(obj)) {
        if (shouldIgnoreKey(key)) continue;
        const fns = obj[key];
        if (typeof fns === "function") {
          obj[key] = {
            enter: fns
          };
        }
      }
    }
    function ensureCallbackArrays(obj) {
      if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
      if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
    }
    function wrapCheck(nodeType, fn) {
      const fnKey = `is${nodeType}`;
      const validator = virtualTypesValidators[fnKey];
      const newFn = function(path3) {
        if (validator.call(path3)) {
          return fn.apply(this, arguments);
        }
      };
      newFn.toString = () => fn.toString();
      return newFn;
    }
    function shouldIgnoreKey(key) {
      if (key[0] === "_") return true;
      if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
      if (key === "denylist" || key === "noScope" || key === "skipKeys") {
        return true;
      }
      {
        if (key === "blacklist") {
          return true;
        }
      }
      return false;
    }
    function mergePair(dest, src) {
      for (const phase of ["enter", "exit"]) {
        if (!src[phase]) continue;
        dest[phase] = [].concat(dest[phase] || [], src[phase]);
      }
    }
    var _environmentVisitor = {
      FunctionParent(path3) {
        if (path3.isArrowFunctionExpression()) return;
        path3.skip();
        if (path3.isMethod()) {
          if (!path3.requeueComputedKeyAndDecorators) {
            _context.requeueComputedKeyAndDecorators.call(path3);
          } else {
            path3.requeueComputedKeyAndDecorators();
          }
        }
      },
      Property(path3) {
        if (path3.isObjectProperty()) return;
        path3.skip();
        if (!path3.requeueComputedKeyAndDecorators) {
          _context.requeueComputedKeyAndDecorators.call(path3);
        } else {
          path3.requeueComputedKeyAndDecorators();
        }
      }
    };
    function environmentVisitor(visitor) {
      return merge([_environmentVisitor, visitor]);
    }
  }
});

// node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS({
  "node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var t3 = require_lib4();
    var _t = t3;
    var _traverseNode = require_traverse_node();
    var _visitors = require_visitors();
    var _context = require_context2();
    var {
      getAssignmentIdentifiers
    } = _t;
    var renameVisitor = {
      ReferencedIdentifier({
        node
      }, state) {
        if (node.name === state.oldName) {
          node.name = state.newName;
        }
      },
      Scope(path3, state) {
        if (!path3.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path3.skip();
          if (path3.isMethod()) {
            if (!path3.requeueComputedKeyAndDecorators) {
              _context.requeueComputedKeyAndDecorators.call(path3);
            } else {
              path3.requeueComputedKeyAndDecorators();
            }
          }
        }
      },
      ObjectProperty({
        node,
        scope
      }, state) {
        const {
          name
        } = node.key;
        if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {
          node.shorthand = false;
          {
            var _node$extra;
            if ((_node$extra = node.extra) != null && _node$extra.shorthand) node.extra.shorthand = false;
          }
        }
      },
      "AssignmentExpression|Declaration|VariableDeclarator"(path3, state) {
        if (path3.isVariableDeclaration()) return;
        const ids = path3.isAssignmentExpression() ? getAssignmentIdentifiers(path3.node) : path3.getOuterBindingIdentifiers();
        for (const name in ids) {
          if (name === state.oldName) ids[name].name = state.newName;
        }
      }
    };
    var Renamer = class {
      constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;
        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }
        if (maybeExportDeclar.isExportDefaultDeclaration()) {
          const {
            declaration
          } = maybeExportDeclar.node;
          if (t3.isDeclaration(declaration) && !declaration.id) {
            return;
          }
        }
        if (maybeExportDeclar.isExportAllDeclaration()) {
          return;
        }
        maybeExportDeclar.splitExportDeclaration();
      }
      maybeConvertFromClassFunctionDeclaration(path3) {
        return path3;
      }
      maybeConvertFromClassFunctionExpression(path3) {
        return path3;
      }
      rename() {
        const {
          binding,
          oldName,
          newName
        } = this;
        const {
          scope,
          path: path3
        } = binding;
        const parentDeclar = path3.find((path4) => path4.isDeclaration() || path4.isFunctionExpression() || path4.isClassExpression());
        if (parentDeclar) {
          const bindingIds = parentDeclar.getOuterBindingIdentifiers();
          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }
        const blockToTraverse = arguments[0] || scope.block;
        const skipKeys = {
          discriminant: true
        };
        if (t3.isMethod(blockToTraverse)) {
          if (blockToTraverse.computed) {
            skipKeys.key = true;
          }
          if (!t3.isObjectMethod(blockToTraverse)) {
            skipKeys.decorators = true;
          }
        }
        (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys);
        if (!arguments[0]) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(path3);
          this.maybeConvertFromClassFunctionExpression(path3);
        }
      }
    };
    exports2.default = Renamer;
  }
});

// node_modules/@babel/traverse/lib/scope/binding.js
var require_binding = __commonJS({
  "node_modules/@babel/traverse/lib/scope/binding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Binding = class {
      constructor({
        identifier,
        scope,
        path: path3,
        kind
      }) {
        this.identifier = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.kind = void 0;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.identifier = identifier;
        this.scope = scope;
        this.path = path3;
        this.kind = kind;
        if ((kind === "var" || kind === "hoisted") && isDeclaredInLoop(path3)) {
          this.reassign(path3);
        }
        this.clearValue();
      }
      deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }
      setValue(value) {
        if (this.hasDeoptedValue) return;
        this.hasValue = true;
        this.value = value;
      }
      clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }
      reassign(path3) {
        this.constant = false;
        if (this.constantViolations.includes(path3)) {
          return;
        }
        this.constantViolations.push(path3);
      }
      reference(path3) {
        if (this.referencePaths.includes(path3)) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path3);
      }
      dereference() {
        this.references--;
        this.referenced = !!this.references;
      }
    };
    exports2.default = Binding;
    function isDeclaredInLoop(path3) {
      for (let {
        parentPath,
        key
      } = path3; parentPath; {
        parentPath,
        key
      } = parentPath) {
        if (parentPath.isFunctionParent()) return false;
        if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && key === "body") {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/globals/globals.json
var require_globals = __commonJS({
  "node_modules/globals/globals.json"(exports2, module2) {
    module2.exports = {
      builtin: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        BigInt: false,
        BigInt64Array: false,
        BigUint64Array: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        globalThis: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es5: {
        Array: false,
        Boolean: false,
        constructor: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        propertyIsEnumerable: false,
        RangeError: false,
        ReferenceError: false,
        RegExp: false,
        String: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false
      },
      es2015: {
        Array: false,
        ArrayBuffer: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es2017: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      browser: {
        AbortController: false,
        AbortSignal: false,
        addEventListener: false,
        alert: false,
        AnalyserNode: false,
        Animation: false,
        AnimationEffectReadOnly: false,
        AnimationEffectTiming: false,
        AnimationEffectTimingReadOnly: false,
        AnimationEvent: false,
        AnimationPlaybackEvent: false,
        AnimationTimeline: false,
        applicationCache: false,
        ApplicationCache: false,
        ApplicationCacheErrorEvent: false,
        atob: false,
        Attr: false,
        Audio: false,
        AudioBuffer: false,
        AudioBufferSourceNode: false,
        AudioContext: false,
        AudioDestinationNode: false,
        AudioListener: false,
        AudioNode: false,
        AudioParam: false,
        AudioProcessingEvent: false,
        AudioScheduledSourceNode: false,
        "AudioWorkletGlobalScope ": false,
        AudioWorkletNode: false,
        AudioWorkletProcessor: false,
        BarProp: false,
        BaseAudioContext: false,
        BatteryManager: false,
        BeforeUnloadEvent: false,
        BiquadFilterNode: false,
        Blob: false,
        BlobEvent: false,
        blur: false,
        BroadcastChannel: false,
        btoa: false,
        BudgetService: false,
        ByteLengthQueuingStrategy: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        cancelAnimationFrame: false,
        cancelIdleCallback: false,
        CanvasCaptureMediaStreamTrack: false,
        CanvasGradient: false,
        CanvasPattern: false,
        CanvasRenderingContext2D: false,
        ChannelMergerNode: false,
        ChannelSplitterNode: false,
        CharacterData: false,
        clearInterval: false,
        clearTimeout: false,
        clientInformation: false,
        ClipboardEvent: false,
        close: false,
        closed: false,
        CloseEvent: false,
        Comment: false,
        CompositionEvent: false,
        confirm: false,
        console: false,
        ConstantSourceNode: false,
        ConvolverNode: false,
        CountQueuingStrategy: false,
        createImageBitmap: false,
        Credential: false,
        CredentialsContainer: false,
        crypto: false,
        Crypto: false,
        CryptoKey: false,
        CSS: false,
        CSSConditionRule: false,
        CSSFontFaceRule: false,
        CSSGroupingRule: false,
        CSSImportRule: false,
        CSSKeyframeRule: false,
        CSSKeyframesRule: false,
        CSSMediaRule: false,
        CSSNamespaceRule: false,
        CSSPageRule: false,
        CSSRule: false,
        CSSRuleList: false,
        CSSStyleDeclaration: false,
        CSSStyleRule: false,
        CSSStyleSheet: false,
        CSSSupportsRule: false,
        CustomElementRegistry: false,
        customElements: false,
        CustomEvent: false,
        DataTransfer: false,
        DataTransferItem: false,
        DataTransferItemList: false,
        defaultstatus: false,
        defaultStatus: false,
        DelayNode: false,
        DeviceMotionEvent: false,
        DeviceOrientationEvent: false,
        devicePixelRatio: false,
        dispatchEvent: false,
        document: false,
        Document: false,
        DocumentFragment: false,
        DocumentType: false,
        DOMError: false,
        DOMException: false,
        DOMImplementation: false,
        DOMMatrix: false,
        DOMMatrixReadOnly: false,
        DOMParser: false,
        DOMPoint: false,
        DOMPointReadOnly: false,
        DOMQuad: false,
        DOMRect: false,
        DOMRectReadOnly: false,
        DOMStringList: false,
        DOMStringMap: false,
        DOMTokenList: false,
        DragEvent: false,
        DynamicsCompressorNode: false,
        Element: false,
        ErrorEvent: false,
        event: false,
        Event: false,
        EventSource: false,
        EventTarget: false,
        external: false,
        fetch: false,
        File: false,
        FileList: false,
        FileReader: false,
        find: false,
        focus: false,
        FocusEvent: false,
        FontFace: false,
        FontFaceSetLoadEvent: false,
        FormData: false,
        frameElement: false,
        frames: false,
        GainNode: false,
        Gamepad: false,
        GamepadButton: false,
        GamepadEvent: false,
        getComputedStyle: false,
        getSelection: false,
        HashChangeEvent: false,
        Headers: false,
        history: false,
        History: false,
        HTMLAllCollection: false,
        HTMLAnchorElement: false,
        HTMLAreaElement: false,
        HTMLAudioElement: false,
        HTMLBaseElement: false,
        HTMLBodyElement: false,
        HTMLBRElement: false,
        HTMLButtonElement: false,
        HTMLCanvasElement: false,
        HTMLCollection: false,
        HTMLContentElement: false,
        HTMLDataElement: false,
        HTMLDataListElement: false,
        HTMLDetailsElement: false,
        HTMLDialogElement: false,
        HTMLDirectoryElement: false,
        HTMLDivElement: false,
        HTMLDListElement: false,
        HTMLDocument: false,
        HTMLElement: false,
        HTMLEmbedElement: false,
        HTMLFieldSetElement: false,
        HTMLFontElement: false,
        HTMLFormControlsCollection: false,
        HTMLFormElement: false,
        HTMLFrameElement: false,
        HTMLFrameSetElement: false,
        HTMLHeadElement: false,
        HTMLHeadingElement: false,
        HTMLHRElement: false,
        HTMLHtmlElement: false,
        HTMLIFrameElement: false,
        HTMLImageElement: false,
        HTMLInputElement: false,
        HTMLLabelElement: false,
        HTMLLegendElement: false,
        HTMLLIElement: false,
        HTMLLinkElement: false,
        HTMLMapElement: false,
        HTMLMarqueeElement: false,
        HTMLMediaElement: false,
        HTMLMenuElement: false,
        HTMLMetaElement: false,
        HTMLMeterElement: false,
        HTMLModElement: false,
        HTMLObjectElement: false,
        HTMLOListElement: false,
        HTMLOptGroupElement: false,
        HTMLOptionElement: false,
        HTMLOptionsCollection: false,
        HTMLOutputElement: false,
        HTMLParagraphElement: false,
        HTMLParamElement: false,
        HTMLPictureElement: false,
        HTMLPreElement: false,
        HTMLProgressElement: false,
        HTMLQuoteElement: false,
        HTMLScriptElement: false,
        HTMLSelectElement: false,
        HTMLShadowElement: false,
        HTMLSlotElement: false,
        HTMLSourceElement: false,
        HTMLSpanElement: false,
        HTMLStyleElement: false,
        HTMLTableCaptionElement: false,
        HTMLTableCellElement: false,
        HTMLTableColElement: false,
        HTMLTableElement: false,
        HTMLTableRowElement: false,
        HTMLTableSectionElement: false,
        HTMLTemplateElement: false,
        HTMLTextAreaElement: false,
        HTMLTimeElement: false,
        HTMLTitleElement: false,
        HTMLTrackElement: false,
        HTMLUListElement: false,
        HTMLUnknownElement: false,
        HTMLVideoElement: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        IdleDeadline: false,
        IIRFilterNode: false,
        Image: false,
        ImageBitmap: false,
        ImageBitmapRenderingContext: false,
        ImageCapture: false,
        ImageData: false,
        indexedDB: false,
        innerHeight: false,
        innerWidth: false,
        InputEvent: false,
        IntersectionObserver: false,
        IntersectionObserverEntry: false,
        Intl: false,
        isSecureContext: false,
        KeyboardEvent: false,
        KeyframeEffect: false,
        KeyframeEffectReadOnly: false,
        length: false,
        localStorage: false,
        location: true,
        Location: false,
        locationbar: false,
        matchMedia: false,
        MediaDeviceInfo: false,
        MediaDevices: false,
        MediaElementAudioSourceNode: false,
        MediaEncryptedEvent: false,
        MediaError: false,
        MediaKeyMessageEvent: false,
        MediaKeySession: false,
        MediaKeyStatusMap: false,
        MediaKeySystemAccess: false,
        MediaList: false,
        MediaQueryList: false,
        MediaQueryListEvent: false,
        MediaRecorder: false,
        MediaSettingsRange: false,
        MediaSource: false,
        MediaStream: false,
        MediaStreamAudioDestinationNode: false,
        MediaStreamAudioSourceNode: false,
        MediaStreamEvent: false,
        MediaStreamTrack: false,
        MediaStreamTrackEvent: false,
        menubar: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        MIDIAccess: false,
        MIDIConnectionEvent: false,
        MIDIInput: false,
        MIDIInputMap: false,
        MIDIMessageEvent: false,
        MIDIOutput: false,
        MIDIOutputMap: false,
        MIDIPort: false,
        MimeType: false,
        MimeTypeArray: false,
        MouseEvent: false,
        moveBy: false,
        moveTo: false,
        MutationEvent: false,
        MutationObserver: false,
        MutationRecord: false,
        name: false,
        NamedNodeMap: false,
        NavigationPreloadManager: false,
        navigator: false,
        Navigator: false,
        NetworkInformation: false,
        Node: false,
        NodeFilter: false,
        NodeIterator: false,
        NodeList: false,
        Notification: false,
        OfflineAudioCompletionEvent: false,
        OfflineAudioContext: false,
        offscreenBuffering: false,
        OffscreenCanvas: true,
        onabort: true,
        onafterprint: true,
        onanimationend: true,
        onanimationiteration: true,
        onanimationstart: true,
        onappinstalled: true,
        onauxclick: true,
        onbeforeinstallprompt: true,
        onbeforeprint: true,
        onbeforeunload: true,
        onblur: true,
        oncancel: true,
        oncanplay: true,
        oncanplaythrough: true,
        onchange: true,
        onclick: true,
        onclose: true,
        oncontextmenu: true,
        oncuechange: true,
        ondblclick: true,
        ondevicemotion: true,
        ondeviceorientation: true,
        ondeviceorientationabsolute: true,
        ondrag: true,
        ondragend: true,
        ondragenter: true,
        ondragleave: true,
        ondragover: true,
        ondragstart: true,
        ondrop: true,
        ondurationchange: true,
        onemptied: true,
        onended: true,
        onerror: true,
        onfocus: true,
        ongotpointercapture: true,
        onhashchange: true,
        oninput: true,
        oninvalid: true,
        onkeydown: true,
        onkeypress: true,
        onkeyup: true,
        onlanguagechange: true,
        onload: true,
        onloadeddata: true,
        onloadedmetadata: true,
        onloadstart: true,
        onlostpointercapture: true,
        onmessage: true,
        onmessageerror: true,
        onmousedown: true,
        onmouseenter: true,
        onmouseleave: true,
        onmousemove: true,
        onmouseout: true,
        onmouseover: true,
        onmouseup: true,
        onmousewheel: true,
        onoffline: true,
        ononline: true,
        onpagehide: true,
        onpageshow: true,
        onpause: true,
        onplay: true,
        onplaying: true,
        onpointercancel: true,
        onpointerdown: true,
        onpointerenter: true,
        onpointerleave: true,
        onpointermove: true,
        onpointerout: true,
        onpointerover: true,
        onpointerup: true,
        onpopstate: true,
        onprogress: true,
        onratechange: true,
        onrejectionhandled: true,
        onreset: true,
        onresize: true,
        onscroll: true,
        onsearch: true,
        onseeked: true,
        onseeking: true,
        onselect: true,
        onstalled: true,
        onstorage: true,
        onsubmit: true,
        onsuspend: true,
        ontimeupdate: true,
        ontoggle: true,
        ontransitionend: true,
        onunhandledrejection: true,
        onunload: true,
        onvolumechange: true,
        onwaiting: true,
        onwheel: true,
        open: false,
        openDatabase: false,
        opener: false,
        Option: false,
        origin: false,
        OscillatorNode: false,
        outerHeight: false,
        outerWidth: false,
        PageTransitionEvent: false,
        pageXOffset: false,
        pageYOffset: false,
        PannerNode: false,
        parent: false,
        Path2D: false,
        PaymentAddress: false,
        PaymentRequest: false,
        PaymentRequestUpdateEvent: false,
        PaymentResponse: false,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceLongTaskTiming: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceNavigationTiming: false,
        PerformanceObserver: false,
        PerformanceObserverEntryList: false,
        PerformancePaintTiming: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        PeriodicWave: false,
        Permissions: false,
        PermissionStatus: false,
        personalbar: false,
        PhotoCapabilities: false,
        Plugin: false,
        PluginArray: false,
        PointerEvent: false,
        PopStateEvent: false,
        postMessage: false,
        Presentation: false,
        PresentationAvailability: false,
        PresentationConnection: false,
        PresentationConnectionAvailableEvent: false,
        PresentationConnectionCloseEvent: false,
        PresentationConnectionList: false,
        PresentationReceiver: false,
        PresentationRequest: false,
        print: false,
        ProcessingInstruction: false,
        ProgressEvent: false,
        PromiseRejectionEvent: false,
        prompt: false,
        PushManager: false,
        PushSubscription: false,
        PushSubscriptionOptions: false,
        queueMicrotask: false,
        RadioNodeList: false,
        Range: false,
        ReadableStream: false,
        registerProcessor: false,
        RemotePlayback: false,
        removeEventListener: false,
        Request: false,
        requestAnimationFrame: false,
        requestIdleCallback: false,
        resizeBy: false,
        ResizeObserver: false,
        ResizeObserverEntry: false,
        resizeTo: false,
        Response: false,
        RTCCertificate: false,
        RTCDataChannel: false,
        RTCDataChannelEvent: false,
        RTCDtlsTransport: false,
        RTCIceCandidate: false,
        RTCIceGatherer: false,
        RTCIceTransport: false,
        RTCPeerConnection: false,
        RTCPeerConnectionIceEvent: false,
        RTCRtpContributingSource: false,
        RTCRtpReceiver: false,
        RTCRtpSender: false,
        RTCSctpTransport: false,
        RTCSessionDescription: false,
        RTCStatsReport: false,
        RTCTrackEvent: false,
        screen: false,
        Screen: false,
        screenLeft: false,
        ScreenOrientation: false,
        screenTop: false,
        screenX: false,
        screenY: false,
        ScriptProcessorNode: false,
        scroll: false,
        scrollbars: false,
        scrollBy: false,
        scrollTo: false,
        scrollX: false,
        scrollY: false,
        SecurityPolicyViolationEvent: false,
        Selection: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerRegistration: false,
        sessionStorage: false,
        setInterval: false,
        setTimeout: false,
        ShadowRoot: false,
        SharedWorker: false,
        SourceBuffer: false,
        SourceBufferList: false,
        speechSynthesis: false,
        SpeechSynthesisEvent: false,
        SpeechSynthesisUtterance: false,
        StaticRange: false,
        status: false,
        statusbar: false,
        StereoPannerNode: false,
        stop: false,
        Storage: false,
        StorageEvent: false,
        StorageManager: false,
        styleMedia: false,
        StyleSheet: false,
        StyleSheetList: false,
        SubtleCrypto: false,
        SVGAElement: false,
        SVGAngle: false,
        SVGAnimatedAngle: false,
        SVGAnimatedBoolean: false,
        SVGAnimatedEnumeration: false,
        SVGAnimatedInteger: false,
        SVGAnimatedLength: false,
        SVGAnimatedLengthList: false,
        SVGAnimatedNumber: false,
        SVGAnimatedNumberList: false,
        SVGAnimatedPreserveAspectRatio: false,
        SVGAnimatedRect: false,
        SVGAnimatedString: false,
        SVGAnimatedTransformList: false,
        SVGAnimateElement: false,
        SVGAnimateMotionElement: false,
        SVGAnimateTransformElement: false,
        SVGAnimationElement: false,
        SVGCircleElement: false,
        SVGClipPathElement: false,
        SVGComponentTransferFunctionElement: false,
        SVGDefsElement: false,
        SVGDescElement: false,
        SVGDiscardElement: false,
        SVGElement: false,
        SVGEllipseElement: false,
        SVGFEBlendElement: false,
        SVGFEColorMatrixElement: false,
        SVGFEComponentTransferElement: false,
        SVGFECompositeElement: false,
        SVGFEConvolveMatrixElement: false,
        SVGFEDiffuseLightingElement: false,
        SVGFEDisplacementMapElement: false,
        SVGFEDistantLightElement: false,
        SVGFEDropShadowElement: false,
        SVGFEFloodElement: false,
        SVGFEFuncAElement: false,
        SVGFEFuncBElement: false,
        SVGFEFuncGElement: false,
        SVGFEFuncRElement: false,
        SVGFEGaussianBlurElement: false,
        SVGFEImageElement: false,
        SVGFEMergeElement: false,
        SVGFEMergeNodeElement: false,
        SVGFEMorphologyElement: false,
        SVGFEOffsetElement: false,
        SVGFEPointLightElement: false,
        SVGFESpecularLightingElement: false,
        SVGFESpotLightElement: false,
        SVGFETileElement: false,
        SVGFETurbulenceElement: false,
        SVGFilterElement: false,
        SVGForeignObjectElement: false,
        SVGGElement: false,
        SVGGeometryElement: false,
        SVGGradientElement: false,
        SVGGraphicsElement: false,
        SVGImageElement: false,
        SVGLength: false,
        SVGLengthList: false,
        SVGLinearGradientElement: false,
        SVGLineElement: false,
        SVGMarkerElement: false,
        SVGMaskElement: false,
        SVGMatrix: false,
        SVGMetadataElement: false,
        SVGMPathElement: false,
        SVGNumber: false,
        SVGNumberList: false,
        SVGPathElement: false,
        SVGPatternElement: false,
        SVGPoint: false,
        SVGPointList: false,
        SVGPolygonElement: false,
        SVGPolylineElement: false,
        SVGPreserveAspectRatio: false,
        SVGRadialGradientElement: false,
        SVGRect: false,
        SVGRectElement: false,
        SVGScriptElement: false,
        SVGSetElement: false,
        SVGStopElement: false,
        SVGStringList: false,
        SVGStyleElement: false,
        SVGSVGElement: false,
        SVGSwitchElement: false,
        SVGSymbolElement: false,
        SVGTextContentElement: false,
        SVGTextElement: false,
        SVGTextPathElement: false,
        SVGTextPositioningElement: false,
        SVGTitleElement: false,
        SVGTransform: false,
        SVGTransformList: false,
        SVGTSpanElement: false,
        SVGUnitTypes: false,
        SVGUseElement: false,
        SVGViewElement: false,
        TaskAttributionTiming: false,
        Text: false,
        TextDecoder: false,
        TextEncoder: false,
        TextEvent: false,
        TextMetrics: false,
        TextTrack: false,
        TextTrackCue: false,
        TextTrackCueList: false,
        TextTrackList: false,
        TimeRanges: false,
        toolbar: false,
        top: false,
        Touch: false,
        TouchEvent: false,
        TouchList: false,
        TrackEvent: false,
        TransitionEvent: false,
        TreeWalker: false,
        UIEvent: false,
        URL: false,
        URLSearchParams: false,
        ValidityState: false,
        visualViewport: false,
        VisualViewport: false,
        VTTCue: false,
        WaveShaperNode: false,
        WebAssembly: false,
        WebGL2RenderingContext: false,
        WebGLActiveInfo: false,
        WebGLBuffer: false,
        WebGLContextEvent: false,
        WebGLFramebuffer: false,
        WebGLProgram: false,
        WebGLQuery: false,
        WebGLRenderbuffer: false,
        WebGLRenderingContext: false,
        WebGLSampler: false,
        WebGLShader: false,
        WebGLShaderPrecisionFormat: false,
        WebGLSync: false,
        WebGLTexture: false,
        WebGLTransformFeedback: false,
        WebGLUniformLocation: false,
        WebGLVertexArrayObject: false,
        WebSocket: false,
        WheelEvent: false,
        window: false,
        Window: false,
        Worker: false,
        WritableStream: false,
        XMLDocument: false,
        XMLHttpRequest: false,
        XMLHttpRequestEventTarget: false,
        XMLHttpRequestUpload: false,
        XMLSerializer: false,
        XPathEvaluator: false,
        XPathExpression: false,
        XPathResult: false,
        XSLTProcessor: false
      },
      worker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        clearInterval: false,
        clearTimeout: false,
        close: true,
        console: false,
        fetch: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: true,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onlanguagechange: true,
        onmessage: true,
        onoffline: true,
        ononline: true,
        onrejectionhandled: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: true,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      node: {
        __dirname: false,
        __filename: false,
        Buffer: false,
        clearImmediate: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        exports: true,
        global: false,
        Intl: false,
        module: false,
        process: false,
        queueMicrotask: false,
        require: false,
        setImmediate: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false
      },
      commonjs: {
        exports: true,
        global: false,
        module: false,
        require: false
      },
      amd: {
        define: false,
        require: false
      },
      mocha: {
        after: false,
        afterEach: false,
        before: false,
        beforeEach: false,
        context: false,
        describe: false,
        it: false,
        mocha: false,
        run: false,
        setup: false,
        specify: false,
        suite: false,
        suiteSetup: false,
        suiteTeardown: false,
        teardown: false,
        test: false,
        xcontext: false,
        xdescribe: false,
        xit: false,
        xspecify: false
      },
      jasmine: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fail: false,
        fdescribe: false,
        fit: false,
        it: false,
        jasmine: false,
        pending: false,
        runs: false,
        spyOn: false,
        spyOnProperty: false,
        waits: false,
        waitsFor: false,
        xdescribe: false,
        xit: false
      },
      jest: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fdescribe: false,
        fit: false,
        it: false,
        jest: false,
        pit: false,
        require: false,
        test: false,
        xdescribe: false,
        xit: false,
        xtest: false
      },
      qunit: {
        asyncTest: false,
        deepEqual: false,
        equal: false,
        expect: false,
        module: false,
        notDeepEqual: false,
        notEqual: false,
        notOk: false,
        notPropEqual: false,
        notStrictEqual: false,
        ok: false,
        propEqual: false,
        QUnit: false,
        raises: false,
        start: false,
        stop: false,
        strictEqual: false,
        test: false,
        throws: false
      },
      phantomjs: {
        console: true,
        exports: true,
        phantom: true,
        require: true,
        WebPage: true
      },
      couch: {
        emit: false,
        exports: false,
        getRow: false,
        log: false,
        module: false,
        provides: false,
        require: false,
        respond: false,
        send: false,
        start: false,
        sum: false
      },
      rhino: {
        defineClass: false,
        deserialize: false,
        gc: false,
        help: false,
        importClass: false,
        importPackage: false,
        java: false,
        load: false,
        loadClass: false,
        Packages: false,
        print: false,
        quit: false,
        readFile: false,
        readUrl: false,
        runCommand: false,
        seal: false,
        serialize: false,
        spawn: false,
        sync: false,
        toint32: false,
        version: false
      },
      nashorn: {
        __DIR__: false,
        __FILE__: false,
        __LINE__: false,
        com: false,
        edu: false,
        exit: false,
        java: false,
        Java: false,
        javafx: false,
        JavaImporter: false,
        javax: false,
        JSAdapter: false,
        load: false,
        loadWithNewGlobal: false,
        org: false,
        Packages: false,
        print: false,
        quit: false
      },
      wsh: {
        ActiveXObject: true,
        Enumerator: true,
        GetObject: true,
        ScriptEngine: true,
        ScriptEngineBuildVersion: true,
        ScriptEngineMajorVersion: true,
        ScriptEngineMinorVersion: true,
        VBArray: true,
        WScript: true,
        WSH: true,
        XDomainRequest: true
      },
      jquery: {
        $: false,
        jQuery: false
      },
      yui: {
        YAHOO: false,
        YAHOO_config: false,
        YUI: false,
        YUI_config: false
      },
      shelljs: {
        cat: false,
        cd: false,
        chmod: false,
        config: false,
        cp: false,
        dirs: false,
        echo: false,
        env: false,
        error: false,
        exec: false,
        exit: false,
        find: false,
        grep: false,
        ln: false,
        ls: false,
        mkdir: false,
        mv: false,
        popd: false,
        pushd: false,
        pwd: false,
        rm: false,
        sed: false,
        set: false,
        target: false,
        tempdir: false,
        test: false,
        touch: false,
        which: false
      },
      prototypejs: {
        $: false,
        $$: false,
        $A: false,
        $break: false,
        $continue: false,
        $F: false,
        $H: false,
        $R: false,
        $w: false,
        Abstract: false,
        Ajax: false,
        Autocompleter: false,
        Builder: false,
        Class: false,
        Control: false,
        Draggable: false,
        Draggables: false,
        Droppables: false,
        Effect: false,
        Element: false,
        Enumerable: false,
        Event: false,
        Field: false,
        Form: false,
        Hash: false,
        Insertion: false,
        ObjectRange: false,
        PeriodicalExecuter: false,
        Position: false,
        Prototype: false,
        Scriptaculous: false,
        Selector: false,
        Sortable: false,
        SortableObserver: false,
        Sound: false,
        Template: false,
        Toggle: false,
        Try: false
      },
      meteor: {
        _: false,
        $: false,
        Accounts: false,
        AccountsClient: false,
        AccountsCommon: false,
        AccountsServer: false,
        App: false,
        Assets: false,
        Blaze: false,
        check: false,
        Cordova: false,
        DDP: false,
        DDPRateLimiter: false,
        DDPServer: false,
        Deps: false,
        EJSON: false,
        Email: false,
        HTTP: false,
        Log: false,
        Match: false,
        Meteor: false,
        Mongo: false,
        MongoInternals: false,
        Npm: false,
        Package: false,
        Plugin: false,
        process: false,
        Random: false,
        ReactiveDict: false,
        ReactiveVar: false,
        Router: false,
        ServiceConfiguration: false,
        Session: false,
        share: false,
        Spacebars: false,
        Template: false,
        Tinytest: false,
        Tracker: false,
        UI: false,
        Utils: false,
        WebApp: false,
        WebAppInternals: false
      },
      mongo: {
        _isWindows: false,
        _rand: false,
        BulkWriteResult: false,
        cat: false,
        cd: false,
        connect: false,
        db: false,
        getHostName: false,
        getMemInfo: false,
        hostname: false,
        ISODate: false,
        listFiles: false,
        load: false,
        ls: false,
        md5sumFile: false,
        mkdir: false,
        Mongo: false,
        NumberInt: false,
        NumberLong: false,
        ObjectId: false,
        PlanCache: false,
        print: false,
        printjson: false,
        pwd: false,
        quit: false,
        removeFile: false,
        rs: false,
        sh: false,
        UUID: false,
        version: false,
        WriteResult: false
      },
      applescript: {
        $: false,
        Application: false,
        Automation: false,
        console: false,
        delay: false,
        Library: false,
        ObjC: false,
        ObjectSpecifier: false,
        Path: false,
        Progress: false,
        Ref: false
      },
      serviceworker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        clearInterval: false,
        clearTimeout: false,
        Client: false,
        clients: false,
        Clients: false,
        close: true,
        console: false,
        ExtendableEvent: false,
        ExtendableMessageEvent: false,
        fetch: false,
        FetchEvent: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: false,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onfetch: true,
        oninstall: true,
        onlanguagechange: true,
        onmessage: true,
        onmessageerror: true,
        onnotificationclick: true,
        onnotificationclose: true,
        onoffline: true,
        ononline: true,
        onpush: true,
        onpushsubscriptionchange: true,
        onrejectionhandled: true,
        onsync: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        registration: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerGlobalScope: false,
        ServiceWorkerMessageEvent: false,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        skipWaiting: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        WindowClient: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      atomtest: {
        advanceClock: false,
        fakeClearInterval: false,
        fakeClearTimeout: false,
        fakeSetInterval: false,
        fakeSetTimeout: false,
        resetTimeouts: false,
        waitsForPromise: false
      },
      embertest: {
        andThen: false,
        click: false,
        currentPath: false,
        currentRouteName: false,
        currentURL: false,
        fillIn: false,
        find: false,
        findAll: false,
        findWithAssert: false,
        keyEvent: false,
        pauseTest: false,
        resumeTest: false,
        triggerEvent: false,
        visit: false,
        wait: false
      },
      protractor: {
        $: false,
        $$: false,
        browser: false,
        by: false,
        By: false,
        DartObject: false,
        element: false,
        protractor: false
      },
      "shared-node-browser": {
        clearInterval: false,
        clearTimeout: false,
        console: false,
        setInterval: false,
        setTimeout: false,
        URL: false,
        URLSearchParams: false
      },
      webextensions: {
        browser: false,
        chrome: false,
        opr: false
      },
      greasemonkey: {
        cloneInto: false,
        createObjectIn: false,
        exportFunction: false,
        GM: false,
        GM_addStyle: false,
        GM_deleteValue: false,
        GM_getResourceText: false,
        GM_getResourceURL: false,
        GM_getValue: false,
        GM_info: false,
        GM_listValues: false,
        GM_log: false,
        GM_openInTab: false,
        GM_registerMenuCommand: false,
        GM_setClipboard: false,
        GM_setValue: false,
        GM_xmlhttpRequest: false,
        unsafeWindow: false
      },
      devtools: {
        $: false,
        $_: false,
        $$: false,
        $0: false,
        $1: false,
        $2: false,
        $3: false,
        $4: false,
        $x: false,
        chrome: false,
        clear: false,
        copy: false,
        debug: false,
        dir: false,
        dirxml: false,
        getEventListeners: false,
        inspect: false,
        keys: false,
        monitor: false,
        monitorEvents: false,
        profile: false,
        profileEnd: false,
        queryObjects: false,
        table: false,
        undebug: false,
        unmonitor: false,
        unmonitorEvents: false,
        values: false
      }
    };
  }
});

// node_modules/globals/index.js
var require_globals2 = __commonJS({
  "node_modules/globals/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_globals();
  }
});

// node_modules/@babel/traverse/lib/cache.js
var require_cache = __commonJS({
  "node_modules/@babel/traverse/lib/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.clear = clear;
    exports2.clearPath = clearPath;
    exports2.clearScope = clearScope;
    exports2.getCachedPaths = getCachedPaths;
    exports2.getOrCreateCachedPaths = getOrCreateCachedPaths;
    exports2.scope = exports2.path = void 0;
    var pathsCache = exports2.path = /* @__PURE__ */ new WeakMap();
    var scope = exports2.scope = /* @__PURE__ */ new WeakMap();
    function clear() {
      clearPath();
      clearScope();
    }
    function clearPath() {
      exports2.path = pathsCache = /* @__PURE__ */ new WeakMap();
    }
    function clearScope() {
      exports2.scope = scope = /* @__PURE__ */ new WeakMap();
    }
    var nullHub = Object.freeze({});
    function getCachedPaths(hub, parent) {
      var _pathsCache$get, _hub;
      {
        hub = null;
      }
      return (_pathsCache$get = pathsCache.get((_hub = hub) != null ? _hub : nullHub)) == null ? void 0 : _pathsCache$get.get(parent);
    }
    function getOrCreateCachedPaths(hub, parent) {
      var _hub2, _hub3;
      {
        hub = null;
      }
      let parents = pathsCache.get((_hub2 = hub) != null ? _hub2 : nullHub);
      if (!parents) pathsCache.set((_hub3 = hub) != null ? _hub3 : nullHub, parents = /* @__PURE__ */ new WeakMap());
      let paths = parents.get(parent);
      if (!paths) parents.set(parent, paths = /* @__PURE__ */ new Map());
      return paths;
    }
  }
});

// node_modules/@babel/traverse/lib/scope/index.js
var require_scope = __commonJS({
  "node_modules/@babel/traverse/lib/scope/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _renamer = require_renamer();
    var _index = require_lib8();
    var _binding = require_binding();
    var _globals = require_globals2();
    var _t = require_lib4();
    var t3 = _t;
    var _cache = require_cache();
    var _visitors = require_visitors();
    var {
      NOT_LOCAL_BINDING,
      assignmentExpression,
      callExpression,
      cloneNode,
      getBindingIdentifiers,
      identifier,
      isArrayExpression,
      isBinary,
      isCallExpression,
      isClass,
      isClassBody,
      isClassDeclaration,
      isExportAllDeclaration,
      isExportDefaultDeclaration,
      isExportNamedDeclaration,
      isFunctionDeclaration,
      isIdentifier,
      isImportDeclaration,
      isLiteral,
      isMemberExpression,
      isMethod,
      isModuleSpecifier,
      isNullLiteral,
      isObjectExpression,
      isProperty,
      isPureish,
      isRegExpLiteral,
      isSuper,
      isTaggedTemplateExpression,
      isTemplateLiteral,
      isThisExpression,
      isUnaryExpression,
      isVariableDeclaration,
      expressionStatement,
      matchesPattern,
      memberExpression,
      numericLiteral,
      toIdentifier,
      variableDeclaration,
      variableDeclarator,
      isRecordExpression,
      isTupleExpression,
      isObjectProperty,
      isTopicReference,
      isMetaProperty,
      isPrivateName,
      isExportDeclaration,
      buildUndefinedNode,
      sequenceExpression
    } = _t;
    function gatherNodeParts(node, parts) {
      switch (node == null ? void 0 : node.type) {
        default:
          if (isImportDeclaration(node) || isExportDeclaration(node)) {
            var _node$specifiers;
            if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
              gatherNodeParts(node.source, parts);
            } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
              for (const e of node.specifiers) gatherNodeParts(e, parts);
            } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
              gatherNodeParts(node.declaration, parts);
            }
          } else if (isModuleSpecifier(node)) {
            gatherNodeParts(node.local, parts);
          } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
            parts.push(node.value);
          }
          break;
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node.object, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "Identifier":
        case "JSXIdentifier":
          parts.push(node.name);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node.callee, parts);
          break;
        case "ObjectExpression":
        case "ObjectPattern":
          for (const e of node.properties) {
            gatherNodeParts(e, parts);
          }
          break;
        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node.argument, parts);
          break;
        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node.key, parts);
          break;
        case "ThisExpression":
          parts.push("this");
          break;
        case "Super":
          parts.push("super");
          break;
        case "Import":
          parts.push("import");
          break;
        case "DoExpression":
          parts.push("do");
          break;
        case "YieldExpression":
          parts.push("yield");
          gatherNodeParts(node.argument, parts);
          break;
        case "AwaitExpression":
          parts.push("await");
          gatherNodeParts(node.argument, parts);
          break;
        case "AssignmentExpression":
          gatherNodeParts(node.left, parts);
          break;
        case "VariableDeclarator":
          gatherNodeParts(node.id, parts);
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node.id, parts);
          break;
        case "PrivateName":
          gatherNodeParts(node.id, parts);
          break;
        case "ParenthesizedExpression":
          gatherNodeParts(node.expression, parts);
          break;
        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node.argument, parts);
          break;
        case "MetaProperty":
          gatherNodeParts(node.meta, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "JSXElement":
          gatherNodeParts(node.openingElement, parts);
          break;
        case "JSXOpeningElement":
          gatherNodeParts(node.name, parts);
          break;
        case "JSXFragment":
          gatherNodeParts(node.openingFragment, parts);
          break;
        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;
        case "JSXNamespacedName":
          gatherNodeParts(node.namespace, parts);
          gatherNodeParts(node.name, parts);
          break;
      }
    }
    var collectorVisitor = {
      ForStatement(path3) {
        const declar = path3.get("init");
        if (declar.isVar()) {
          const {
            scope
          } = path3;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      },
      Declaration(path3) {
        if (path3.isBlockScoped()) return;
        if (path3.isImportDeclaration()) return;
        if (path3.isExportDeclaration()) return;
        const parent = path3.scope.getFunctionParent() || path3.scope.getProgramParent();
        parent.registerDeclaration(path3);
      },
      ImportDeclaration(path3) {
        const parent = path3.scope.getBlockParent();
        parent.registerDeclaration(path3);
      },
      TSImportEqualsDeclaration(path3) {
        const parent = path3.scope.getBlockParent();
        parent.registerDeclaration(path3);
      },
      ReferencedIdentifier(path3, state) {
        if (t3.isTSQualifiedName(path3.parent) && path3.parent.right === path3.node) {
          return;
        }
        if (path3.parentPath.isTSImportEqualsDeclaration()) return;
        state.references.push(path3);
      },
      ForXStatement(path3, state) {
        const left = path3.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path3);
        } else if (left.isVar()) {
          const {
            scope
          } = path3;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", left);
        }
      },
      ExportDeclaration: {
        exit(path3) {
          const {
            node,
            scope
          } = path3;
          if (isExportAllDeclaration(node)) return;
          const declar = node.declaration;
          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            const id = declar.id;
            if (!id) return;
            const binding = scope.getBinding(id.name);
            binding == null || binding.reference(path3);
          } else if (isVariableDeclaration(declar)) {
            for (const decl of declar.declarations) {
              for (const name of Object.keys(getBindingIdentifiers(decl))) {
                const binding = scope.getBinding(name);
                binding == null || binding.reference(path3);
              }
            }
          }
        }
      },
      LabeledStatement(path3) {
        path3.scope.getBlockParent().registerDeclaration(path3);
      },
      AssignmentExpression(path3, state) {
        state.assignments.push(path3);
      },
      UpdateExpression(path3, state) {
        state.constantViolations.push(path3);
      },
      UnaryExpression(path3, state) {
        if (path3.node.operator === "delete") {
          state.constantViolations.push(path3);
        }
      },
      BlockScoped(path3) {
        let scope = path3.scope;
        if (scope.path === path3) scope = scope.parent;
        const parent = scope.getBlockParent();
        parent.registerDeclaration(path3);
        if (path3.isClassDeclaration() && path3.node.id) {
          const id = path3.node.id;
          const name = id.name;
          path3.scope.bindings[name] = path3.scope.parent.getBinding(name);
        }
      },
      CatchClause(path3) {
        path3.scope.registerBinding("let", path3);
      },
      Function(path3) {
        const params = path3.get("params");
        for (const param of params) {
          path3.scope.registerBinding("param", param);
        }
        if (path3.isFunctionExpression() && path3.node.id && !path3.node.id[NOT_LOCAL_BINDING]) {
          path3.scope.registerBinding("local", path3.get("id"), path3);
        }
      },
      ClassExpression(path3) {
        if (path3.node.id && !path3.node.id[NOT_LOCAL_BINDING]) {
          path3.scope.registerBinding("local", path3.get("id"), path3);
        }
      },
      TSTypeAnnotation(path3) {
        path3.skip();
      }
    };
    var uid = 0;
    var Scope = class _Scope {
      constructor(path3) {
        this.uid = void 0;
        this.path = void 0;
        this.block = void 0;
        this.inited = void 0;
        this.labels = void 0;
        this.bindings = void 0;
        this.references = void 0;
        this.globals = void 0;
        this.uids = void 0;
        this.data = void 0;
        this.crawling = void 0;
        const {
          node
        } = path3;
        const cached = _cache.scope.get(node);
        if ((cached == null ? void 0 : cached.path) === path3) {
          return cached;
        }
        _cache.scope.set(node, this);
        this.uid = uid++;
        this.block = node;
        this.path = path3;
        this.labels = /* @__PURE__ */ new Map();
        this.inited = false;
      }
      get parent() {
        var _parent;
        let parent, path3 = this.path;
        do {
          var _path;
          const shouldSkip = path3.key === "key" || path3.listKey === "decorators";
          path3 = path3.parentPath;
          if (shouldSkip && path3.isMethod()) path3 = path3.parentPath;
          if ((_path = path3) != null && _path.isScope()) parent = path3;
        } while (path3 && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
      generateDeclaredUidIdentifier(name) {
        const id = this.generateUidIdentifier(name);
        this.push({
          id
        });
        return cloneNode(id);
      }
      generateUidIdentifier(name) {
        return identifier(this.generateUid(name));
      }
      generateUid(name = "temp") {
        name = toIdentifier(name).replace(/^_+/, "").replace(/\d+$/g, "");
        let uid2;
        let i = 1;
        do {
          uid2 = `_${name}`;
          if (i > 1) uid2 += i;
          i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
        const program3 = this.getProgramParent();
        program3.references[uid2] = true;
        program3.uids[uid2] = true;
        return uid2;
      }
      generateUidBasedOnNode(node, defaultName) {
        const parts = [];
        gatherNodeParts(node, parts);
        let id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUid(id.slice(0, 20));
      }
      generateUidIdentifierBasedOnNode(node, defaultName) {
        return identifier(this.generateUidBasedOnNode(node, defaultName));
      }
      isStatic(node) {
        if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {
          return true;
        }
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }
        return false;
      }
      maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          const id = this.generateUidIdentifierBasedOnNode(node);
          if (!dontPush) {
            this.push({
              id
            });
            return cloneNode(id);
          }
          return id;
        }
      }
      checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === "param") return;
        if (local.kind === "local") return;
        const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
        if (duplicate) {
          throw this.path.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
        }
      }
      rename(oldName, newName) {
        const binding = this.getBinding(oldName);
        if (binding) {
          newName || (newName = this.generateUidIdentifier(oldName).name);
          const renamer = new _renamer.default(binding, oldName, newName);
          {
            renamer.rename(arguments[2]);
          }
        }
      }
      dump() {
        const sep = "-".repeat(60);
        console.log(sep);
        let scope = this;
        do {
          console.log("#", scope.block.type);
          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            console.log(" -", name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      }
      hasLabel(name) {
        return !!this.getLabel(name);
      }
      getLabel(name) {
        return this.labels.get(name);
      }
      registerLabel(path3) {
        this.labels.set(path3.node.label.name, path3);
      }
      registerDeclaration(path3) {
        if (path3.isLabeledStatement()) {
          this.registerLabel(path3);
        } else if (path3.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path3.get("id"), path3);
        } else if (path3.isVariableDeclaration()) {
          const declarations = path3.get("declarations");
          const {
            kind
          } = path3.node;
          for (const declar of declarations) {
            this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
          }
        } else if (path3.isClassDeclaration()) {
          if (path3.node.declare) return;
          this.registerBinding("let", path3);
        } else if (path3.isImportDeclaration()) {
          const isTypeDeclaration = path3.node.importKind === "type" || path3.node.importKind === "typeof";
          const specifiers = path3.get("specifiers");
          for (const specifier of specifiers) {
            const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
            this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
          }
        } else if (path3.isExportDeclaration()) {
          const declar = path3.get("declaration");
          if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
            this.registerDeclaration(declar);
          }
        } else {
          this.registerBinding("unknown", path3);
        }
      }
      buildUndefinedNode() {
        return buildUndefinedNode();
      }
      registerConstantViolation(path3) {
        const ids = path3.getAssignmentIdentifiers();
        for (const name of Object.keys(ids)) {
          var _this$getBinding;
          (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path3);
        }
      }
      registerBinding(kind, path3, bindingPath = path3) {
        if (!kind) throw new ReferenceError("no `kind`");
        if (path3.isVariableDeclaration()) {
          const declarators = path3.get("declarations");
          for (const declar of declarators) {
            this.registerBinding(kind, declar);
          }
          return;
        }
        const parent = this.getProgramParent();
        const ids = path3.getOuterBindingIdentifiers(true);
        for (const name of Object.keys(ids)) {
          parent.references[name] = true;
          for (const id of ids[name]) {
            const local = this.getOwnBinding(name);
            if (local) {
              if (local.identifier === id) continue;
              this.checkBlockScopedCollisions(local, kind, name, id);
            }
            if (local) {
              local.reassign(bindingPath);
            } else {
              this.bindings[name] = new _binding.default({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind
              });
            }
          }
        }
      }
      addGlobal(node) {
        this.globals[node.name] = node;
      }
      hasUid(name) {
        let scope = this;
        do {
          if (scope.uids[name]) return true;
        } while (scope = scope.parent);
        return false;
      }
      hasGlobal(name) {
        let scope = this;
        do {
          if (scope.globals[name]) return true;
        } while (scope = scope.parent);
        return false;
      }
      hasReference(name) {
        return !!this.getProgramParent().references[name];
      }
      isPure(node, constantsOnly) {
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (!binding) return false;
          if (constantsOnly) return binding.constant;
          return true;
        } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
          return true;
        } else if (isClass(node)) {
          var _node$decorators;
          if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
            return false;
          }
          if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
            return false;
          }
          return this.isPure(node.body, constantsOnly);
        } else if (isClassBody(node)) {
          for (const method of node.body) {
            if (!this.isPure(method, constantsOnly)) return false;
          }
          return true;
        } else if (isBinary(node)) {
          return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (isArrayExpression(node) || isTupleExpression(node)) {
          for (const elem of node.elements) {
            if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
          }
          return true;
        } else if (isObjectExpression(node) || isRecordExpression(node)) {
          for (const prop of node.properties) {
            if (!this.isPure(prop, constantsOnly)) return false;
          }
          return true;
        } else if (isMethod(node)) {
          var _node$decorators2;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
            return false;
          }
          return true;
        } else if (isProperty(node)) {
          var _node$decorators3;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
            return false;
          }
          if (isObjectProperty(node) || node.static) {
            if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
              return false;
            }
          }
          return true;
        } else if (isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else if (isTemplateLiteral(node)) {
          for (const expression of node.expressions) {
            if (!this.isPure(expression, constantsOnly)) return false;
          }
          return true;
        } else if (isTaggedTemplateExpression(node)) {
          return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", {
            noGlobals: true
          }) && this.isPure(node.quasi, constantsOnly);
        } else if (isMemberExpression(node)) {
          return !node.computed && isIdentifier(node.object) && node.object.name === "Symbol" && isIdentifier(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {
            noGlobals: true
          });
        } else if (isCallExpression(node)) {
          return matchesPattern(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {
            noGlobals: true
          }) && node.arguments.length === 1 && t3.isStringLiteral(node.arguments[0]);
        } else {
          return isPureish(node);
        }
      }
      setData(key, val) {
        return this.data[key] = val;
      }
      getData(key) {
        let scope = this;
        do {
          const data = scope.data[key];
          if (data != null) return data;
        } while (scope = scope.parent);
      }
      removeData(key) {
        let scope = this;
        do {
          const data = scope.data[key];
          if (data != null) scope.data[key] = null;
        } while (scope = scope.parent);
      }
      init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      }
      crawl() {
        const path3 = this.path;
        this.references = /* @__PURE__ */ Object.create(null);
        this.bindings = /* @__PURE__ */ Object.create(null);
        this.globals = /* @__PURE__ */ Object.create(null);
        this.uids = /* @__PURE__ */ Object.create(null);
        this.data = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          if (scope.crawling) return;
          if (scope.path.isProgram()) {
            break;
          }
        } while (scope = scope.parent);
        const programParent = scope;
        const state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        if (path3.type !== "Program" && (0, _visitors.isExplodedVisitor)(collectorVisitor)) {
          for (const visit of collectorVisitor.enter) {
            visit.call(state, path3, state);
          }
          const typeVisitors = collectorVisitor[path3.type];
          if (typeVisitors) {
            for (const visit of typeVisitors.enter) {
              visit.call(state, path3, state);
            }
          }
        }
        path3.traverse(collectorVisitor, state);
        this.crawling = false;
        for (const path4 of state.assignments) {
          const ids = path4.getAssignmentIdentifiers();
          for (const name of Object.keys(ids)) {
            if (path4.scope.getBinding(name)) continue;
            programParent.addGlobal(ids[name]);
          }
          path4.scope.registerConstantViolation(path4);
        }
        for (const ref of state.references) {
          const binding = ref.scope.getBinding(ref.node.name);
          if (binding) {
            binding.reference(ref);
          } else {
            programParent.addGlobal(ref.node);
          }
        }
        for (const path4 of state.constantViolations) {
          path4.scope.registerConstantViolation(path4);
        }
      }
      push(opts) {
        let path3 = this.path;
        if (path3.isPattern()) {
          path3 = this.getPatternParent().path;
        } else if (!path3.isBlockStatement() && !path3.isProgram()) {
          path3 = this.getBlockParent().path;
        }
        if (path3.isSwitchStatement()) {
          path3 = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        const {
          init,
          unique,
          kind = "var",
          id
        } = opts;
        if (!init && !unique && (kind === "var" || kind === "let") && path3.isFunction() && !path3.node.name && isCallExpression(path3.parent, {
          callee: path3.node
        }) && path3.parent.arguments.length <= path3.node.params.length && isIdentifier(id)) {
          path3.pushContainer("params", id);
          path3.scope.registerBinding("param", path3.get("params")[path3.node.params.length - 1]);
          return;
        }
        if (path3.isLoop() || path3.isCatchClause() || path3.isFunction()) {
          path3.ensureBlock();
          path3 = path3.get("body");
        }
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path3.getData(dataKey);
        if (!declarPath) {
          const declar = variableDeclaration(kind, []);
          declar._blockHoist = blockHoist;
          [declarPath] = path3.unshiftContainer("body", [declar]);
          if (!unique) path3.setData(dataKey, declarPath);
        }
        const declarator = variableDeclarator(id, init);
        const len = declarPath.node.declarations.push(declarator);
        path3.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
      }
      getProgramParent() {
        let scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("Couldn't find a Program");
      }
      getFunctionParent() {
        let scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        return null;
      }
      getBlockParent() {
        let scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getPatternParent() {
        let scope = this;
        do {
          if (!scope.path.isPattern()) {
            return scope.getBlockParent();
          }
        } while (scope = scope.parent.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getAllBindings() {
        const ids = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          for (const key of Object.keys(scope.bindings)) {
            if (key in ids === false) {
              ids[key] = scope.bindings[key];
            }
          }
          scope = scope.parent;
        } while (scope);
        return ids;
      }
      bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      }
      getBinding(name) {
        let scope = this;
        let previousPath;
        do {
          const binding = scope.getOwnBinding(name);
          if (binding) {
            var _previousPath;
            if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {
            } else {
              return binding;
            }
          } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
          previousPath = scope.path;
        } while (scope = scope.parent);
      }
      getOwnBinding(name) {
        return this.bindings[name];
      }
      getBindingIdentifier(name) {
        var _this$getBinding2;
        return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;
      }
      getOwnBindingIdentifier(name) {
        const binding = this.bindings[name];
        return binding == null ? void 0 : binding.identifier;
      }
      hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      }
      hasBinding(name, opts) {
        if (!name) return false;
        let scope = this;
        do {
          if (scope.hasOwnBinding(name)) {
            return true;
          }
        } while (scope = scope.parent);
        let noGlobals;
        let noUids;
        if (typeof opts === "object") {
          noGlobals = opts.noGlobals;
          noUids = opts.noUids;
        } else if (typeof opts === "boolean") {
          noGlobals = opts;
        }
        if (!noUids && this.hasUid(name)) return true;
        if (!noGlobals && _Scope.globals.includes(name)) return true;
        if (!noGlobals && _Scope.contextVariables.includes(name)) return true;
        return false;
      }
      parentHasBinding(name, opts) {
        var _this$parent;
        return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);
      }
      moveBindingTo(name, scope) {
        const info = this.getBinding(name);
        if (info) {
          info.scope.removeOwnBinding(name);
          info.scope = scope;
          scope.bindings[name] = info;
        }
      }
      removeOwnBinding(name) {
        delete this.bindings[name];
      }
      removeBinding(name) {
        var _this$getBinding3;
        (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
        let scope = this;
        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      }
      hoistVariables(emit = (id) => this.push({
        id
      })) {
        this.crawl();
        const seen = /* @__PURE__ */ new Set();
        for (const name of Object.keys(this.bindings)) {
          const binding = this.bindings[name];
          if (!binding) continue;
          const {
            path: path3
          } = binding;
          if (!path3.isVariableDeclarator()) continue;
          const {
            parent,
            parentPath
          } = path3;
          if (parent.kind !== "var" || seen.has(parent)) continue;
          seen.add(path3.parent);
          let firstId;
          const init = [];
          for (const decl of parent.declarations) {
            var _firstId;
            (_firstId = firstId) != null ? _firstId : firstId = decl.id;
            if (decl.init) {
              init.push(assignmentExpression("=", decl.id, decl.init));
            }
            const ids = Object.keys(getBindingIdentifiers(decl, false, true, true));
            for (const name2 of ids) {
              emit(identifier(name2), decl.init != null);
            }
          }
          if (parentPath.parentPath.isFor({
            left: parent
          })) {
            parentPath.replaceWith(firstId);
          } else if (init.length === 0) {
            parentPath.remove();
          } else {
            const expr = init.length === 1 ? init[0] : sequenceExpression(init);
            if (parentPath.parentPath.isForStatement({
              init: parent
            })) {
              parentPath.replaceWith(expr);
            } else {
              parentPath.replaceWith(expressionStatement(expr));
            }
          }
        }
      }
    };
    exports2.default = Scope;
    Scope.globals = Object.keys(_globals.builtin);
    Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    {
      Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      };
      Scope.prototype.traverse = function(node, opts, state) {
        (0, _index.default)(node, opts, this, state, this.path);
      };
      Scope.prototype._generateUid = function _generateUid(name, i) {
        let id = name;
        if (i > 1) id += i;
        return `_${id}`;
      };
      Scope.prototype.toArray = function toArray(node, i, arrayLikeIsIterable) {
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
            return node;
          }
        }
        if (isArrayExpression(node)) {
          return node;
        }
        if (isIdentifier(node, {
          name: "arguments"
        })) {
          return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
        }
        let helperName;
        const args = [node];
        if (i === true) {
          helperName = "toConsumableArray";
        } else if (typeof i === "number") {
          args.push(numericLiteral(i));
          helperName = "slicedToArray";
        } else {
          helperName = "toArray";
        }
        if (arrayLikeIsIterable) {
          args.unshift(this.path.hub.addHelper(helperName));
          helperName = "maybeArrayLike";
        }
        return callExpression(this.path.hub.addHelper(helperName), args);
      };
      Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {
        const ids = /* @__PURE__ */ Object.create(null);
        for (const kind of kinds) {
          let scope = this;
          do {
            for (const name of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name];
              if (binding.kind === kind) ids[name] = binding;
            }
            scope = scope.parent;
          } while (scope);
        }
        return ids;
      };
      Object.defineProperties(Scope.prototype, {
        parentBlock: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.parent;
          }
        },
        hub: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.hub;
          }
        }
      });
    }
  }
});

// node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.setArray = {}));
    })(exports2, function(exports3) {
      "use strict";
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      function cast(set) {
        return set;
      }
      function get(setarr, key) {
        return cast(setarr)._indexes[key];
      }
      function put(setarr, key) {
        const index = get(setarr, key);
        if (index !== void 0)
          return index;
        const { array, _indexes: indexes } = cast(setarr);
        const length = array.push(key);
        return indexes[key] = length - 1;
      }
      function pop(setarr) {
        const { array, _indexes: indexes } = cast(setarr);
        if (array.length === 0)
          return;
        const last = array.pop();
        indexes[last] = void 0;
      }
      function remove(setarr, key) {
        const index = get(setarr, key);
        if (index === void 0)
          return;
        const { array, _indexes: indexes } = cast(setarr);
        for (let i = index + 1; i < array.length; i++) {
          const k = array[i];
          array[i - 1] = k;
          indexes[k]--;
        }
        indexes[key] = void 0;
        array.pop();
      }
      exports3.SetArray = SetArray;
      exports3.get = get;
      exports3.pop = pop;
      exports3.put = put;
      exports3.remove = remove;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
    })(exports2, function(exports3) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
      }
      function decodeInteger(reader, relative) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c = reader.next();
          integer = charToInt[c];
          value |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        return relative + value;
      }
      function encodeInteger(builder, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0)
            clamped |= 32;
          builder.write(intToChar[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max) {
        if (reader.pos >= max)
          return false;
        return reader.peek() !== comma;
      }
      const bufLength = 1024 * 16;
      const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      class StringWriter {
        constructor() {
          this.pos = 0;
          this.out = "";
          this.buffer = new Uint8Array(bufLength);
        }
        write(v) {
          const { buffer } = this;
          buffer[this.pos++] = v;
          if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
          }
        }
        flush() {
          const { buffer, out, pos } = this;
          return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
        }
      }
      class StringReader {
        constructor(buffer) {
          this.pos = 0;
          this.buffer = buffer;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char) {
          const { buffer, pos } = this;
          const idx = buffer.indexOf(char, pos);
          return idx === -1 ? buffer.length : idx;
        }
      }
      const EMPTY = [];
      function decodeOriginalScopes(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const scopes = [];
        const stack = [];
        let line = 0;
        for (; reader.pos < length; reader.pos++) {
          line = decodeInteger(reader, line);
          const column = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
          }
          const kind = decodeInteger(reader, 0);
          const fields = decodeInteger(reader, 0);
          const hasName = fields & 1;
          const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
          let vars = EMPTY;
          if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
              const varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length));
          }
          scope.vars = vars;
          scopes.push(scope);
          stack.push(scope);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        const writer = new StringWriter();
        for (let i = 0; i < scopes.length; ) {
          i = _encodeOriginalScopes(scopes, i, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index, writer, state) {
        const scope = scopes[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
        if (index > 0)
          writer.write(comma);
        state[0] = encodeInteger(writer, startLine, state[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        const fields = scope.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0);
        if (scope.length === 6)
          encodeInteger(writer, scope[5], 0);
        for (const v of vars) {
          encodeInteger(writer, v, 0);
        }
        for (index++; index < scopes.length; ) {
          const next = scopes[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        writer.write(comma);
        state[0] = encodeInteger(writer, endLine, state[0]);
        encodeInteger(writer, endColumn, 0);
        return index;
      }
      function decodeGeneratedRanges(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
          const semi = reader.indexOf(";");
          let genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
              const last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
              const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
              definitionSourcesIndex = defSourcesIndex;
              range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
              const prevCsi = callsiteSourcesIndex;
              const prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              const sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                const expressionsCount = decodeInteger(reader, 0);
                let expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (let i = -1; i > expressionsCount; i--) {
                    const prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine);
                    bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    const expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
          }
          genLine++;
          reader.pos = semi + 1;
        } while (reader.pos < length);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0)
          return "";
        const writer = new StringWriter();
        for (let i = 0; i < ranges.length; ) {
          i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index, writer, state) {
        const range = ranges[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings } = range;
        if (state[0] < startLine) {
          catchupLine(writer, state[0], startLine);
          state[0] = startLine;
          state[1] = 0;
        } else if (index > 0) {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, range[1], state[1]);
        const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
        encodeInteger(writer, fields, 0);
        if (range.length === 6) {
          const { 4: sourcesIndex, 5: scopesIndex } = range;
          if (sourcesIndex !== state[2]) {
            state[3] = 0;
          }
          state[2] = encodeInteger(writer, sourcesIndex, state[2]);
          state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
          if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
          } else if (callLine !== state[5]) {
            state[6] = 0;
          }
          state[4] = encodeInteger(writer, sourcesIndex, state[4]);
          state[5] = encodeInteger(writer, callLine, state[5]);
          state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings) {
          for (const binding of bindings) {
            if (binding.length > 1)
              encodeInteger(writer, -binding.length, 0);
            const expression = binding[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i = 1; i < binding.length; i++) {
              const expRange = binding[i];
              bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
              bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
              encodeInteger(writer, expRange[0], 0);
            }
          }
        }
        for (index++; index < ranges.length; ) {
          const next = ranges[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        if (state[0] < endLine) {
          catchupLine(writer, state[0], endLine);
          state[0] = endLine;
          state[1] = 0;
        } else {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, endColumn, state[1]);
        return index;
      }
      function catchupLine(writer, lastLine, line) {
        do {
          writer.write(semicolon);
        } while (++lastLine < line);
      }
      function decode(mappings) {
        const { length } = mappings;
        const reader = new StringReader(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
          const semi = reader.indexOf(";");
          const line = [];
          let sorted = true;
          let lastCol = 0;
          genColumn = 0;
          while (reader.pos < semi) {
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol)
              sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
              sourcesIndex = decodeInteger(reader, sourcesIndex);
              sourceLine = decodeInteger(reader, sourceLine);
              sourceColumn = decodeInteger(reader, sourceColumn);
              if (hasMoreVlq(reader, semi)) {
                namesIndex = decodeInteger(reader, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          reader.pos = semi + 1;
        } while (reader.pos <= length);
        return decoded;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        const writer = new StringWriter();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0)
            writer.write(semicolon);
          if (line.length === 0)
            continue;
          let genColumn = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0)
              writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1)
              continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4)
              continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
      exports3.decode = decode;
      exports3.decodeGeneratedRanges = decodeGeneratedRanges;
      exports3.decodeOriginalScopes = decodeOriginalScopes;
      exports3.encode = encode;
      exports3.encodeGeneratedRanges = encodeGeneratedRanges;
      exports3.encodeOriginalScopes = encodeOriginalScopes;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports2, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path3 = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path3) ? path3 : "/" + path3, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path3, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path: path3,
          query,
          hash,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path3) {
        if (path3.endsWith("/.."))
          return path3;
        const index = path3.lastIndexOf("/");
        return path3.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path3 = "";
        for (let i = 1; i < pointer; i++) {
          path3 += "/" + pieces[i];
        }
        if (!path3 || addTrailingSlash && !path3.endsWith("/..")) {
          path3 += "/";
        }
        url.path = path3;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            // fall through
            case 2:
              url.query = baseUrl.query;
            // fall through
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            // fall through
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            // fall through
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path3 = url.path.slice(1);
            if (!path3)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path3)) {
              return "./" + path3 + queryHash;
            }
            return path3 + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
    })(exports2, function(exports3, sourcemapCodec, resolveUri) {
      "use strict";
      function resolve(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri(input, base);
      }
      function stripFilename(path3) {
        if (!path3)
          return "";
        const index = path3.lastIndexOf("/");
        return path3.slice(0, index + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = parse2(map);
        if (!("sections" in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function parse2(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse2(input);
        if ("sections" in parsed)
          return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents)
          append(sourcesContent, contents);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        if (ignores)
          for (let i = 0; i < ignores.length; i++)
            ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++)
          arr[i] = [];
        return arr[index];
      }
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      class TraceMap {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo)
            return map;
          const parsed = isString ? JSON.parse(map) : map;
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const from = resolve(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s) => resolve(s || "", from));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a;
        var _b;
        return (_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = sourcemapCodec.encode(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = sourcemapCodec.decode(cast(map)._encoded));
      }
      function traceSegment(map, line, column) {
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1)
          return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      }
      function generatedPositionFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      }
      function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source);
        if (index === -1)
          index = resolvedSources.indexOf(source);
        return index;
      }
      function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null)
          return null;
        const index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null)
          return false;
        const index = sourceIndex(map, source);
        return index === -1 ? false : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone(map, encodedMappings(map));
      }
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line, column, name) {
        return { source, line, column, name };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min++;
        if (min === -1 || min === segments.length)
          return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found)
          min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1)
          sourceIndex2 = resolvedSources.indexOf(source);
        if (sourceIndex2 === -1)
          return all ? [] : GMapping(null, null);
        const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
        const segments = generated[sourceIndex2][line];
        if (segments == null)
          return all ? [] : GMapping(null, null);
        const memo = cast(map)._bySourceMemos[sourceIndex2];
        if (all)
          return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1)
          return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
      exports3.AnyMap = AnyMap;
      exports3.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports3.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports3.TraceMap = TraceMap;
      exports3.allGeneratedPositionsFor = allGeneratedPositionsFor;
      exports3.decodedMap = decodedMap;
      exports3.decodedMappings = decodedMappings;
      exports3.eachMapping = eachMapping;
      exports3.encodedMap = encodedMap;
      exports3.encodedMappings = encodedMappings;
      exports3.generatedPositionFor = generatedPositionFor;
      exports3.isIgnored = isIgnored;
      exports3.originalPositionFor = originalPositionFor;
      exports3.presortedDecodedMap = presortedDecodedMap;
      exports3.sourceContentFor = sourceContentFor;
      exports3.traceSegment = traceSegment;
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.genMapping = {}, global2.setArray, global2.sourcemapCodec, global2.traceMapping));
    })(exports2, function(exports3, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const NO_NAME = -1;
      class GenMapping {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new setArray.SetArray();
        }
      }
      function cast(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      };
      const maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source, content) {
        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);
        const index = setArray.put(sources, source);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source, ignore = true) {
        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);
        const index = setArray.put(sources, source);
        if (index === sourcesContent.length)
          sourcesContent[index] = null;
        if (ignore)
          setArray.put(ignoreList, index);
        else
          setArray.remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
      }
      function fromMap(input) {
        const map = new traceMapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast(gen)._names, map.names);
        putAll(cast(gen)._sources, map.sources);
        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList)
          putAll(cast(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated = { line: i + 1, column: seg[COLUMN] };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5)
                name = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated, source, original, name });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast(map);
        const line = getLine(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index))
            return;
          return insert(line, index, [genColumn]);
        }
        const sourcesIndex = setArray.put(sources, source);
        const namesIndex = name ? setArray.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      }
      function getLine(mappings, index) {
        for (let i = mappings.length; i <= index; i++) {
          mappings[i] = [];
        }
        return mappings[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current = line[i];
          if (genColumn >= current[COLUMN])
            break;
        }
        return index;
      }
      function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(setarr, array) {
        for (let i = 0; i < array.length; i++)
          setArray.put(setarr, array[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0)
          return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0)
          return false;
        const prev = line[index - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name, content } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
      }
      exports3.GenMapping = GenMapping;
      exports3.addMapping = addMapping;
      exports3.addSegment = addSegment;
      exports3.allMappings = allMappings;
      exports3.fromMap = fromMap;
      exports3.maybeAddMapping = maybeAddMapping;
      exports3.maybeAddSegment = maybeAddSegment;
      exports3.setIgnore = setIgnore;
      exports3.setSourceContent = setSourceContent;
      exports3.toDecodedMap = toDecodedMap;
      exports3.toEncodedMap = toEncodedMap;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@babel/generator/lib/source-map.js
var require_source_map = __commonJS({
  "node_modules/@babel/generator/lib/source-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _genMapping = require_gen_mapping_umd();
    var _traceMapping = require_trace_mapping_umd();
    var SourceMap = class {
      constructor(opts, code) {
        var _opts$sourceFileName;
        this._map = void 0;
        this._rawMappings = void 0;
        this._sourceFileName = void 0;
        this._lastGenLine = 0;
        this._lastSourceLine = 0;
        this._lastSourceColumn = 0;
        this._inputMap = void 0;
        const map = this._map = new _genMapping.GenMapping({
          sourceRoot: opts.sourceRoot
        });
        this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
        this._rawMappings = void 0;
        if (opts.inputSourceMap) {
          this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
          const resolvedSources = this._inputMap.resolvedSources;
          if (resolvedSources.length) {
            for (let i = 0; i < resolvedSources.length; i++) {
              var _this$_inputMap$sourc;
              (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
            }
          }
        }
        if (typeof code === "string" && !opts.inputSourceMap) {
          (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
        } else if (typeof code === "object") {
          for (const sourceFileName of Object.keys(code)) {
            (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          }
        }
      }
      get() {
        return (0, _genMapping.toEncodedMap)(this._map);
      }
      getDecoded() {
        return (0, _genMapping.toDecodedMap)(this._map);
      }
      getRawMappings() {
        return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
      }
      mark(generated, line, column, identifierName, identifierNamePos, filename) {
        var _originalMapping;
        this._rawMappings = void 0;
        let originalMapping;
        if (line != null) {
          if (this._inputMap) {
            originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
              line,
              column
            });
            if (!originalMapping.name && identifierNamePos) {
              const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
              if (originalIdentifierMapping.name) {
                identifierName = originalIdentifierMapping.name;
              }
            }
          } else {
            originalMapping = {
              source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
              line,
              column
            };
          }
        }
        (0, _genMapping.maybeAddMapping)(this._map, {
          name: identifierName,
          generated,
          source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
          original: originalMapping
        });
      }
    };
    exports2.default = SourceMap;
  }
});

// node_modules/@babel/generator/lib/buffer.js
var require_buffer = __commonJS({
  "node_modules/@babel/generator/lib/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Buffer2 = class {
      constructor(map, indentChar) {
        this._map = null;
        this._buf = "";
        this._str = "";
        this._appendCount = 0;
        this._last = 0;
        this._queue = [];
        this._queueCursor = 0;
        this._canMarkIdName = true;
        this._indentChar = "";
        this._fastIndentations = [];
        this._position = {
          line: 1,
          column: 0
        };
        this._sourcePosition = {
          identifierName: void 0,
          identifierNamePos: void 0,
          line: void 0,
          column: void 0,
          filename: void 0
        };
        this._map = map;
        this._indentChar = indentChar;
        for (let i = 0; i < 64; i++) {
          this._fastIndentations.push(indentChar.repeat(i));
        }
        this._allocQueue();
      }
      _allocQueue() {
        const queue = this._queue;
        for (let i = 0; i < 16; i++) {
          queue.push({
            char: 0,
            repeat: 1,
            line: void 0,
            column: void 0,
            identifierName: void 0,
            identifierNamePos: void 0,
            filename: ""
          });
        }
      }
      _pushQueue(char, repeat, line, column, filename) {
        const cursor = this._queueCursor;
        if (cursor === this._queue.length) {
          this._allocQueue();
        }
        const item = this._queue[cursor];
        item.char = char;
        item.repeat = repeat;
        item.line = line;
        item.column = column;
        item.filename = filename;
        this._queueCursor++;
      }
      _popQueue() {
        if (this._queueCursor === 0) {
          throw new Error("Cannot pop from empty queue");
        }
        return this._queue[--this._queueCursor];
      }
      get() {
        this._flush();
        const map = this._map;
        const result = {
          code: (this._buf + this._str).trimRight(),
          decodedMap: map == null ? void 0 : map.getDecoded(),
          get __mergedMap() {
            return this.map;
          },
          get map() {
            const resultMap = map ? map.get() : null;
            result.map = resultMap;
            return resultMap;
          },
          set map(value) {
            Object.defineProperty(result, "map", {
              value,
              writable: true
            });
          },
          get rawMappings() {
            const mappings = map == null ? void 0 : map.getRawMappings();
            result.rawMappings = mappings;
            return mappings;
          },
          set rawMappings(value) {
            Object.defineProperty(result, "rawMappings", {
              value,
              writable: true
            });
          }
        };
        return result;
      }
      append(str, maybeNewline) {
        this._flush();
        this._append(str, this._sourcePosition, maybeNewline);
      }
      appendChar(char) {
        this._flush();
        this._appendChar(char, 1, this._sourcePosition);
      }
      queue(char) {
        if (char === 10) {
          while (this._queueCursor !== 0) {
            const char2 = this._queue[this._queueCursor - 1].char;
            if (char2 !== 32 && char2 !== 9) {
              break;
            }
            this._queueCursor--;
          }
        }
        const sourcePosition = this._sourcePosition;
        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
      }
      queueIndentation(repeat) {
        if (repeat === 0) return;
        this._pushQueue(-1, repeat, void 0, void 0, void 0);
      }
      _flush() {
        const queueCursor = this._queueCursor;
        const queue = this._queue;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          this._appendChar(item.char, item.repeat, item);
        }
        this._queueCursor = 0;
      }
      _appendChar(char, repeat, sourcePos) {
        this._last = char;
        if (char === -1) {
          const fastIndentation = this._fastIndentations[repeat];
          if (fastIndentation !== void 0) {
            this._str += fastIndentation;
          } else {
            this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
          }
        } else {
          this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
        }
        if (char !== 10) {
          this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
          this._position.column += repeat;
        } else {
          this._position.line++;
          this._position.column = 0;
        }
        if (this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
      }
      _append(str, sourcePos, maybeNewline) {
        const len = str.length;
        const position = this._position;
        this._last = str.charCodeAt(len - 1);
        if (++this._appendCount > 4096) {
          +this._str;
          this._buf += this._str;
          this._str = str;
          this._appendCount = 0;
        } else {
          this._str += str;
        }
        if (!maybeNewline && !this._map) {
          position.column += len;
          return;
        }
        const {
          column,
          identifierName,
          identifierNamePos,
          filename
        } = sourcePos;
        let line = sourcePos.line;
        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        let i = str.indexOf("\n");
        let last = 0;
        if (i !== 0) {
          this._mark(line, column, identifierName, identifierNamePos, filename);
        }
        while (i !== -1) {
          position.line++;
          position.column = 0;
          last = i + 1;
          if (last < len && line !== void 0) {
            this._mark(++line, 0, null, null, filename);
          }
          i = str.indexOf("\n", last);
        }
        position.column += len - last;
      }
      _mark(line, column, identifierName, identifierNamePos, filename) {
        var _this$_map;
        (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
      }
      removeTrailingNewline() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
          this._queueCursor--;
        }
      }
      removeLastSemicolon() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
          this._queueCursor--;
        }
      }
      getLastChar() {
        const queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
      }
      getNewlineCount() {
        const queueCursor = this._queueCursor;
        let count = 0;
        if (queueCursor === 0) return this._last === 10 ? 1 : 0;
        for (let i = queueCursor - 1; i >= 0; i--) {
          if (this._queue[i].char !== 10) {
            break;
          }
          count++;
        }
        return count === queueCursor && this._last === 10 ? count + 1 : count;
      }
      endsWithCharAndNewline() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0) {
          const lastCp = queue[queueCursor - 1].char;
          if (lastCp !== 10) return;
          if (queueCursor > 1) {
            return queue[queueCursor - 2].char;
          } else {
            return this._last;
          }
        }
      }
      hasContent() {
        return this._queueCursor !== 0 || !!this._last;
      }
      exactSource(loc, cb) {
        if (!this._map) {
          cb();
          return;
        }
        this.source("start", loc);
        const identifierName = loc.identifierName;
        const sourcePos = this._sourcePosition;
        if (identifierName) {
          this._canMarkIdName = false;
          sourcePos.identifierName = identifierName;
        }
        cb();
        if (identifierName) {
          this._canMarkIdName = true;
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        this.source("end", loc);
      }
      source(prop, loc) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, 0);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, columnOffset);
      }
      _normalizePosition(prop, loc, columnOffset) {
        const pos = loc[prop];
        const target = this._sourcePosition;
        if (pos) {
          target.line = pos.line;
          target.column = Math.max(pos.column + columnOffset, 0);
          target.filename = loc.filename;
        }
      }
      getCurrentColumn() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        let lastIndex = -1;
        let len = 0;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          if (item.char === 10) {
            lastIndex = len;
          }
          len += item.repeat;
        }
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
      }
      getCurrentLine() {
        let count = 0;
        const queue = this._queue;
        for (let i = 0; i < this._queueCursor; i++) {
          if (queue[i].char === 10) {
            count++;
          }
        }
        return this._position.line + count;
      }
    };
    exports2.default = Buffer2;
  }
});

// node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace = __commonJS({
  "node_modules/@babel/generator/lib/node/whitespace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.nodes = void 0;
    var _t = require_lib4();
    var {
      FLIPPED_ALIAS_KEYS,
      isArrayExpression,
      isAssignmentExpression,
      isBinary,
      isBlockStatement,
      isCallExpression,
      isFunction,
      isIdentifier,
      isLiteral,
      isMemberExpression,
      isObjectExpression,
      isOptionalCallExpression,
      isOptionalMemberExpression,
      isStringLiteral: isStringLiteral3
    } = _t;
    function crawlInternal(node, state) {
      if (!node) return state;
      if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
        crawlInternal(node.object, state);
        if (node.computed) crawlInternal(node.property, state);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        crawlInternal(node.left, state);
        crawlInternal(node.right, state);
      } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
        state.hasCall = true;
        crawlInternal(node.callee, state);
      } else if (isFunction(node)) {
        state.hasFunction = true;
      } else if (isIdentifier(node)) {
        state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
      }
      return state;
    }
    function crawl(node) {
      return crawlInternal(node, {
        hasCall: false,
        hasFunction: false,
        hasHelper: false
      });
    }
    function isHelper(node) {
      if (!node) return false;
      if (isMemberExpression(node)) {
        return isHelper(node.object) || isHelper(node.property);
      } else if (isIdentifier(node)) {
        return node.name === "require" || node.name.charCodeAt(0) === 95;
      } else if (isCallExpression(node)) {
        return isHelper(node.callee);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
      } else {
        return false;
      }
    }
    function isType(node) {
      return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
    }
    var nodes = exports2.nodes = {
      AssignmentExpression(node) {
        const state = crawl(node.right);
        if (state.hasCall && state.hasHelper || state.hasFunction) {
          return state.hasFunction ? 1 | 2 : 2;
        }
      },
      SwitchCase(node, parent) {
        return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
      },
      LogicalExpression(node) {
        if (isFunction(node.left) || isFunction(node.right)) {
          return 2;
        }
      },
      Literal(node) {
        if (isStringLiteral3(node) && node.value === "use strict") {
          return 2;
        }
      },
      CallExpression(node) {
        if (isFunction(node.callee) || isHelper(node)) {
          return 1 | 2;
        }
      },
      OptionalCallExpression(node) {
        if (isFunction(node.callee)) {
          return 1 | 2;
        }
      },
      VariableDeclaration(node) {
        for (let i = 0; i < node.declarations.length; i++) {
          const declar = node.declarations[i];
          let enabled = isHelper(declar.id) && !isType(declar.init);
          if (!enabled && declar.init) {
            const state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }
          if (enabled) {
            return 1 | 2;
          }
        }
      },
      IfStatement(node) {
        if (isBlockStatement(node.consequent)) {
          return 1 | 2;
        }
      }
    };
    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
      if (parent.properties[0] === node) {
        return 1;
      }
    };
    nodes.ObjectTypeCallProperty = function(node, parent) {
      var _parent$properties;
      if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeIndexer = function(node, parent) {
      var _parent$properties2, _parent$callPropertie;
      if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeInternalSlot = function(node, parent) {
      var _parent$properties3, _parent$callPropertie2, _parent$indexers;
      if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
        return 1;
      }
    };
    [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
      [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
        const ret = amounts ? 1 | 2 : 0;
        nodes[type2] = () => ret;
      });
    });
  }
});

// node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses = __commonJS({
  "node_modules/@babel/generator/lib/node/parentheses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.Binary = Binary;
    exports2.BinaryExpression = BinaryExpression;
    exports2.ClassExpression = ClassExpression;
    exports2.ArrowFunctionExpression = exports2.ConditionalExpression = ConditionalExpression;
    exports2.DoExpression = DoExpression;
    exports2.FunctionExpression = FunctionExpression;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.Identifier = Identifier;
    exports2.LogicalExpression = LogicalExpression;
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    exports2.ObjectExpression = ObjectExpression;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports2.OptionalCallExpression = exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.SequenceExpression = SequenceExpression;
    exports2.TSSatisfiesExpression = exports2.TSAsExpression = TSAsExpression;
    exports2.TSConditionalType = TSConditionalType;
    exports2.TSConstructorType = exports2.TSFunctionType = TSFunctionType;
    exports2.TSInferType = TSInferType;
    exports2.TSInstantiationExpression = TSInstantiationExpression;
    exports2.TSIntersectionType = TSIntersectionType;
    exports2.UnaryLike = exports2.TSTypeAssertion = UnaryLike;
    exports2.TSTypeOperator = TSTypeOperator;
    exports2.TSUnionType = TSUnionType;
    exports2.IntersectionTypeAnnotation = exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.UpdateExpression = UpdateExpression;
    exports2.AwaitExpression = exports2.YieldExpression = YieldExpression;
    var _t = require_lib4();
    var _index = require_node2();
    var {
      isArrayTypeAnnotation,
      isBinaryExpression,
      isCallExpression,
      isForOfStatement,
      isIndexedAccessType,
      isMemberExpression,
      isObjectPattern,
      isOptionalMemberExpression,
      isYieldExpression,
      isStatement
    } = _t;
    var PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
    function getBinaryPrecedence(node, nodeType) {
      if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
        return PRECEDENCE.get(node.operator);
      }
      if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
        return PRECEDENCE.get("in");
      }
    }
    function isTSTypeExpression(nodeType) {
      return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
    }
    var isClassExtendsClause = (node, parent) => {
      const parentType = parent.type;
      return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node;
    };
    var hasPostfixPart = (node, parent) => {
      const parentType = parent.type;
      return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node || parentType === "TaggedTemplateExpression" && parent.tag === node || parentType === "TSNonNullExpression";
    };
    function NullableTypeAnnotation(node, parent) {
      return isArrayTypeAnnotation(parent);
    }
    function FunctionTypeAnnotation(node, parent, tokenContext) {
      const parentType = parent.type;
      return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);
    }
    function UpdateExpression(node, parent) {
      return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
    }
    function needsParenBeforeExpressionBrace(tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
    }
    function ObjectExpression(node, parent, tokenContext) {
      return needsParenBeforeExpressionBrace(tokenContext);
    }
    function DoExpression(node, parent, tokenContext) {
      return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);
    }
    function Binary(node, parent) {
      const parentType = parent.type;
      if (node.type === "BinaryExpression" && node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
        return parent.left === node;
      }
      if (isClassExtendsClause(node, parent)) {
        return true;
      }
      if (hasPostfixPart(node, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
        return true;
      }
      const parentPos = getBinaryPrecedence(parent, parentType);
      if (parentPos != null) {
        const nodePos = getBinaryPrecedence(node, node.type);
        if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node || parentPos > nodePos) {
          return true;
        }
      }
      return void 0;
    }
    function UnionTypeAnnotation(node, parent) {
      const parentType = parent.type;
      return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
    }
    function OptionalIndexedAccessType(node, parent) {
      return isIndexedAccessType(parent) && parent.objectType === node;
    }
    function TSAsExpression(node, parent) {
      if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node) {
        return true;
      }
      if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node === parent.left) {
        return true;
      }
      return Binary(node, parent);
    }
    function TSConditionalType(node, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
        return true;
      }
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
        return true;
      }
      if (parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node)) {
        return true;
      }
      return false;
    }
    function TSUnionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSIntersectionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInferType(node, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType") {
        return true;
      }
      if (node.typeParameter.constraint) {
        if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
          return true;
        }
      }
      return false;
    }
    function TSTypeOperator(node, parent) {
      const parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInstantiationExpression(node, parent) {
      const parentType = parent.type;
      return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
    }
    function TSFunctionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node);
    }
    function BinaryExpression(node, parent, tokenContext, inForStatementInit) {
      return node.operator === "in" && inForStatementInit;
    }
    function SequenceExpression(node, parent) {
      const parentType = parent.type;
      if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node || parentType === "OptionalMemberExpression" && parent.property === node || parentType === "TemplateLiteral") {
        return false;
      }
      if (parentType === "ClassDeclaration") {
        return true;
      }
      if (parentType === "ForOfStatement") {
        return parent.right === node;
      }
      if (parentType === "ExportDefaultDeclaration") {
        return true;
      }
      return !isStatement(parent);
    }
    function YieldExpression(node, parent) {
      const parentType = parent.type;
      return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node, parent) || parentType === "AwaitExpression" && isYieldExpression(node) || parentType === "ConditionalExpression" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);
    }
    function ClassExpression(node, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function UnaryLike(node, parent) {
      return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node || isClassExtendsClause(node, parent);
    }
    function FunctionExpression(node, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function ConditionalExpression(node, parent) {
      const parentType = parent.type;
      if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
        return true;
      }
      return UnaryLike(node, parent);
    }
    function OptionalMemberExpression(node, parent) {
      return isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node;
    }
    function AssignmentExpression(node, parent, tokenContext) {
      if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {
        return true;
      } else {
        return ConditionalExpression(node, parent);
      }
    }
    function LogicalExpression(node, parent) {
      const parentType = parent.type;
      if (isTSTypeExpression(parentType)) return true;
      if (parentType !== "LogicalExpression") return false;
      switch (node.operator) {
        case "||":
          return parent.operator === "??" || parent.operator === "&&";
        case "&&":
          return parent.operator === "??";
        case "??":
          return parent.operator !== "??";
      }
    }
    function Identifier(node, parent, tokenContext, _inForInit, getRawIdentifier) {
      var _node$extra;
      const parentType = parent.type;
      if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node) {
        const rightType = parent.right.type;
        if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
          return true;
        }
      }
      if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
        return false;
      }
      if (node.name === "let") {
        const isFollowedByBracket = isMemberExpression(parent, {
          object: node,
          computed: true
        }) || isOptionalMemberExpression(parent, {
          object: node,
          computed: true,
          optional: false
        });
        if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forHead | _index.TokenContext.forInHead)) {
          return true;
        }
        return Boolean(tokenContext & _index.TokenContext.forOfHead);
      }
      return node.name === "async" && isForOfStatement(parent, {
        left: node,
        await: false
      });
    }
  }
});

// node_modules/@babel/generator/lib/node/index.js
var require_node2 = __commonJS({
  "node_modules/@babel/generator/lib/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenContext = void 0;
    exports2.isLastChild = isLastChild;
    exports2.needsParens = needsParens;
    exports2.needsWhitespace = needsWhitespace;
    exports2.needsWhitespaceAfter = needsWhitespaceAfter;
    exports2.needsWhitespaceBefore = needsWhitespaceBefore;
    var whitespace = require_whitespace();
    var parens = require_parentheses();
    var _t = require_lib4();
    var {
      FLIPPED_ALIAS_KEYS,
      VISITOR_KEYS,
      isCallExpression,
      isDecorator,
      isExpressionStatement,
      isMemberExpression,
      isNewExpression,
      isParenthesizedExpression
    } = _t;
    var TokenContext = exports2.TokenContext = {
      expressionStatement: 1,
      arrowBody: 2,
      exportDefault: 4,
      forHead: 8,
      forInHead: 16,
      forOfHead: 32,
      arrowFlowReturnType: 64
    };
    function expandAliases(obj) {
      const map = /* @__PURE__ */ new Map();
      function add(type, func) {
        const fn = map.get(type);
        map.set(type, fn ? function(node, parent, stack, inForInit, getRawIdentifier) {
          var _fn;
          return (_fn = fn(node, parent, stack, inForInit, getRawIdentifier)) != null ? _fn : func(node, parent, stack, inForInit, getRawIdentifier);
        } : func);
      }
      for (const type of Object.keys(obj)) {
        const aliases = FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          for (const alias of aliases) {
            add(alias, obj[type]);
          }
        } else {
          add(type, obj[type]);
        }
      }
      return map;
    }
    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
    function isOrHasCallExpression(node) {
      if (isCallExpression(node)) {
        return true;
      }
      return isMemberExpression(node) && isOrHasCallExpression(node.object);
    }
    function needsWhitespace(node, parent, type) {
      var _expandedWhitespaceNo;
      if (!node) return false;
      if (isExpressionStatement(node)) {
        node = node.expression;
      }
      const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? void 0 : _expandedWhitespaceNo(node, parent);
      if (typeof flag === "number") {
        return (flag & type) !== 0;
      }
      return false;
    }
    function needsWhitespaceBefore(node, parent) {
      return needsWhitespace(node, parent, 1);
    }
    function needsWhitespaceAfter(node, parent) {
      return needsWhitespace(node, parent, 2);
    }
    function needsParens(node, parent, tokenContext, inForInit, getRawIdentifier) {
      var _expandedParens$get;
      if (!parent) return false;
      if (isNewExpression(parent) && parent.callee === node) {
        if (isOrHasCallExpression(node)) return true;
      }
      if (isDecorator(parent)) {
        return !isDecoratorMemberExpression(node) && !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression(node);
      }
      return (_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, tokenContext, inForInit, getRawIdentifier);
    }
    function isDecoratorMemberExpression(node) {
      switch (node.type) {
        case "Identifier":
          return true;
        case "MemberExpression":
          return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
        default:
          return false;
      }
    }
    function isLastChild(parent, child) {
      const visitorKeys = VISITOR_KEYS[parent.type];
      for (let i = visitorKeys.length - 1; i >= 0; i--) {
        const val = parent[visitorKeys[i]];
        if (val === child) {
          return true;
        } else if (Array.isArray(val)) {
          let j = val.length - 1;
          while (j >= 0 && val[j] === null) j--;
          return j >= 0 && val[j] === child;
        } else if (val) {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/generator/lib/token-map.js
var require_token_map = __commonJS({
  "node_modules/@babel/generator/lib/token-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenMap = void 0;
    var _t = require_lib4();
    var {
      traverseFast,
      VISITOR_KEYS
    } = _t;
    var TokenMap = class {
      constructor(ast, tokens, source) {
        this._tokens = void 0;
        this._source = void 0;
        this._nodesToTokenIndexes = /* @__PURE__ */ new Map();
        this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map();
        this._tokensCache = /* @__PURE__ */ new Map();
        this._tokens = tokens;
        this._source = source;
        traverseFast(ast, (node) => {
          const indexes = this._getTokensIndexesOfNode(node);
          if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);
        });
        this._tokensCache = null;
      }
      has(node) {
        return this._nodesToTokenIndexes.has(node);
      }
      getIndexes(node) {
        return this._nodesToTokenIndexes.get(node);
      }
      find(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (let k = 0; k < indexes.length; k++) {
            const index = indexes[k];
            const tok = this._tokens[index];
            if (condition(tok, index)) return tok;
          }
        }
        return null;
      }
      findLastIndex(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (let k = indexes.length - 1; k >= 0; k--) {
            const index = indexes[k];
            const tok = this._tokens[index];
            if (condition(tok, index)) return index;
          }
        }
        return -1;
      }
      findMatching(node, test, occurrenceCount = 0) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          let i = 0;
          const count = occurrenceCount;
          if (count > 1) {
            const cache = this._nodesOccurrencesCountCache.get(node);
            if (cache && cache.test === test && cache.count < count) {
              i = cache.i + 1;
              occurrenceCount -= cache.count + 1;
            }
          }
          for (; i < indexes.length; i++) {
            const tok = this._tokens[indexes[i]];
            if (this.matchesOriginal(tok, test)) {
              if (occurrenceCount === 0) {
                if (count > 0) {
                  this._nodesOccurrencesCountCache.set(node, {
                    test,
                    count,
                    i
                  });
                }
                return tok;
              }
              occurrenceCount--;
            }
          }
        }
        return null;
      }
      matchesOriginal(token, test) {
        if (token.end - token.start !== test.length) return false;
        if (token.value != null) return token.value === test;
        return this._source.startsWith(test, token.start);
      }
      startMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        const tok = this._tokens[indexes[0]];
        if (tok.start !== node.start) return false;
        return this.matchesOriginal(tok, test);
      }
      endMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        const tok = this._tokens[indexes[indexes.length - 1]];
        if (tok.end !== node.end) return false;
        return this.matchesOriginal(tok, test);
      }
      _getTokensIndexesOfNode(node) {
        if (node.start == null || node.end == null) return [];
        const {
          first,
          last
        } = this._findTokensOfNode(node, 0, this._tokens.length - 1);
        let low = first;
        const children = childrenIterator(node);
        if ((node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration && node.declaration.type === "ClassDeclaration") {
          children.next();
        }
        const indexes = [];
        for (const child of children) {
          if (child == null) continue;
          if (child.start == null || child.end == null) continue;
          const childTok = this._findTokensOfNode(child, low, last);
          const high = childTok.first;
          for (let k = low; k < high; k++) indexes.push(k);
          low = childTok.last + 1;
        }
        for (let k = low; k <= last; k++) indexes.push(k);
        return indexes;
      }
      _findTokensOfNode(node, low, high) {
        const cached = this._tokensCache.get(node);
        if (cached) return cached;
        const first = this._findFirstTokenOfNode(node.start, low, high);
        const last = this._findLastTokenOfNode(node.end, first, high);
        this._tokensCache.set(node, {
          first,
          last
        });
        return {
          first,
          last
        };
      }
      _findFirstTokenOfNode(start, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (start < this._tokens[mid].start) {
            high = mid - 1;
          } else if (start > this._tokens[mid].start) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return low;
      }
      _findLastTokenOfNode(end, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (end < this._tokens[mid].end) {
            high = mid - 1;
          } else if (end > this._tokens[mid].end) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return high;
      }
    };
    exports2.TokenMap = TokenMap;
    function* childrenIterator(node) {
      if (node.type === "TemplateLiteral") {
        yield node.quasis[0];
        for (let i = 1; i < node.quasis.length; i++) {
          yield node.expressions[i - 1];
          yield node.quasis[i];
        }
        return;
      }
      const keys = VISITOR_KEYS[node.type];
      for (const key of keys) {
        const child = node[key];
        if (!child) continue;
        if (Array.isArray(child)) {
          yield* child;
        } else {
          yield child;
        }
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals = __commonJS({
  "node_modules/@babel/generator/lib/generators/template-literals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    exports2.TemplateElement = TemplateElement;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2._printTemplate = _printTemplate;
    function TaggedTemplateExpression(node) {
      this.print(node.tag);
      {
        this.print(node.typeParameters);
      }
      this.print(node.quasi);
    }
    function TemplateElement() {
      throw new Error("TemplateElement printing is handled in TemplateLiteral");
    }
    function _printTemplate(node, substitutions) {
      const quasis = node.quasis;
      let partRaw = "`";
      for (let i = 0; i < quasis.length - 1; i++) {
        partRaw += quasis[i].value.raw;
        this.token(partRaw + "${", true);
        this.print(substitutions[i]);
        partRaw = "}";
        if (this.tokenMap) {
          const token = this.tokenMap.findMatching(node, "}", i);
          if (token) this._catchUpTo(token.loc.start);
        }
      }
      partRaw += quasis[quasis.length - 1].value.raw;
      this.token(partRaw + "`", true);
    }
    function TemplateLiteral(node) {
      this._printTemplate(node, node.expressions);
    }
  }
});

// node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions = __commonJS({
  "node_modules/@babel/generator/lib/generators/expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LogicalExpression = exports2.BinaryExpression = exports2.AssignmentExpression = AssignmentExpression;
    exports2.AssignmentPattern = AssignmentPattern;
    exports2.AwaitExpression = AwaitExpression;
    exports2.BindExpression = BindExpression;
    exports2.CallExpression = CallExpression;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.Decorator = Decorator;
    exports2.DoExpression = DoExpression;
    exports2.EmptyStatement = EmptyStatement;
    exports2.ExpressionStatement = ExpressionStatement;
    exports2.Import = Import;
    exports2.MemberExpression = MemberExpression;
    exports2.MetaProperty = MetaProperty;
    exports2.ModuleExpression = ModuleExpression;
    exports2.NewExpression = NewExpression;
    exports2.OptionalCallExpression = OptionalCallExpression;
    exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.PrivateName = PrivateName;
    exports2.SequenceExpression = SequenceExpression;
    exports2.Super = Super;
    exports2.ThisExpression = ThisExpression;
    exports2.UnaryExpression = UnaryExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    exports2.YieldExpression = YieldExpression;
    exports2._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
    var _t = require_lib4();
    var _index = require_node2();
    var {
      isCallExpression,
      isLiteral,
      isMemberExpression,
      isNewExpression,
      isPattern
    } = _t;
    function UnaryExpression(node) {
      const {
        operator
      } = node;
      if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
        this.word(operator);
        this.space();
      } else {
        this.token(operator);
      }
      this.print(node.argument);
    }
    function DoExpression(node) {
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      this.word("do");
      this.space();
      this.print(node.body);
    }
    function ParenthesizedExpression(node) {
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.print(node.expression);
      exit();
      this.rightParens(node);
    }
    function UpdateExpression(node) {
      if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument);
      } else {
        this.print(node.argument, true);
        this.token(node.operator);
      }
    }
    function ConditionalExpression(node) {
      this.print(node.test);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node.consequent);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node.alternate);
    }
    function NewExpression(node, parent) {
      this.word("new");
      this.space();
      this.print(node.callee);
      if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
        callee: node
      }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
        return;
      }
      this.print(node.typeArguments);
      {
        this.print(node.typeParameters);
      }
      if (node.optional) {
        this.token("?.");
      }
      if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ")")) {
        return;
      }
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node);
    }
    function SequenceExpression(node) {
      this.printList(node.expressions);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function _shouldPrintDecoratorsBeforeExport(node) {
      if (typeof this.format.decoratorsBeforeExport === "boolean") {
        return this.format.decoratorsBeforeExport;
      }
      return typeof node.start === "number" && node.start === node.declaration.start;
    }
    function Decorator(node) {
      this.tokenChar(64);
      this.print(node.expression);
      this.newline();
    }
    function OptionalMemberExpression(node) {
      let {
        computed
      } = node;
      const {
        optional,
        property
      } = node;
      this.print(node.object);
      if (!computed && isMemberExpression(property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      if (isLiteral(property) && typeof property.value === "number") {
        computed = true;
      }
      if (optional) {
        this.token("?.");
      }
      if (computed) {
        this.tokenChar(91);
        this.print(property);
        this.tokenChar(93);
      } else {
        if (!optional) {
          this.tokenChar(46);
        }
        this.print(property);
      }
    }
    function OptionalCallExpression(node) {
      this.print(node.callee);
      {
        this.print(node.typeParameters);
      }
      if (node.optional) {
        this.token("?.");
      }
      this.print(node.typeArguments);
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments);
      exit();
      this.rightParens(node);
    }
    function CallExpression(node) {
      this.print(node.callee);
      this.print(node.typeArguments);
      {
        this.print(node.typeParameters);
      }
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node);
    }
    function Import() {
      this.word("import");
    }
    function AwaitExpression(node) {
      this.word("await");
      if (node.argument) {
        this.space();
        this.printTerminatorless(node.argument);
      }
    }
    function YieldExpression(node) {
      this.word("yield", true);
      if (node.delegate) {
        this.tokenChar(42);
        if (node.argument) {
          this.space();
          this.print(node.argument);
        }
      } else {
        if (node.argument) {
          this.space();
          this.printTerminatorless(node.argument);
        }
      }
    }
    function EmptyStatement() {
      this.semicolon(true);
    }
    function ExpressionStatement(node) {
      this.tokenContext |= _index.TokenContext.expressionStatement;
      this.print(node.expression);
      this.semicolon();
    }
    function AssignmentPattern(node) {
      this.print(node.left);
      if (node.left.type === "Identifier" || isPattern(node.left)) {
        if (node.left.optional) this.tokenChar(63);
        this.print(node.left.typeAnnotation);
      }
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.right);
    }
    function AssignmentExpression(node) {
      this.print(node.left);
      this.space();
      if (node.operator === "in" || node.operator === "instanceof") {
        this.word(node.operator);
      } else {
        this.token(node.operator);
        this._endsWithDiv = node.operator === "/";
      }
      this.space();
      this.print(node.right);
    }
    function BindExpression(node) {
      this.print(node.object);
      this.token("::");
      this.print(node.callee);
    }
    function MemberExpression(node) {
      this.print(node.object);
      if (!node.computed && isMemberExpression(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      let computed = node.computed;
      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }
      if (computed) {
        const exit = this.enterDelimited();
        this.tokenChar(91);
        this.print(node.property);
        this.tokenChar(93);
        exit();
      } else {
        this.tokenChar(46);
        this.print(node.property);
      }
    }
    function MetaProperty(node) {
      this.print(node.meta);
      this.tokenChar(46);
      this.print(node.property);
    }
    function PrivateName(node) {
      this.tokenChar(35);
      this.print(node.id);
    }
    function V8IntrinsicIdentifier(node) {
      this.tokenChar(37);
      this.word(node.name);
    }
    function ModuleExpression(node) {
      this.word("module", true);
      this.space();
      this.tokenChar(123);
      this.indent();
      const {
        body
      } = node;
      if (body.body.length || body.directives.length) {
        this.newline();
      }
      this.print(body);
      this.dedent();
      this.rightBrace(node);
    }
  }
});

// node_modules/@babel/generator/lib/generators/statements.js
var require_statements = __commonJS({
  "node_modules/@babel/generator/lib/generators/statements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BreakStatement = BreakStatement;
    exports2.CatchClause = CatchClause;
    exports2.ContinueStatement = ContinueStatement;
    exports2.DebuggerStatement = DebuggerStatement;
    exports2.DoWhileStatement = DoWhileStatement;
    exports2.ForOfStatement = exports2.ForInStatement = void 0;
    exports2.ForStatement = ForStatement;
    exports2.IfStatement = IfStatement;
    exports2.LabeledStatement = LabeledStatement;
    exports2.ReturnStatement = ReturnStatement;
    exports2.SwitchCase = SwitchCase;
    exports2.SwitchStatement = SwitchStatement;
    exports2.ThrowStatement = ThrowStatement;
    exports2.TryStatement = TryStatement;
    exports2.VariableDeclaration = VariableDeclaration;
    exports2.VariableDeclarator = VariableDeclarator;
    exports2.WhileStatement = WhileStatement;
    exports2.WithStatement = WithStatement;
    var _t = require_lib4();
    var _index = require_node2();
    var {
      isFor,
      isForStatement,
      isIfStatement,
      isStatement
    } = _t;
    function WithStatement(node) {
      this.word("with");
      this.space();
      this.tokenChar(40);
      this.print(node.object);
      this.tokenChar(41);
      this.printBlock(node);
    }
    function IfStatement(node) {
      this.word("if");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.space();
      const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
      if (needsBlock) {
        this.tokenChar(123);
        this.newline();
        this.indent();
      }
      this.printAndIndentOnComments(node.consequent);
      if (needsBlock) {
        this.dedent();
        this.newline();
        this.tokenChar(125);
      }
      if (node.alternate) {
        if (this.endsWith(125)) this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node.alternate);
      }
    }
    function getLastStatement(statement) {
      const {
        body
      } = statement;
      if (isStatement(body) === false) {
        return statement;
      }
      return getLastStatement(body);
    }
    function ForStatement(node) {
      this.word("for");
      this.space();
      this.tokenChar(40);
      {
        const exit = this.enterForStatementInit();
        this.tokenContext |= _index.TokenContext.forHead;
        this.print(node.init);
        exit();
      }
      this.tokenChar(59);
      if (node.test) {
        this.space();
        this.print(node.test);
      }
      this.token(";", false, 1);
      if (node.update) {
        this.space();
        this.print(node.update);
      }
      this.tokenChar(41);
      this.printBlock(node);
    }
    function WhileStatement(node) {
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.printBlock(node);
    }
    function ForXStatement(node) {
      this.word("for");
      this.space();
      const isForOf = node.type === "ForOfStatement";
      if (isForOf && node.await) {
        this.word("await");
        this.space();
      }
      this.noIndentInnerCommentsHere();
      this.tokenChar(40);
      {
        const exit = isForOf ? null : this.enterForStatementInit();
        this.tokenContext |= isForOf ? _index.TokenContext.forOfHead : _index.TokenContext.forInHead;
        this.print(node.left);
        exit == null || exit();
      }
      this.space();
      this.word(isForOf ? "of" : "in");
      this.space();
      this.print(node.right);
      this.tokenChar(41);
      this.printBlock(node);
    }
    var ForInStatement = exports2.ForInStatement = ForXStatement;
    var ForOfStatement = exports2.ForOfStatement = ForXStatement;
    function DoWhileStatement(node) {
      this.word("do");
      this.space();
      this.print(node.body);
      this.space();
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.semicolon();
    }
    function printStatementAfterKeyword(printer, node) {
      if (node) {
        printer.space();
        printer.printTerminatorless(node);
      }
      printer.semicolon();
    }
    function BreakStatement(node) {
      this.word("break");
      printStatementAfterKeyword(this, node.label);
    }
    function ContinueStatement(node) {
      this.word("continue");
      printStatementAfterKeyword(this, node.label);
    }
    function ReturnStatement(node) {
      this.word("return");
      printStatementAfterKeyword(this, node.argument);
    }
    function ThrowStatement(node) {
      this.word("throw");
      printStatementAfterKeyword(this, node.argument);
    }
    function LabeledStatement(node) {
      this.print(node.label);
      this.tokenChar(58);
      this.space();
      this.print(node.body);
    }
    function TryStatement(node) {
      this.word("try");
      this.space();
      this.print(node.block);
      this.space();
      if (node.handlers) {
        this.print(node.handlers[0]);
      } else {
        this.print(node.handler);
      }
      if (node.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node.finalizer);
      }
    }
    function CatchClause(node) {
      this.word("catch");
      this.space();
      if (node.param) {
        this.tokenChar(40);
        this.print(node.param);
        this.print(node.param.typeAnnotation);
        this.tokenChar(41);
        this.space();
      }
      this.print(node.body);
    }
    function SwitchStatement(node) {
      this.word("switch");
      this.space();
      this.tokenChar(40);
      this.print(node.discriminant);
      this.tokenChar(41);
      this.space();
      this.tokenChar(123);
      this.printSequence(node.cases, true, void 0, function addNewlines(leading, cas) {
        if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
      });
      this.rightBrace(node);
    }
    function SwitchCase(node) {
      if (node.test) {
        this.word("case");
        this.space();
        this.print(node.test);
        this.tokenChar(58);
      } else {
        this.word("default");
        this.tokenChar(58);
      }
      if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, true);
      }
    }
    function DebuggerStatement() {
      this.word("debugger");
      this.semicolon();
    }
    function VariableDeclaration(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      const {
        kind
      } = node;
      if (kind === "await using") {
        this.word("await");
        this.space();
        this.word("using", true);
      } else {
        this.word(kind, kind === "using");
      }
      this.space();
      let hasInits = false;
      if (!isFor(parent)) {
        for (const declar of node.declarations) {
          if (declar.init) {
            hasInits = true;
          }
        }
      }
      this.printList(node.declarations, void 0, void 0, node.declarations.length > 1, hasInits ? function(occurrenceCount) {
        this.token(",", false, occurrenceCount);
        this.newline();
      } : void 0);
      if (isFor(parent)) {
        if (isForStatement(parent)) {
          if (parent.init === node) return;
        } else {
          if (parent.left === node) return;
        }
      }
      this.semicolon();
    }
    function VariableDeclarator(node) {
      this.print(node.id);
      if (node.definite) this.tokenChar(33);
      this.print(node.id.typeAnnotation);
      if (node.init) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.init);
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/classes.js
var require_classes = __commonJS({
  "node_modules/@babel/generator/lib/generators/classes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ClassAccessorProperty = ClassAccessorProperty;
    exports2.ClassBody = ClassBody;
    exports2.ClassExpression = exports2.ClassDeclaration = ClassDeclaration;
    exports2.ClassMethod = ClassMethod;
    exports2.ClassPrivateMethod = ClassPrivateMethod;
    exports2.ClassPrivateProperty = ClassPrivateProperty;
    exports2.ClassProperty = ClassProperty;
    exports2.StaticBlock = StaticBlock;
    exports2._classMethodHead = _classMethodHead;
    var _t = require_lib4();
    var {
      isExportDefaultDeclaration,
      isExportNamedDeclaration
    } = _t;
    function ClassDeclaration(node, parent) {
      const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
      if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
        this.printJoin(node.decorators);
      }
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("class");
      if (node.id) {
        this.space();
        this.print(node.id);
      }
      this.print(node.typeParameters);
      if (node.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.superClass);
        this.print(node.superTypeParameters);
      }
      if (node.implements) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node.implements);
      }
      this.space();
      this.print(node.body);
    }
    function ClassBody(node) {
      this.tokenChar(123);
      if (node.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        const separator = classBodyEmptySemicolonsPrinter(this, node);
        separator == null || separator(-1);
        const exit = this.enterDelimited();
        this.printJoin(node.body, true, true, separator, true);
        exit();
        if (!this.endsWith(10)) this.newline();
        this.rightBrace(node);
      }
    }
    function classBodyEmptySemicolonsPrinter(printer, node) {
      if (!printer.tokenMap || node.start == null || node.end == null) {
        return null;
      }
      const indexes = printer.tokenMap.getIndexes(node);
      if (!indexes) return null;
      let k = 1;
      let occurrenceCount = 0;
      let nextLocIndex = 0;
      const advanceNextLocIndex = () => {
        while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {
          nextLocIndex++;
        }
      };
      advanceNextLocIndex();
      return (i) => {
        if (nextLocIndex <= i) {
          nextLocIndex = i + 1;
          advanceNextLocIndex();
        }
        const end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;
        let tok;
        while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end) {
          printer.token(";", void 0, occurrenceCount++);
          k++;
        }
      };
    }
    function ClassProperty(node) {
      this.printJoin(node.decorators);
      if (!node.static && !this.format.preserveFormat) {
        var _node$key$loc;
        const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node);
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        this._variance(node);
        this.print(node.key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassAccessorProperty(node) {
      var _node$key$loc2;
      this.printJoin(node.decorators);
      const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
      if (endLine) this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node);
      this.word("accessor", true);
      this.space();
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        this._variance(node);
        this.print(node.key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassPrivateProperty(node) {
      this.printJoin(node.decorators);
      this.tsPrintClassMemberModifiers(node);
      this.print(node.key);
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body);
    }
    function ClassPrivateMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body);
    }
    function _classMethodHead(node) {
      this.printJoin(node.decorators);
      if (!this.format.preserveFormat) {
        var _node$key$loc3;
        const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node);
      this._methodHead(node);
    }
    function StaticBlock(node) {
      this.word("static");
      this.space();
      this.tokenChar(123);
      if (node.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        this.printSequence(node.body, true);
        this.rightBrace(node);
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/methods.js
var require_methods = __commonJS({
  "node_modules/@babel/generator/lib/generators/methods.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArrowFunctionExpression = ArrowFunctionExpression;
    exports2.FunctionDeclaration = exports2.FunctionExpression = FunctionExpression;
    exports2._functionHead = _functionHead;
    exports2._methodHead = _methodHead;
    exports2._param = _param;
    exports2._parameters = _parameters;
    exports2._params = _params;
    exports2._predicate = _predicate;
    exports2._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
    var _t = require_lib4();
    var _index = require_node2();
    var {
      isIdentifier
    } = _t;
    function _params(node, idNode, parentNode) {
      this.print(node.typeParameters);
      const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
      if (nameInfo) {
        this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
      }
      this.tokenChar(40);
      this._parameters(node.params, ")");
      const noLineTerminator = node.type === "ArrowFunctionExpression";
      this.print(node.returnType, noLineTerminator);
      this._noLineTerminator = noLineTerminator;
    }
    function _parameters(parameters, endToken) {
      const exit = this.enterDelimited();
      const trailingComma = this.shouldPrintTrailingComma(endToken);
      const paramLength = parameters.length;
      for (let i = 0; i < paramLength; i++) {
        this._param(parameters[i]);
        if (trailingComma || i < paramLength - 1) {
          this.token(",", null, i);
          this.space();
        }
      }
      this.token(endToken);
      exit();
    }
    function _param(parameter) {
      this.printJoin(parameter.decorators);
      this.print(parameter);
      if (parameter.optional) {
        this.tokenChar(63);
      }
      this.print(parameter.typeAnnotation);
    }
    function _methodHead(node) {
      const kind = node.kind;
      const key = node.key;
      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      if (kind === "method" || kind === "init") {
        if (node.generator) {
          this.tokenChar(42);
        }
      }
      if (node.computed) {
        this.tokenChar(91);
        this.print(key);
        this.tokenChar(93);
      } else {
        this.print(key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      this._params(node, node.computed && node.key.type !== "StringLiteral" ? void 0 : node.key, void 0);
    }
    function _predicate(node, noLineTerminatorAfter) {
      if (node.predicate) {
        if (!node.returnType) {
          this.tokenChar(58);
        }
        this.space();
        this.print(node.predicate, noLineTerminatorAfter);
      }
    }
    function _functionHead(node, parent) {
      if (node.async) {
        this.word("async");
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.space();
      }
      this.word("function");
      if (node.generator) {
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.tokenChar(42);
      }
      this.space();
      if (node.id) {
        this.print(node.id);
      }
      this._params(node, node.id, parent);
      if (node.type !== "TSDeclareFunction") {
        this._predicate(node);
      }
    }
    function FunctionExpression(node, parent) {
      this._functionHead(node, parent);
      this.space();
      this.print(node.body);
    }
    function ArrowFunctionExpression(node, parent) {
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      if (this._shouldPrintArrowParamsParens(node)) {
        this._params(node, void 0, parent);
      } else {
        this.print(node.params[0], true);
      }
      this._predicate(node, true);
      this.space();
      this.printInnerComments();
      this.token("=>");
      this.space();
      this.tokenContext |= _index.TokenContext.arrowBody;
      this.print(node.body);
    }
    function _shouldPrintArrowParamsParens(node) {
      var _firstParam$leadingCo, _firstParam$trailingC;
      if (node.params.length !== 1) return true;
      if (node.typeParameters || node.returnType || node.predicate) {
        return true;
      }
      const firstParam = node.params[0];
      if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
        return true;
      }
      if (this.tokenMap) {
        if (node.loc == null) return true;
        if (this.tokenMap.findMatching(node, "(") !== null) return true;
        const arrowToken = this.tokenMap.findMatching(node, "=>");
        if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;
        return arrowToken.loc.start.line !== node.loc.start.line;
      }
      if (this.format.retainLines) return true;
      return false;
    }
    function _getFuncIdName(idNode, parent) {
      let id = idNode;
      if (!id && parent) {
        const parentType = parent.type;
        if (parentType === "VariableDeclarator") {
          id = parent.id;
        } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
          id = parent.left;
        } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
          if (!parent.computed || parent.key.type === "StringLiteral") {
            id = parent.key;
          }
        } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
          id = parent.key;
        }
      }
      if (!id) return;
      let nameInfo;
      if (id.type === "Identifier") {
        var _id$loc, _id$loc2;
        nameInfo = {
          pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
          name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
        };
      } else if (id.type === "PrivateName") {
        var _id$loc3;
        nameInfo = {
          pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
          name: "#" + id.id.name
        };
      } else if (id.type === "StringLiteral") {
        var _id$loc4;
        nameInfo = {
          pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
          name: id.value
        };
      }
      return nameInfo;
    }
  }
});

// node_modules/@babel/generator/lib/generators/modules.js
var require_modules = __commonJS({
  "node_modules/@babel/generator/lib/generators/modules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExportAllDeclaration = ExportAllDeclaration;
    exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
    exports2.ExportDefaultSpecifier = ExportDefaultSpecifier;
    exports2.ExportNamedDeclaration = ExportNamedDeclaration;
    exports2.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    exports2.ExportSpecifier = ExportSpecifier;
    exports2.ImportAttribute = ImportAttribute;
    exports2.ImportDeclaration = ImportDeclaration;
    exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
    exports2.ImportExpression = ImportExpression;
    exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    exports2.ImportSpecifier = ImportSpecifier;
    exports2._printAttributes = _printAttributes;
    var _t = require_lib4();
    var _index = require_node2();
    var {
      isClassDeclaration,
      isExportDefaultSpecifier,
      isExportNamespaceSpecifier,
      isImportDefaultSpecifier,
      isImportNamespaceSpecifier,
      isStatement
    } = _t;
    function ImportSpecifier(node) {
      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }
      this.print(node.imported);
      if (node.local && node.local.name !== node.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.local);
      }
    }
    function ImportDefaultSpecifier(node) {
      this.print(node.local);
    }
    function ExportDefaultSpecifier(node) {
      this.print(node.exported);
    }
    function ExportSpecifier(node) {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.print(node.local);
      if (node.exported && node.local.name !== node.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.exported);
      }
    }
    function ExportNamespaceSpecifier(node) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported);
    }
    var warningShown = false;
    function _printAttributes(node, hasPreviousBrace) {
      const {
        importAttributesKeyword
      } = this.format;
      const {
        attributes,
        assertions
      } = node;
      if (attributes && !importAttributesKeyword && !warningShown) {
        warningShown = true;
        console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
      }
      const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
      this.word(useAssertKeyword ? "assert" : "with");
      this.space();
      if (!useAssertKeyword && importAttributesKeyword !== "with") {
        this.printList(attributes || assertions);
        return;
      }
      const occurrenceCount = hasPreviousBrace ? 1 : 0;
      this.token("{", null, occurrenceCount);
      this.space();
      this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
      this.space();
      this.token("}", null, occurrenceCount);
    }
    function ExportAllDeclaration(node) {
      var _node$attributes, _node$assertions;
      this.word("export");
      this.space();
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.tokenChar(42);
      this.space();
      this.word("from");
      this.space();
      if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, false);
      } else {
        this.print(node.source);
      }
      this.semicolon();
    }
    function maybePrintDecoratorsBeforeExport(printer, node) {
      if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
        printer.printJoin(node.declaration.decorators);
      }
    }
    function ExportNamedDeclaration(node) {
      maybePrintDecoratorsBeforeExport(this, node);
      this.word("export");
      this.space();
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        if (!isStatement(declar)) this.semicolon();
      } else {
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        const specifiers = node.specifiers.slice(0);
        let hasSpecial = false;
        for (; ; ) {
          const first = specifiers[0];
          if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
            hasSpecial = true;
            this.print(specifiers.shift());
            if (specifiers.length) {
              this.tokenChar(44);
              this.space();
            }
          } else {
            break;
          }
        }
        let hasBrace = false;
        if (specifiers.length || !specifiers.length && !hasSpecial) {
          hasBrace = true;
          this.tokenChar(123);
          if (specifiers.length) {
            this.space();
            this.printList(specifiers, this.shouldPrintTrailingComma("}"));
            this.space();
          }
          this.tokenChar(125);
        }
        if (node.source) {
          var _node$attributes2, _node$assertions2;
          this.space();
          this.word("from");
          this.space();
          if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {
            this.print(node.source, true);
            this.space();
            this._printAttributes(node, hasBrace);
          } else {
            this.print(node.source);
          }
        }
        this.semicolon();
      }
    }
    function ExportDefaultDeclaration(node) {
      maybePrintDecoratorsBeforeExport(this, node);
      this.word("export");
      this.noIndentInnerCommentsHere();
      this.space();
      this.word("default");
      this.space();
      this.tokenContext |= _index.TokenContext.exportDefault;
      const declar = node.declaration;
      this.print(declar);
      if (!isStatement(declar)) this.semicolon();
    }
    function ImportDeclaration(node) {
      var _node$attributes3, _node$assertions3;
      this.word("import");
      this.space();
      const isTypeKind = node.importKind === "type" || node.importKind === "typeof";
      if (isTypeKind) {
        this.noIndentInnerCommentsHere();
        this.word(node.importKind);
        this.space();
      } else if (node.module) {
        this.noIndentInnerCommentsHere();
        this.word("module");
        this.space();
      } else if (node.phase) {
        this.noIndentInnerCommentsHere();
        this.word(node.phase);
        this.space();
      }
      const specifiers = node.specifiers.slice(0);
      const hasSpecifiers = !!specifiers.length;
      while (hasSpecifiers) {
        const first = specifiers[0];
        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      let hasBrace = false;
      if (specifiers.length) {
        hasBrace = true;
        this.tokenChar(123);
        this.space();
        this.printList(specifiers, this.shouldPrintTrailingComma("}"));
        this.space();
        this.tokenChar(125);
      } else if (isTypeKind && !hasSpecifiers) {
        hasBrace = true;
        this.tokenChar(123);
        this.tokenChar(125);
      }
      if (hasSpecifiers || isTypeKind) {
        this.space();
        this.word("from");
        this.space();
      }
      if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, hasBrace);
      } else {
        this.print(node.source);
      }
      this.semicolon();
    }
    function ImportAttribute(node) {
      this.print(node.key);
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ImportNamespaceSpecifier(node) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node.local);
    }
    function ImportExpression(node) {
      this.word("import");
      if (node.phase) {
        this.tokenChar(46);
        this.word(node.phase);
      }
      this.tokenChar(40);
      this.print(node.source);
      if (node.options != null) {
        this.tokenChar(44);
        this.space();
        this.print(node.options);
      }
      this.tokenChar(41);
    }
  }
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/jsesc/jsesc.js"(exports2, module2) {
    "use strict";
    var object = {};
    var hasOwnProperty2 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty2.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach = (array, callback) => {
      const length = array.length;
      let index = -1;
      while (++index < length) {
        callback(array[index]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase) return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString = object.toString;
    var isArray = Array.isArray;
    var isBuffer = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject = (value) => {
      return toString.call(value) == "[object Object]";
    };
    var isString = (value) => {
      return typeof value == "string" || toString.call(value) == "[object String]";
    };
    var isNumber = (value) => {
      return typeof value == "number" || toString.call(value) == "[object Number]";
    };
    var isBigInt = (value) => {
      return typeof value == "bigint";
    };
    var isFunction = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
      // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
      // '\v': '\\x0B'
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };
      const defaults = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json = options && options.json;
      if (json) {
        defaults.quotes = "double";
        defaults.wrap = true;
      }
      options = extend(defaults, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json && argument && isFunction(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isBuffer(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isArray(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push(
              (compact || inline2 ? "" : indent) + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber(argument) || isBigInt(argument)) {
          if (json) {
            return JSON.stringify(Number(argument));
          }
          let result2;
          if (useDecNumbers) {
            result2 = String(argument);
          } else if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            result2 = "0x" + hexadecimal2;
          } else if (useBinNumbers) {
            result2 = "0b" + argument.toString(2);
          } else if (useOctNumbers) {
            result2 = "0o" + argument.toString(8);
          }
          if (isBigInt(argument)) {
            return result2 + "n";
          }
          return result2;
        } else if (isBigInt(argument)) {
          if (json) {
            return JSON.stringify(Number(argument));
          }
          return argument + "n";
        } else if (!isObject(argument)) {
          if (json) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push(
              (compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options.minimal) return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json && !regexDigit.test(string.charAt(index + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc.version = "3.0.2";
    module2.exports = jsesc;
  }
});

// node_modules/@babel/generator/lib/generators/types.js
var require_types = __commonJS({
  "node_modules/@babel/generator/lib/generators/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArgumentPlaceholder = ArgumentPlaceholder;
    exports2.ArrayPattern = exports2.ArrayExpression = ArrayExpression;
    exports2.BigIntLiteral = BigIntLiteral;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.Identifier = Identifier;
    exports2.NullLiteral = NullLiteral;
    exports2.NumericLiteral = NumericLiteral;
    exports2.ObjectPattern = exports2.ObjectExpression = ObjectExpression;
    exports2.ObjectMethod = ObjectMethod;
    exports2.ObjectProperty = ObjectProperty;
    exports2.PipelineBareFunction = PipelineBareFunction;
    exports2.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
    exports2.PipelineTopicExpression = PipelineTopicExpression;
    exports2.RecordExpression = RecordExpression;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.SpreadElement = exports2.RestElement = RestElement;
    exports2.StringLiteral = StringLiteral;
    exports2.TopicReference = TopicReference;
    exports2.TupleExpression = TupleExpression;
    exports2._getRawIdentifier = _getRawIdentifier;
    var _t = require_lib4();
    var _jsesc = require_jsesc();
    var {
      isAssignmentPattern,
      isIdentifier
    } = _t;
    var lastRawIdentNode = null;
    var lastRawIdentResult = "";
    function _getRawIdentifier(node) {
      if (node === lastRawIdentNode) return lastRawIdentResult;
      lastRawIdentNode = node;
      const {
        name
      } = node;
      const token = this.tokenMap.find(node, (tok) => tok.value === name);
      if (token) {
        lastRawIdentResult = this._originalCode.slice(token.start, token.end);
        return lastRawIdentResult;
      }
      return lastRawIdentResult = node.name;
    }
    function Identifier(node) {
      var _node$loc;
      this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);
      this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
    }
    function ArgumentPlaceholder() {
      this.tokenChar(63);
    }
    function RestElement(node) {
      this.token("...");
      this.print(node.argument);
    }
    function ObjectExpression(node) {
      const props = node.properties;
      this.tokenChar(123);
      if (props.length) {
        const exit = this.enterDelimited();
        this.space();
        this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
        this.space();
        exit();
      }
      this.sourceWithOffset("end", node.loc, -1);
      this.tokenChar(125);
    }
    function ObjectMethod(node) {
      this.printJoin(node.decorators);
      this._methodHead(node);
      this.space();
      this.print(node.body);
    }
    function ObjectProperty(node) {
      this.printJoin(node.decorators);
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
          this.print(node.value);
          return;
        }
        this.print(node.key);
        if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
          return;
        }
      }
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ArrayExpression(node) {
      const elems = node.elements;
      const len = elems.length;
      this.tokenChar(91);
      const exit = this.enterDelimited();
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem);
          if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
            this.token(",", false, i);
          }
        } else {
          this.token(",", false, i);
        }
      }
      exit();
      this.tokenChar(93);
    }
    function RecordExpression(node) {
      const props = node.properties;
      let startToken;
      let endToken;
      {
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "{|";
          endToken = "|}";
        } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
          throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
        } else {
          startToken = "#{";
          endToken = "}";
        }
      }
      this.token(startToken);
      if (props.length) {
        this.space();
        this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
        this.space();
      }
      this.token(endToken);
    }
    function TupleExpression(node) {
      const elems = node.elements;
      const len = elems.length;
      let startToken;
      let endToken;
      {
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "[|";
          endToken = "|]";
        } else if (this.format.recordAndTupleSyntaxType === "hash") {
          startToken = "#[";
          endToken = "]";
        } else {
          throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
        }
      }
      this.token(startToken);
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem);
          if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
            this.token(",", false, i);
          }
        }
      }
      this.token(endToken);
    }
    function RegExpLiteral(node) {
      this.word(`/${node.pattern}/${node.flags}`);
    }
    function BooleanLiteral(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral(node) {
      const raw = this.getPossibleRaw(node);
      const opts = this.format.jsescOption;
      const value = node.value;
      const str = value + "";
      if (opts.numbers) {
        this.number(_jsesc(value, opts), value);
      } else if (raw == null) {
        this.number(str, value);
      } else if (this.format.minified) {
        this.number(raw.length < str.length ? raw : str, value);
      } else {
        this.number(raw, value);
      }
    }
    function StringLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const val = _jsesc(node.value, this.format.jsescOption);
      this.token(val);
    }
    function BigIntLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node.value + "n");
    }
    var validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
    function TopicReference() {
      const {
        topicToken
      } = this.format;
      if (validTopicTokenSet.has(topicToken)) {
        this.token(topicToken);
      } else {
        const givenTopicTokenJSON = JSON.stringify(topicToken);
        const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
        throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
      }
    }
    function PipelineTopicExpression(node) {
      this.print(node.expression);
    }
    function PipelineBareFunction(node) {
      this.print(node.callee);
    }
    function PipelinePrimaryTopicReference() {
      this.tokenChar(35);
    }
  }
});

// node_modules/@babel/generator/lib/generators/flow.js
var require_flow2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/flow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AnyTypeAnnotation = AnyTypeAnnotation;
    exports2.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports2.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports2.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports2.DeclareClass = DeclareClass;
    exports2.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports2.DeclareExportDeclaration = DeclareExportDeclaration;
    exports2.DeclareFunction = DeclareFunction;
    exports2.DeclareInterface = DeclareInterface;
    exports2.DeclareModule = DeclareModule;
    exports2.DeclareModuleExports = DeclareModuleExports;
    exports2.DeclareOpaqueType = DeclareOpaqueType;
    exports2.DeclareTypeAlias = DeclareTypeAlias;
    exports2.DeclareVariable = DeclareVariable;
    exports2.DeclaredPredicate = DeclaredPredicate;
    exports2.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports2.EnumBooleanBody = EnumBooleanBody;
    exports2.EnumBooleanMember = EnumBooleanMember;
    exports2.EnumDeclaration = EnumDeclaration;
    exports2.EnumDefaultedMember = EnumDefaultedMember;
    exports2.EnumNumberBody = EnumNumberBody;
    exports2.EnumNumberMember = EnumNumberMember;
    exports2.EnumStringBody = EnumStringBody;
    exports2.EnumStringMember = EnumStringMember;
    exports2.EnumSymbolBody = EnumSymbolBody;
    exports2.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.FunctionTypeParam = FunctionTypeParam;
    exports2.IndexedAccessType = IndexedAccessType;
    exports2.InferredPredicate = InferredPredicate;
    exports2.InterfaceDeclaration = InterfaceDeclaration;
    exports2.GenericTypeAnnotation = exports2.ClassImplements = exports2.InterfaceExtends = InterfaceExtends;
    exports2.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports2.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports2.MixedTypeAnnotation = MixedTypeAnnotation;
    exports2.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    exports2.NumberTypeAnnotation = NumberTypeAnnotation;
    exports2.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports2.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports2.ObjectTypeIndexer = ObjectTypeIndexer;
    exports2.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports2.ObjectTypeProperty = ObjectTypeProperty;
    exports2.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports2.OpaqueType = OpaqueType;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports2.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports2, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    exports2.StringTypeAnnotation = StringTypeAnnotation;
    exports2.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports2.ThisTypeAnnotation = ThisTypeAnnotation;
    exports2.TupleTypeAnnotation = TupleTypeAnnotation;
    exports2.TypeAlias = TypeAlias;
    exports2.TypeAnnotation = TypeAnnotation;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.TypeParameter = TypeParameter;
    exports2.TypeParameterDeclaration = exports2.TypeParameterInstantiation = TypeParameterInstantiation;
    exports2.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.Variance = Variance;
    exports2.VoidTypeAnnotation = VoidTypeAnnotation;
    exports2._interfaceish = _interfaceish;
    exports2._variance = _variance;
    var _t = require_lib4();
    var _modules = require_modules();
    var _index = require_node2();
    var _types2 = require_types();
    var {
      isDeclareExportDeclaration,
      isStatement
    } = _t;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node) {
      this.print(node.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node);
    }
    function DeclareFunction(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation.typeAnnotation);
      if (node.predicate) {
        this.space();
        this.print(node.predicate);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node.value);
      this.tokenChar(41);
    }
    function DeclareInterface(node) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node);
    }
    function DeclareModule(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node.id);
      this.space();
      this.print(node.body);
    }
    function DeclareModuleExports(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node.typeAnnotation);
    }
    function DeclareTypeAlias(node) {
      this.word("declare");
      this.space();
      this.TypeAlias(node);
    }
    function DeclareOpaqueType(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node);
    }
    function DeclareVariable(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation);
      this.semicolon();
    }
    function DeclareExportDeclaration(node) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node);
    }
    function DeclareExportAllDeclaration(node) {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.call(this, node);
    }
    function EnumDeclaration(node) {
      const {
        id,
        body
      } = node;
      this.word("enum");
      this.space();
      this.print(id);
      this.print(body);
    }
    function enumExplicitType(context, name, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name);
      }
      context.space();
    }
    function enumBody(context, node) {
      const {
        members
      } = node;
      context.token("{");
      context.indent();
      context.newline();
      for (const member of members) {
        context.print(member);
        context.newline();
      }
      if (node.hasUnknownMembers) {
        context.token("...");
        context.newline();
      }
      context.dedent();
      context.token("}");
    }
    function EnumBooleanBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node);
    }
    function EnumNumberBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node);
    }
    function EnumStringBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node);
    }
    function EnumSymbolBody(node) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node);
    }
    function EnumDefaultedMember(node) {
      const {
        id
      } = node;
      this.print(id);
      this.tokenChar(44);
    }
    function enumInitializedMember(context, node) {
      context.print(node.id);
      context.space();
      context.token("=");
      context.space();
      context.print(node.init);
      context.token(",");
    }
    function EnumBooleanMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumNumberMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumStringMember(node) {
      enumInitializedMember(this, node);
    }
    function FlowExportDeclaration(node) {
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        if (!isStatement(declar)) this.semicolon();
      } else {
        this.tokenChar(123);
        if (node.specifiers.length) {
          this.space();
          this.printList(node.specifiers);
          this.space();
        }
        this.tokenChar(125);
        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node, parent) {
      this.print(node.typeParameters);
      this.tokenChar(40);
      if (node.this) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node.this.typeAnnotation);
        if (node.params.length || node.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node.params);
      if (node.rest) {
        if (node.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node.rest);
      }
      this.tokenChar(41);
      const type = parent == null ? void 0 : parent.type;
      if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node.returnType);
    }
    function FunctionTypeParam(node) {
      this.print(node.name);
      if (node.optional) this.tokenChar(63);
      if (node.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.typeAnnotation);
    }
    function InterfaceExtends(node) {
      this.print(node.id);
      this.print(node.typeParameters, true);
    }
    function _interfaceish(node) {
      var _node$extends;
      this.print(node.id);
      this.print(node.typeParameters);
      if ((_node$extends = node.extends) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends);
      }
      if (node.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node.mixins);
        }
        if ((_node$implements = node.implements) != null && _node$implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node.implements);
        }
      }
      this.space();
      this.print(node.body);
    }
    function _variance(node) {
      var _node$variance;
      const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node) {
      this.word("interface");
      this.space();
      this._interfaceish(node);
    }
    function andSeparator(occurrenceCount) {
      this.space();
      this.token("&", false, occurrenceCount);
      this.space();
    }
    function InterfaceTypeAnnotation(node) {
      var _node$extends2;
      this.word("interface");
      if ((_node$extends2 = node.extends) != null && _node$extends2.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends);
      }
      this.space();
      this.print(node.body);
    }
    function IntersectionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, andSeparator);
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node) {
      this.tokenChar(63);
      this.print(node.typeAnnotation);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node) {
      this.tokenChar(91);
      this.printList(node.types);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node) {
      this.word("typeof");
      this.space();
      this.print(node.argument);
    }
    function TypeAlias(node) {
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.right);
      this.semicolon();
    }
    function TypeAnnotation(node, parent) {
      this.tokenChar(58);
      this.space();
      if (parent.type === "ArrowFunctionExpression") {
        this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
      } else if (node.optional) {
        this.tokenChar(63);
      }
      this.print(node.typeAnnotation);
    }
    function TypeParameterInstantiation(node) {
      this.tokenChar(60);
      this.printList(node.params);
      this.tokenChar(62);
    }
    function TypeParameter(node) {
      this._variance(node);
      this.word(node.name);
      if (node.bound) {
        this.print(node.bound);
      }
      if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
      }
    }
    function OpaqueType(node) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      if (node.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node.supertype);
      }
      if (node.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.impltype);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node) {
      if (node.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, void 0, void 0, function addNewlines(leading) {
          if (leading && !props[0]) return 1;
        }, () => {
          if (props.length !== 1 || node.inexact) {
            this.tokenChar(44);
            this.space();
          }
        });
        this.space();
      }
      if (node.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node.id);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeCallProperty(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeIndexer(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this._variance(node);
      this.tokenChar(91);
      if (node.id) {
        this.print(node.id);
        this.tokenChar(58);
        this.space();
      }
      this.print(node.key);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ObjectTypeProperty(node) {
      if (node.proto) {
        this.word("proto");
        this.space();
      }
      if (node.static) {
        this.word("static");
        this.space();
      }
      if (node.kind === "get" || node.kind === "set") {
        this.word(node.kind);
        this.space();
      }
      this._variance(node);
      this.print(node.key);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeSpreadProperty(node) {
      this.token("...");
      this.print(node.argument);
    }
    function QualifiedTypeIdentifier(node) {
      this.print(node.qualification);
      this.tokenChar(46);
      this.print(node.id);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator(occurrenceCount) {
      this.space();
      this.token("|", false, occurrenceCount);
      this.space();
    }
    function UnionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, orSeparator);
    }
    function TypeCastExpression(node) {
      this.tokenChar(40);
      this.print(node.expression);
      this.print(node.typeAnnotation);
      this.tokenChar(41);
    }
    function Variance(node) {
      if (node.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node) {
      this.print(node.objectType, true);
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node) {
      this.print(node.objectType);
      if (node.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
  }
});

// node_modules/@babel/generator/lib/generators/base.js
var require_base = __commonJS({
  "node_modules/@babel/generator/lib/generators/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BlockStatement = BlockStatement;
    exports2.Directive = Directive;
    exports2.DirectiveLiteral = DirectiveLiteral;
    exports2.File = File;
    exports2.InterpreterDirective = InterpreterDirective;
    exports2.Placeholder = Placeholder;
    exports2.Program = Program;
    function File(node) {
      if (node.program) {
        this.print(node.program.interpreter);
      }
      this.print(node.program);
    }
    function Program(node) {
      var _node$directives;
      this.noIndentInnerCommentsHere();
      this.printInnerComments();
      const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
      if (directivesLen) {
        var _node$directives$trai;
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, void 0, newline);
        if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node.body);
    }
    function BlockStatement(node) {
      var _node$directives2;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
      if (directivesLen) {
        var _node$directives$trai2;
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, true, newline);
        if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node.body, true);
      exit();
      this.rightBrace(node);
    }
    function Directive(node) {
      this.print(node.value);
      this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const {
        value
      } = node;
      if (!unescapedDoubleQuoteRE.test(value)) {
        this.token(`"${value}"`);
      } else if (!unescapedSingleQuoteRE.test(value)) {
        this.token(`'${value}'`);
      } else {
        throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      }
    }
    function InterpreterDirective(node) {
      this.token(`#!${node.value}`);
      this.newline(1, true);
    }
    function Placeholder(node) {
      this.token("%%");
      this.print(node.name);
      this.token("%%");
      if (node.expectedNode === "Statement") {
        this.semicolon();
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/jsx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JSXAttribute = JSXAttribute;
    exports2.JSXClosingElement = JSXClosingElement;
    exports2.JSXClosingFragment = JSXClosingFragment;
    exports2.JSXElement = JSXElement;
    exports2.JSXEmptyExpression = JSXEmptyExpression;
    exports2.JSXExpressionContainer = JSXExpressionContainer;
    exports2.JSXFragment = JSXFragment;
    exports2.JSXIdentifier = JSXIdentifier;
    exports2.JSXMemberExpression = JSXMemberExpression;
    exports2.JSXNamespacedName = JSXNamespacedName;
    exports2.JSXOpeningElement = JSXOpeningElement;
    exports2.JSXOpeningFragment = JSXOpeningFragment;
    exports2.JSXSpreadAttribute = JSXSpreadAttribute;
    exports2.JSXSpreadChild = JSXSpreadChild;
    exports2.JSXText = JSXText;
    function JSXAttribute(node) {
      this.print(node.name);
      if (node.value) {
        this.tokenChar(61);
        this.print(node.value);
      }
    }
    function JSXIdentifier(node) {
      this.word(node.name);
    }
    function JSXNamespacedName(node) {
      this.print(node.namespace);
      this.tokenChar(58);
      this.print(node.name);
    }
    function JSXMemberExpression(node) {
      this.print(node.object);
      this.tokenChar(46);
      this.print(node.property);
    }
    function JSXSpreadAttribute(node) {
      this.tokenChar(123);
      this.token("...");
      this.print(node.argument);
      this.rightBrace(node);
    }
    function JSXExpressionContainer(node) {
      this.tokenChar(123);
      this.print(node.expression);
      this.rightBrace(node);
    }
    function JSXSpreadChild(node) {
      this.tokenChar(123);
      this.token("...");
      this.print(node.expression);
      this.rightBrace(node);
    }
    function JSXText(node) {
      const raw = this.getPossibleRaw(node);
      if (raw !== void 0) {
        this.token(raw, true);
      } else {
        this.token(node.value, true);
      }
    }
    function JSXElement(node) {
      const open = node.openingElement;
      this.print(open);
      if (open.selfClosing) return;
      this.indent();
      for (const child of node.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node.closingElement);
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node) {
      this.tokenChar(60);
      this.print(node.name);
      {
        if (node.typeArguments) {
          this.print(node.typeArguments);
        }
        this.print(node.typeParameters);
      }
      if (node.attributes.length > 0) {
        this.space();
        this.printJoin(node.attributes, void 0, void 0, spaceSeparator);
      }
      if (node.selfClosing) {
        this.space();
        this.tokenChar(47);
      }
      this.tokenChar(62);
    }
    function JSXClosingElement(node) {
      this.tokenChar(60);
      this.tokenChar(47);
      this.print(node.name);
      this.tokenChar(62);
    }
    function JSXEmptyExpression() {
      this.printInnerComments();
    }
    function JSXFragment(node) {
      this.print(node.openingFragment);
      this.indent();
      for (const child of node.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node.closingFragment);
    }
    function JSXOpeningFragment() {
      this.tokenChar(60);
      this.tokenChar(62);
    }
    function JSXClosingFragment() {
      this.token("</");
      this.tokenChar(62);
    }
  }
});

// node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/typescript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TSAnyKeyword = TSAnyKeyword;
    exports2.TSArrayType = TSArrayType;
    exports2.TSSatisfiesExpression = exports2.TSAsExpression = TSTypeExpression;
    exports2.TSBigIntKeyword = TSBigIntKeyword;
    exports2.TSBooleanKeyword = TSBooleanKeyword;
    exports2.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    exports2.TSInterfaceHeritage = exports2.TSClassImplements = TSClassImplements;
    exports2.TSConditionalType = TSConditionalType;
    exports2.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    exports2.TSConstructorType = TSConstructorType;
    exports2.TSDeclareFunction = TSDeclareFunction;
    exports2.TSDeclareMethod = TSDeclareMethod;
    exports2.TSEnumBody = TSEnumBody;
    exports2.TSEnumDeclaration = TSEnumDeclaration;
    exports2.TSEnumMember = TSEnumMember;
    exports2.TSExportAssignment = TSExportAssignment;
    exports2.TSExternalModuleReference = TSExternalModuleReference;
    exports2.TSFunctionType = TSFunctionType;
    exports2.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    exports2.TSImportType = TSImportType;
    exports2.TSIndexSignature = TSIndexSignature;
    exports2.TSIndexedAccessType = TSIndexedAccessType;
    exports2.TSInferType = TSInferType;
    exports2.TSInstantiationExpression = TSInstantiationExpression;
    exports2.TSInterfaceBody = TSInterfaceBody;
    exports2.TSInterfaceDeclaration = TSInterfaceDeclaration;
    exports2.TSIntersectionType = TSIntersectionType;
    exports2.TSIntrinsicKeyword = TSIntrinsicKeyword;
    exports2.TSLiteralType = TSLiteralType;
    exports2.TSMappedType = TSMappedType;
    exports2.TSMethodSignature = TSMethodSignature;
    exports2.TSModuleBlock = TSModuleBlock;
    exports2.TSModuleDeclaration = TSModuleDeclaration;
    exports2.TSNamedTupleMember = TSNamedTupleMember;
    exports2.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    exports2.TSNeverKeyword = TSNeverKeyword;
    exports2.TSNonNullExpression = TSNonNullExpression;
    exports2.TSNullKeyword = TSNullKeyword;
    exports2.TSNumberKeyword = TSNumberKeyword;
    exports2.TSObjectKeyword = TSObjectKeyword;
    exports2.TSOptionalType = TSOptionalType;
    exports2.TSParameterProperty = TSParameterProperty;
    exports2.TSParenthesizedType = TSParenthesizedType;
    exports2.TSPropertySignature = TSPropertySignature;
    exports2.TSQualifiedName = TSQualifiedName;
    exports2.TSRestType = TSRestType;
    exports2.TSStringKeyword = TSStringKeyword;
    exports2.TSSymbolKeyword = TSSymbolKeyword;
    exports2.TSTemplateLiteralType = TSTemplateLiteralType;
    exports2.TSThisType = TSThisType;
    exports2.TSTupleType = TSTupleType;
    exports2.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    exports2.TSTypeAnnotation = TSTypeAnnotation;
    exports2.TSTypeAssertion = TSTypeAssertion;
    exports2.TSTypeLiteral = TSTypeLiteral;
    exports2.TSTypeOperator = TSTypeOperator;
    exports2.TSTypeParameter = TSTypeParameter;
    exports2.TSTypeParameterDeclaration = exports2.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    exports2.TSTypePredicate = TSTypePredicate;
    exports2.TSTypeQuery = TSTypeQuery;
    exports2.TSTypeReference = TSTypeReference;
    exports2.TSUndefinedKeyword = TSUndefinedKeyword;
    exports2.TSUnionType = TSUnionType;
    exports2.TSUnknownKeyword = TSUnknownKeyword;
    exports2.TSVoidKeyword = TSVoidKeyword;
    exports2.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
    exports2.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    exports2.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    exports2.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    function TSTypeAnnotation(node, parent) {
      this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node ? "=>" : ":");
      this.space();
      if (node.optional) this.tokenChar(63);
      this.print(node.typeAnnotation);
    }
    function TSTypeParameterInstantiation(node, parent) {
      this.tokenChar(60);
      let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node.params.length === 1;
      if (this.tokenMap && node.start != null && node.end != null) {
        printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, (t3) => this.tokenMap.matchesOriginal(t3, ",")));
        printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
      }
      this.printList(node.params, printTrailingSeparator);
      this.tokenChar(62);
    }
    function TSTypeParameter(node) {
      if (node.in) {
        this.word("in");
        this.space();
      }
      if (node.out) {
        this.word("out");
        this.space();
      }
      this.word(node.name);
      if (node.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.constraint);
      }
      if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
      }
    }
    function TSParameterProperty(node) {
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }
      if (node.readonly) {
        this.word("readonly");
        this.space();
      }
      this._param(node.parameter);
    }
    function TSDeclareFunction(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      this._functionHead(node, parent);
      this.semicolon();
    }
    function TSDeclareMethod(node) {
      this._classMethodHead(node);
      this.semicolon();
    }
    function TSQualifiedName(node) {
      this.print(node.left);
      this.tokenChar(46);
      this.print(node.right);
    }
    function TSCallSignatureDeclaration(node) {
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function maybePrintTrailingCommaOrSemicolon(printer, node) {
      if (!printer.tokenMap || !node.start || !node.end) {
        printer.semicolon();
        return;
      }
      if (printer.tokenMap.endMatches(node, ",")) {
        printer.token(",");
      } else if (printer.tokenMap.endMatches(node, ";")) {
        printer.semicolon();
      }
    }
    function TSConstructSignatureDeclaration(node) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSPropertySignature(node) {
      const {
        readonly
      } = node;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.print(node.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function tsPrintPropertyOrMethodName(node) {
      if (node.computed) {
        this.tokenChar(91);
      }
      this.print(node.key);
      if (node.computed) {
        this.tokenChar(93);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
    }
    function TSMethodSignature(node) {
      const {
        kind
      } = node;
      if (kind === "set" || kind === "get") {
        this.word(kind);
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSIndexSignature(node) {
      const {
        readonly,
        static: isStatic
      } = node;
      if (isStatic) {
        this.word("static");
        this.space();
      }
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this._parameters(node.parameters, "]");
      this.print(node.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSBigIntKeyword() {
      this.word("bigint");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSIntrinsicKeyword() {
      this.word("intrinsic");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node) {
      this.tsPrintFunctionOrConstructorType(node);
    }
    function TSConstructorType(node) {
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node);
    }
    function tsPrintFunctionOrConstructorType(node) {
      const {
        typeParameters
      } = node;
      const parameters = node.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      this.space();
      const returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function TSTypeReference(node) {
      const typeArguments = node.typeParameters;
      this.print(node.typeName, !!typeArguments);
      this.print(typeArguments);
    }
    function TSTypePredicate(node) {
      if (node.asserts) {
        this.word("asserts");
        this.space();
      }
      this.print(node.parameterName);
      if (node.typeAnnotation) {
        this.space();
        this.word("is");
        this.space();
        this.print(node.typeAnnotation.typeAnnotation);
      }
    }
    function TSTypeQuery(node) {
      this.word("typeof");
      this.space();
      this.print(node.exprName);
      const typeArguments = node.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSTypeLiteral(node) {
      printBraced(this, node, () => this.printJoin(node.members, true, true));
    }
    function TSArrayType(node) {
      this.print(node.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function TSTupleType(node) {
      this.tokenChar(91);
      this.printList(node.elementTypes, this.shouldPrintTrailingComma("]"));
      this.tokenChar(93);
    }
    function TSOptionalType(node) {
      this.print(node.typeAnnotation);
      this.tokenChar(63);
    }
    function TSRestType(node) {
      this.token("...");
      this.print(node.typeAnnotation);
    }
    function TSNamedTupleMember(node) {
      this.print(node.label);
      if (node.optional) this.tokenChar(63);
      this.tokenChar(58);
      this.space();
      this.print(node.elementType);
    }
    function TSUnionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "|");
    }
    function TSIntersectionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "&");
    }
    function tsPrintUnionOrIntersectionType(printer, node, sep) {
      var _printer$tokenMap;
      let hasLeadingToken = 0;
      if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {
        hasLeadingToken = 1;
        printer.token(sep);
      }
      printer.printJoin(node.types, void 0, void 0, function(i) {
        this.space();
        this.token(sep, null, i + hasLeadingToken);
        this.space();
      });
    }
    function TSConditionalType(node) {
      this.print(node.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node.extendsType);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node.trueType);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node.falseType);
    }
    function TSInferType(node) {
      this.word("infer");
      this.print(node.typeParameter);
    }
    function TSParenthesizedType(node) {
      this.tokenChar(40);
      this.print(node.typeAnnotation);
      this.tokenChar(41);
    }
    function TSTypeOperator(node) {
      this.word(node.operator);
      this.space();
      this.print(node.typeAnnotation);
    }
    function TSIndexedAccessType(node) {
      this.print(node.objectType, true);
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
    function TSMappedType(node) {
      const {
        nameType,
        optional,
        readonly,
        typeAnnotation
      } = node;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      this.space();
      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      {
        this.word(node.typeParameter.name);
      }
      this.space();
      this.word("in");
      this.space();
      {
        this.print(node.typeParameter.constraint);
      }
      if (nameType) {
        this.space();
        this.word("as");
        this.space();
        this.print(nameType);
      }
      this.tokenChar(93);
      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.tokenChar(63);
      }
      if (typeAnnotation) {
        this.tokenChar(58);
        this.space();
        this.print(typeAnnotation);
      }
      this.space();
      exit();
      this.tokenChar(125);
    }
    function tokenIfPlusMinus(self2, tok) {
      if (tok !== true) {
        self2.token(tok);
      }
    }
    function TSTemplateLiteralType(node) {
      this._printTemplate(node, node.types);
    }
    function TSLiteralType(node) {
      this.print(node.literal);
    }
    function TSClassImplements(node) {
      this.print(node.expression);
      this.print(node.typeArguments);
    }
    function TSInterfaceDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        extends: extendz,
        body
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("interface");
      this.space();
      this.print(id);
      this.print(typeParameters);
      if (extendz != null && extendz.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz);
      }
      this.space();
      this.print(body);
    }
    function TSInterfaceBody(node) {
      printBraced(this, node, () => this.printJoin(node.body, true, true));
    }
    function TSTypeAliasDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        typeAnnotation
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("type");
      this.space();
      this.print(id);
      this.print(typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(typeAnnotation);
      this.semicolon();
    }
    function TSTypeExpression(node) {
      const {
        type,
        expression,
        typeAnnotation
      } = node;
      this.print(expression, true);
      this.space();
      this.word(type === "TSAsExpression" ? "as" : "satisfies");
      this.space();
      this.print(typeAnnotation);
    }
    function TSTypeAssertion(node) {
      const {
        typeAnnotation,
        expression
      } = node;
      this.tokenChar(60);
      this.print(typeAnnotation);
      this.tokenChar(62);
      this.space();
      this.print(expression);
    }
    function TSInstantiationExpression(node) {
      this.print(node.expression);
      {
        this.print(node.typeParameters);
      }
    }
    function TSEnumDeclaration(node) {
      const {
        declare,
        const: isConst,
        id
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (isConst) {
        this.word("const");
        this.space();
      }
      this.word("enum");
      this.space();
      this.print(id);
      this.space();
      {
        TSEnumBody.call(this, node);
      }
    }
    function TSEnumBody(node) {
      printBraced(this, node, () => {
        var _this$shouldPrintTrai;
        return this.printList(node.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true, true, true);
      });
    }
    function TSEnumMember(node) {
      const {
        id,
        initializer
      } = node;
      this.print(id);
      if (initializer) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(initializer);
      }
    }
    function TSModuleDeclaration(node) {
      const {
        declare,
        id,
        kind
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      {
        if (!node.global) {
          this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");
          this.space();
        }
        this.print(id);
        if (!node.body) {
          this.semicolon();
          return;
        }
        let body = node.body;
        while (body.type === "TSModuleDeclaration") {
          this.tokenChar(46);
          this.print(body.id);
          body = body.body;
        }
        this.space();
        this.print(body);
      }
    }
    function TSModuleBlock(node) {
      printBraced(this, node, () => this.printSequence(node.body, true));
    }
    function TSImportType(node) {
      const {
        argument,
        qualifier,
        options
      } = node;
      this.word("import");
      this.tokenChar(40);
      this.print(argument);
      if (options) {
        this.tokenChar(44);
        this.print(options);
      }
      this.tokenChar(41);
      if (qualifier) {
        this.tokenChar(46);
        this.print(qualifier);
      }
      const typeArguments = node.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSImportEqualsDeclaration(node) {
      const {
        id,
        moduleReference
      } = node;
      if (node.isExport) {
        this.word("export");
        this.space();
      }
      this.word("import");
      this.space();
      this.print(id);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(moduleReference);
      this.semicolon();
    }
    function TSExternalModuleReference(node) {
      this.token("require(");
      this.print(node.expression);
      this.tokenChar(41);
    }
    function TSNonNullExpression(node) {
      this.print(node.expression);
      this.tokenChar(33);
    }
    function TSExportAssignment(node) {
      this.word("export");
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.expression);
      this.semicolon();
    }
    function TSNamespaceExportDeclaration(node) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node.id);
      this.semicolon();
    }
    function tsPrintSignatureDeclarationBase(node) {
      const {
        typeParameters
      } = node;
      const parameters = node.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      const returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function tsPrintClassMemberModifiers(node) {
      const isPrivateField = node.type === "ClassPrivateProperty";
      const isPublicField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
      printModifiersList(this, node, [isPublicField && node.declare && "declare", !isPrivateField && node.accessibility]);
      if (node.static) {
        this.word("static");
        this.space();
      }
      printModifiersList(this, node, [!isPrivateField && node.override && "override", !isPrivateField && node.abstract && "abstract", (isPublicField || isPrivateField) && node.readonly && "readonly"]);
    }
    function printBraced(printer, node, cb) {
      printer.token("{");
      const exit = printer.enterDelimited();
      cb();
      exit();
      printer.rightBrace(node);
    }
    function printModifiersList(printer, node, modifiers) {
      var _printer$tokenMap2;
      const modifiersSet = /* @__PURE__ */ new Set();
      for (const modifier of modifiers) {
        if (modifier) modifiersSet.add(modifier);
      }
      (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, (tok) => {
        if (modifiersSet.has(tok.value)) {
          printer.token(tok.value);
          printer.space();
          modifiersSet.delete(tok.value);
          return modifiersSet.size === 0;
        }
      });
      for (const modifier of modifiersSet) {
        printer.word(modifier);
        printer.space();
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/index.js
var require_generators = __commonJS({
  "node_modules/@babel/generator/lib/generators/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _templateLiterals = require_template_literals();
    Object.keys(_templateLiterals).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _templateLiterals[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _templateLiterals[key];
        }
      });
    });
    var _expressions = require_expressions();
    Object.keys(_expressions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _expressions[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _expressions[key];
        }
      });
    });
    var _statements = require_statements();
    Object.keys(_statements).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _statements[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _statements[key];
        }
      });
    });
    var _classes = require_classes();
    Object.keys(_classes).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _classes[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _classes[key];
        }
      });
    });
    var _methods = require_methods();
    Object.keys(_methods).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _methods[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _methods[key];
        }
      });
    });
    var _modules = require_modules();
    Object.keys(_modules).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _modules[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _modules[key];
        }
      });
    });
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _types[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _types[key];
        }
      });
    });
    var _flow = require_flow2();
    Object.keys(_flow).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _flow[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _flow[key];
        }
      });
    });
    var _base = require_base();
    Object.keys(_base).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _base[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _base[key];
        }
      });
    });
    var _jsx = require_jsx2();
    Object.keys(_jsx).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _jsx[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _jsx[key];
        }
      });
    });
    var _typescript = require_typescript2();
    Object.keys(_typescript).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _typescript[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _typescript[key];
        }
      });
    });
  }
});

// node_modules/@babel/generator/lib/generators/deprecated.js
var require_deprecated = __commonJS({
  "node_modules/@babel/generator/lib/generators/deprecated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addDeprecatedGenerators = addDeprecatedGenerators;
    function addDeprecatedGenerators(PrinterClass) {
      {
        const deprecatedBabel7Generators = {
          Noop() {
          },
          TSExpressionWithTypeArguments(node) {
            this.print(node.expression);
            this.print(node.typeParameters);
          },
          DecimalLiteral(node) {
            const raw = this.getPossibleRaw(node);
            if (!this.format.minified && raw !== void 0) {
              this.word(raw);
              return;
            }
            this.word(node.value + "m");
          }
        };
        Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
      }
    }
  }
});

// node_modules/@babel/generator/lib/printer.js
var require_printer = __commonJS({
  "node_modules/@babel/generator/lib/printer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _buffer = require_buffer();
    var n = require_node2();
    var _t = require_lib4();
    var _tokenMap = require_token_map();
    var generatorFunctions = require_generators();
    var _deprecated = require_deprecated();
    var {
      isExpression,
      isFunction,
      isStatement,
      isClassBody,
      isTSInterfaceBody,
      isTSEnumMember
    } = _t;
    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
    var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
    function commentIsNewline(c) {
      return c.type === "CommentLine" || HAS_NEWLINE.test(c.value);
    }
    var {
      needsParens
    } = n;
    var Printer = class {
      constructor(format, map, tokens, originalCode) {
        this.inForStatementInit = false;
        this.tokenContext = 0;
        this._tokens = null;
        this._originalCode = null;
        this._currentNode = null;
        this._indent = 0;
        this._indentRepeat = 0;
        this._insideAux = false;
        this._noLineTerminator = false;
        this._noLineTerminatorAfterNode = null;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = /* @__PURE__ */ new Set();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this._endsWithDiv = false;
        this._lastCommentLine = 0;
        this._endsWithInnerRaw = false;
        this._indentInnerComments = true;
        this.tokenMap = null;
        this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
        this._printSemicolonBeforeNextNode = -1;
        this._printSemicolonBeforeNextToken = -1;
        this.format = format;
        this._tokens = tokens;
        this._originalCode = originalCode;
        this._indentRepeat = format.indent.style.length;
        this._inputMap = map == null ? void 0 : map._inputMap;
        this._buf = new _buffer.default(map, format.indent.style[0]);
      }
      enterForStatementInit() {
        if (this.inForStatementInit) return () => {
        };
        this.inForStatementInit = true;
        return () => {
          this.inForStatementInit = false;
        };
      }
      enterDelimited() {
        const oldInForStatementInit = this.inForStatementInit;
        const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        if (oldInForStatementInit === false && oldNoLineTerminatorAfterNode === null) {
          return () => {
          };
        }
        this.inForStatementInit = false;
        this._noLineTerminatorAfterNode = null;
        return () => {
          this.inForStatementInit = oldInForStatementInit;
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        };
      }
      generate(ast) {
        if (this.format.preserveFormat) {
          this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
        }
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
      }
      indent() {
        const {
          format
        } = this;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent++;
      }
      dedent() {
        const {
          format
        } = this;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent--;
      }
      semicolon(force = false) {
        this._maybeAddAuxComment();
        if (force) {
          this._appendChar(59);
          this._noLineTerminator = false;
          return;
        }
        if (this.tokenMap) {
          const node = this._currentNode;
          if (node.start != null && node.end != null) {
            if (!this.tokenMap.endMatches(node, ";")) {
              this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
              return;
            }
            const indexes = this.tokenMap.getIndexes(this._currentNode);
            this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
          }
        }
        this._queue(59);
        this._noLineTerminator = false;
      }
      rightBrace(node) {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(125);
      }
      rightParens(node) {
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(41);
      }
      space(force = false) {
        const {
          format
        } = this;
        if (format.compact || format.preserveFormat) return;
        if (force) {
          this._space();
        } else if (this._buf.hasContent()) {
          const lastCp = this.getLastChar();
          if (lastCp !== 32 && lastCp !== 10) {
            this._space();
          }
        }
      }
      word(str, noLineTerminatorAfter = false) {
        this.tokenContext = 0;
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
          this._space();
        }
        this._append(str, false);
        this._endsWithWord = true;
        this._noLineTerminator = noLineTerminatorAfter;
      }
      number(str, number) {
        function isNonDecimalLiteral(str2) {
          if (str2.length > 2 && str2.charCodeAt(0) === 48) {
            const secondChar = str2.charCodeAt(1);
            return secondChar === 98 || secondChar === 111 || secondChar === 120;
          }
          return false;
        }
        this.word(str);
        this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
      }
      token(str, maybeNewline = false, occurrenceCount = 0) {
        this.tokenContext = 0;
        this._maybePrintInnerComments(str, occurrenceCount);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);
        const lastChar = this.getLastChar();
        const strFirst = str.charCodeAt(0);
        if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
          this._space();
        }
        this._append(str, maybeNewline);
        this._noLineTerminator = false;
      }
      tokenChar(char) {
        this.tokenContext = 0;
        const str = String.fromCharCode(char);
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        const lastChar = this.getLastChar();
        if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
          this._space();
        }
        this._appendChar(char);
        this._noLineTerminator = false;
      }
      newline(i = 1, force) {
        if (i <= 0) return;
        if (!force) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        if (i > 2) i = 2;
        i -= this._buf.getNewlineCount();
        for (let j = 0; j < i; j++) {
          this._newline();
        }
        return;
      }
      endsWith(char) {
        return this.getLastChar() === char;
      }
      getLastChar() {
        return this._buf.getLastChar();
      }
      endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
      }
      removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }
      exactSource(loc, cb) {
        if (!loc) {
          cb();
          return;
        }
        this._catchUp("start", loc);
        this._buf.exactSource(loc, cb);
      }
      source(prop, loc) {
        if (!loc) return;
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!loc || this.format.preserveFormat) return;
        this._catchUp(prop, loc);
        this._buf.sourceWithOffset(prop, loc, columnOffset);
      }
      sourceIdentifierName(identifierName, pos) {
        if (!this._buf._canMarkIdName) return;
        const sourcePosition = this._buf._sourcePosition;
        sourcePosition.identifierNamePos = pos;
        sourcePosition.identifierName = identifierName;
      }
      _space() {
        this._queue(32);
      }
      _newline() {
        this._queue(10);
      }
      _catchUpToCurrentToken(str, occurrenceCount = 0) {
        const token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
        if (token) this._catchUpTo(token.loc.start);
        if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
          this._buf.appendChar(59);
          this._endsWithWord = false;
          this._endsWithInteger = false;
          this._endsWithDiv = false;
        }
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
      }
      _append(str, maybeNewline) {
        this._maybeIndent(str.charCodeAt(0));
        this._buf.append(str, maybeNewline);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _appendChar(char) {
        this._maybeIndent(char);
        this._buf.appendChar(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _queue(char) {
        this._maybeIndent(char);
        this._buf.queue(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
      _maybeIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          this._buf.queueIndentation(this._getIndent());
        }
      }
      _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          return true;
        }
      }
      catchUp(line) {
        if (!this.format.retainLines) return;
        const count = line - this._buf.getCurrentLine();
        for (let i = 0; i < count; i++) {
          this._newline();
        }
      }
      _catchUp(prop, loc) {
        const {
          format
        } = this;
        if (!format.preserveFormat) {
          if (format.retainLines && loc != null && loc[prop]) {
            this.catchUp(loc[prop].line);
          }
          return;
        }
        const pos = loc == null ? void 0 : loc[prop];
        if (pos != null) this._catchUpTo(pos);
      }
      _catchUpTo({
        line,
        column,
        index
      }) {
        const count = line - this._buf.getCurrentLine();
        if (count > 0 && this._noLineTerminator) {
          return;
        }
        for (let i = 0; i < count; i++) {
          this._newline();
        }
        const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
        if (spacesCount > 0) {
          const spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(spacesCount);
          this._append(spaces, false);
        }
      }
      _getIndent() {
        return this._indentRepeat * this._indent;
      }
      printTerminatorless(node) {
        this._noLineTerminator = true;
        this.print(node);
      }
      print(node, noLineTerminatorAfter, trailingCommentsLineOffset) {
        var _node$extra, _node$leadingComments, _node$leadingComments2;
        if (!node) return;
        this._endsWithInnerRaw = false;
        const nodeType = node.type;
        const format = this.format;
        const oldConcise = format.concise;
        if (node._compact) {
          format.concise = true;
        }
        const printMethod = this[nodeType];
        if (printMethod === void 0) {
          throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
        }
        const parent = this._currentNode;
        this._currentNode = node;
        if (this.tokenMap) {
          this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
        }
        const oldInAux = this._insideAux;
        this._insideAux = node.loc == null;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        const parenthesized = (_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized;
        let shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node, parent, this.tokenContext, this.inForStatementInit, format.preserveFormat ? this._boundGetRawIdentifier : void 0);
        if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === "CommentBlock") {
          const parentType = parent == null ? void 0 : parent.type;
          switch (parentType) {
            case "ExpressionStatement":
            case "VariableDeclarator":
            case "AssignmentExpression":
            case "ReturnStatement":
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              if (parent.callee !== node) break;
            default:
              shouldPrintParens = true;
          }
        }
        let indentParenthesized = false;
        if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {
          shouldPrintParens = true;
          indentParenthesized = true;
        }
        let oldNoLineTerminatorAfterNode;
        let oldInForStatementInitWasTrue;
        if (!shouldPrintParens) {
          noLineTerminatorAfter || (noLineTerminatorAfter = parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node));
          if (noLineTerminatorAfter) {
            var _node$trailingComment;
            if ((_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
              if (isExpression(node)) shouldPrintParens = true;
            } else {
              oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
              this._noLineTerminatorAfterNode = node;
            }
          }
        }
        if (shouldPrintParens) {
          this.tokenChar(40);
          if (indentParenthesized) this.indent();
          this._endsWithInnerRaw = false;
          if (this.inForStatementInit) {
            oldInForStatementInitWasTrue = true;
            this.inForStatementInit = false;
          }
          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
          this._noLineTerminatorAfterNode = null;
        }
        this._lastCommentLine = 0;
        this._printLeadingComments(node, parent);
        const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
        this.exactSource(loc, printMethod.bind(this, node, parent));
        if (shouldPrintParens) {
          this._printTrailingComments(node, parent);
          if (indentParenthesized) {
            this.dedent();
            this.newline();
          }
          this.tokenChar(41);
          this._noLineTerminator = noLineTerminatorAfter;
          if (oldInForStatementInitWasTrue) this.inForStatementInit = true;
        } else if (noLineTerminatorAfter && !this._noLineTerminator) {
          this._noLineTerminator = true;
          this._printTrailingComments(node, parent);
        } else {
          this._printTrailingComments(node, parent, trailingCommentsLineOffset);
        }
        this._currentNode = parent;
        format.concise = oldConcise;
        this._insideAux = oldInAux;
        if (oldNoLineTerminatorAfterNode !== void 0) {
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        }
        this._endsWithInnerRaw = false;
      }
      _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode) this._printAuxBeforeComment();
        if (!this._insideAux) this._printAuxAfterComment();
      }
      _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = true;
        const comment = this.format.auxiliaryCommentBefore;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
      _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = false;
        const comment = this.format.auxiliaryCommentAfter;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
      getPossibleRaw(node) {
        const extra = node.extra;
        if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {
          return extra.raw;
        }
      }
      printJoin(nodes, statement, indent, separator, printTrailingSeparator, addNewlines, iterator, trailingCommentsLineOffset) {
        if (!(nodes != null && nodes.length)) return;
        if (indent == null && this.format.retainLines) {
          var _nodes$0$loc;
          const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
          if (startLine != null && startLine !== this._buf.getCurrentLine()) {
            indent = true;
          }
        }
        if (indent) this.indent();
        const newlineOpts = {
          addNewlines,
          nextNodeStartLine: 0
        };
        const boundSeparator = separator == null ? void 0 : separator.bind(this);
        const len = nodes.length;
        for (let i = 0; i < len; i++) {
          const node = nodes[i];
          if (!node) continue;
          if (statement) this._printNewline(i === 0, newlineOpts);
          this.print(node, void 0, trailingCommentsLineOffset || 0);
          iterator == null || iterator(node, i);
          if (boundSeparator != null) {
            if (i < len - 1) boundSeparator(i, false);
            else if (printTrailingSeparator) boundSeparator(i, true);
          }
          if (statement) {
            var _node$trailingComment2;
            if (!((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length)) {
              this._lastCommentLine = 0;
            }
            if (i + 1 === len) {
              this.newline(1);
            } else {
              var _nextNode$loc;
              const nextNode = nodes[i + 1];
              newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
              this._printNewline(true, newlineOpts);
            }
          }
        }
        if (indent) this.dedent();
      }
      printAndIndentOnComments(node) {
        const indent = node.leadingComments && node.leadingComments.length > 0;
        if (indent) this.indent();
        this.print(node);
        if (indent) this.dedent();
      }
      printBlock(parent) {
        const node = parent.body;
        if (node.type !== "EmptyStatement") {
          this.space();
        }
        this.print(node);
      }
      _printTrailingComments(node, parent, lineOffset) {
        const {
          innerComments,
          trailingComments
        } = node;
        if (innerComments != null && innerComments.length) {
          this._printComments(2, innerComments, node, parent, lineOffset);
        }
        if (trailingComments != null && trailingComments.length) {
          this._printComments(2, trailingComments, node, parent, lineOffset);
        }
      }
      _printLeadingComments(node, parent) {
        const comments = node.leadingComments;
        if (!(comments != null && comments.length)) return;
        this._printComments(0, comments, node, parent);
      }
      _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
        if (this._endsWithInnerRaw) {
          var _this$tokenMap;
          this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
        }
        this._endsWithInnerRaw = true;
        this._indentInnerComments = true;
      }
      printInnerComments(nextToken) {
        const node = this._currentNode;
        const comments = node.innerComments;
        if (!(comments != null && comments.length)) return;
        const hasSpace = this.endsWith(32);
        const indent = this._indentInnerComments;
        const printedCommentsCount = this._printedComments.size;
        if (indent) this.indent();
        this._printComments(1, comments, node, void 0, void 0, nextToken);
        if (hasSpace && printedCommentsCount !== this._printedComments.size) {
          this.space();
        }
        if (indent) this.dedent();
      }
      noIndentInnerCommentsHere() {
        this._indentInnerComments = false;
      }
      printSequence(nodes, indent, trailingCommentsLineOffset, addNewlines) {
        this.printJoin(nodes, true, indent != null ? indent : false, void 0, void 0, addNewlines, void 0, trailingCommentsLineOffset);
      }
      printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
        this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, void 0, iterator);
      }
      shouldPrintTrailingComma(listEnd) {
        if (!this.tokenMap) return null;
        const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token) => this.tokenMap.matchesOriginal(token, listEnd));
        if (listEndIndex <= 0) return null;
        return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
      }
      _printNewline(newLine, opts) {
        const format = this.format;
        if (format.retainLines || format.compact) return;
        if (format.concise) {
          this.space();
          return;
        }
        if (!newLine) {
          return;
        }
        const startLine = opts.nextNodeStartLine;
        const lastCommentLine = this._lastCommentLine;
        if (startLine > 0 && lastCommentLine > 0) {
          const offset = startLine - lastCommentLine;
          if (offset >= 0) {
            this.newline(offset || 1);
            return;
          }
        }
        if (this._buf.hasContent()) {
          this.newline(1);
        }
      }
      _shouldPrintComment(comment, nextToken) {
        if (comment.ignore) return 0;
        if (this._printedComments.has(comment)) return 0;
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
          return 2;
        }
        if (nextToken && this.tokenMap) {
          const commentTok = this.tokenMap.find(this._currentNode, (token) => token.value === comment.value);
          if (commentTok && commentTok.start > nextToken.start) {
            return 2;
          }
        }
        this._printedComments.add(comment);
        if (!this.format.shouldPrintComment(comment.value)) {
          return 0;
        }
        return 1;
      }
      _printComment(comment, skipNewLines) {
        const noLineTerminator = this._noLineTerminator;
        const isBlockComment = comment.type === "CommentBlock";
        const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
          this.newline(1);
        }
        const lastCharCode = this.getLastChar();
        if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
          this.space();
        }
        let val;
        if (isBlockComment) {
          val = `/*${comment.value}*/`;
          if (this.format.indent.adjustMultilineComment) {
            var _comment$loc;
            const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
            if (offset) {
              const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
              val = val.replace(newlineRegex, "\n");
            }
            if (this.format.concise) {
              val = val.replace(/\n(?!$)/g, `
`);
            } else {
              let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
              if (this._shouldIndent(47) || this.format.retainLines) {
                indentSize += this._getIndent();
              }
              val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
            }
          }
        } else if (!noLineTerminator) {
          val = `//${comment.value}`;
        } else {
          val = `/*${comment.value}*/`;
        }
        if (this._endsWithDiv) this._space();
        if (this.tokenMap) {
          const {
            _printSemicolonBeforeNextToken,
            _printSemicolonBeforeNextNode
          } = this;
          this._printSemicolonBeforeNextToken = -1;
          this._printSemicolonBeforeNextNode = -1;
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
          this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
          this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
        } else {
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
        }
        if (!isBlockComment && !noLineTerminator) {
          this.newline(1, true);
        }
        if (printNewLines && skipNewLines !== 3) {
          this.newline(1);
        }
      }
      _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {
        const nodeLoc = node.loc;
        const len = comments.length;
        let hasLoc = !!nodeLoc;
        const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
        const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
        let lastLine = 0;
        let leadingCommentNewline = 0;
        const maybeNewline = this._noLineTerminator ? function() {
        } : this.newline.bind(this);
        for (let i = 0; i < len; i++) {
          const comment = comments[i];
          const shouldPrint = this._shouldPrintComment(comment, nextToken);
          if (shouldPrint === 2) {
            hasLoc = false;
            break;
          }
          if (hasLoc && comment.loc && shouldPrint === 1) {
            const commentStartLine = comment.loc.start.line;
            const commentEndLine = comment.loc.end.line;
            if (type === 0) {
              let offset = 0;
              if (i === 0) {
                if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                  offset = leadingCommentNewline = 1;
                }
              } else {
                offset = commentStartLine - lastLine;
              }
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
                lastLine = nodeStartLine;
              }
            } else if (type === 1) {
              const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.min(1, nodeEndLine - lastLine));
                lastLine = nodeEndLine;
              }
            } else {
              const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
            }
          } else {
            hasLoc = false;
            if (shouldPrint !== 1) {
              continue;
            }
            if (len === 1) {
              const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
              const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node);
              if (type === 0) {
                this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                  body: node
                }) ? 1 : 0);
              } else if (shouldSkipNewline && type === 2) {
                this._printComment(comment, 1);
              } else {
                this._printComment(comment, 0);
              }
            } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {
              this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
            } else {
              this._printComment(comment, 0);
            }
          }
        }
        if (type === 2 && hasLoc && lastLine) {
          this._lastCommentLine = lastLine;
        }
      }
    };
    Object.assign(Printer.prototype, generatorFunctions);
    {
      (0, _deprecated.addDeprecatedGenerators)(Printer);
    }
    var _default = exports2.default = Printer;
    function commaSeparator(occurrenceCount, last) {
      this.token(",", false, occurrenceCount);
      if (!last) this.space();
    }
  }
});

// node_modules/@babel/generator/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@babel/generator/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = generate;
    var _sourceMap = require_source_map();
    var _printer = require_printer();
    function normalizeOptions(code, opts, ast) {
      if (opts.experimental_preserveFormat) {
        if (typeof code !== "string") {
          throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
        }
        if (!opts.retainLines) {
          throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
        }
        if (opts.compact && opts.compact !== "auto") {
          throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
        }
        if (opts.minified) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
        }
        if (opts.jsescOption) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
        }
        if (!Array.isArray(ast.tokens)) {
          throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
        }
      }
      const format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        preserveFormat: opts.experimental_preserveFormat,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: true,
          style: "  "
        },
        jsescOption: Object.assign({
          quotes: "double",
          wrap: true,
          minimal: false
        }, opts.jsescOption),
        topicToken: opts.topicToken,
        importAttributesKeyword: opts.importAttributesKeyword
      };
      {
        var _opts$recordAndTupleS;
        format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
        format.jsescOption.json = opts.jsonCompatibleStrings;
        format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
      }
      if (format.minified) {
        format.compact = true;
        format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
      } else {
        format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes("@license") || value.includes("@preserve"));
      }
      if (format.compact === "auto") {
        format.compact = typeof code === "string" && code.length > 5e5;
        if (format.compact) {
          console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
        }
      }
      if (format.compact || format.preserveFormat) {
        format.indent.adjustMultilineComment = false;
      }
      const {
        auxiliaryCommentBefore,
        auxiliaryCommentAfter,
        shouldPrintComment
      } = format;
      if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
        format.auxiliaryCommentBefore = void 0;
      }
      if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
        format.auxiliaryCommentAfter = void 0;
      }
      return format;
    }
    {
      exports2.CodeGenerator = class CodeGenerator {
        constructor(ast, opts = {}, code) {
          this._ast = void 0;
          this._format = void 0;
          this._map = void 0;
          this._ast = ast;
          this._format = normalizeOptions(code, opts, ast);
          this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
        }
        generate() {
          const printer = new _printer.default(this._format, this._map);
          return printer.generate(this._ast);
        }
      };
    }
    function generate(ast, opts = {}, code) {
      const format = normalizeOptions(code, opts, ast);
      const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      const printer = new _printer.default(format, map, ast.tokens, typeof code === "string" ? code : null);
      return printer.generate(ast);
    }
  }
});

// node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry = __commonJS({
  "node_modules/@babel/traverse/lib/path/ancestry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.find = find;
    exports2.findParent = findParent;
    exports2.getAncestry = getAncestry;
    exports2.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
    exports2.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
    exports2.getFunctionParent = getFunctionParent;
    exports2.getStatementParent = getStatementParent;
    exports2.inType = inType;
    exports2.isAncestor = isAncestor;
    exports2.isDescendant = isDescendant;
    var _t = require_lib4();
    var {
      VISITOR_KEYS
    } = _t;
    function findParent(callback) {
      let path3 = this;
      while (path3 = path3.parentPath) {
        if (callback(path3)) return path3;
      }
      return null;
    }
    function find(callback) {
      let path3 = this;
      do {
        if (callback(path3)) return path3;
      } while (path3 = path3.parentPath);
      return null;
    }
    function getFunctionParent() {
      return this.findParent((p) => p.isFunction());
    }
    function getStatementParent() {
      let path3 = this;
      do {
        if (!path3.parentPath || Array.isArray(path3.container) && path3.isStatement()) {
          break;
        } else {
          path3 = path3.parentPath;
        }
      } while (path3);
      if (path3 && (path3.isProgram() || path3.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }
      return path3;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest;
        const keys = VISITOR_KEYS[deepest.type];
        for (const ancestry of ancestries) {
          const path3 = ancestry[i + 1];
          if (!earliest) {
            earliest = path3;
            continue;
          }
          if (path3.listKey && earliest.listKey === path3.listKey) {
            if (path3.key < earliest.key) {
              earliest = path3;
              continue;
            }
          }
          const earliestKeyIndex = keys.indexOf(earliest.parentKey);
          const currentKeyIndex = keys.indexOf(path3.parentKey);
          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path3;
          }
        }
        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter) {
      if (!paths.length) {
        return this;
      }
      if (paths.length === 1) {
        return paths[0];
      }
      let minDepth = Infinity;
      let lastCommonIndex, lastCommon;
      const ancestries = paths.map((path3) => {
        const ancestry = [];
        do {
          ancestry.unshift(path3);
        } while ((path3 = path3.parentPath) && path3 !== this);
        if (ancestry.length < minDepth) {
          minDepth = ancestry.length;
        }
        return ancestry;
      });
      const first = ancestries[0];
      depthLoop: for (let i = 0; i < minDepth; i++) {
        const shouldMatch = first[i];
        for (const ancestry of ancestries) {
          if (ancestry[i] !== shouldMatch) {
            break depthLoop;
          }
        }
        lastCommonIndex = i;
        lastCommon = shouldMatch;
      }
      if (lastCommon) {
        if (filter) {
          return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    function getAncestry() {
      let path3 = this;
      const paths = [];
      do {
        paths.push(path3);
      } while (path3 = path3.parentPath);
      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent((parent) => parent === maybeAncestor);
    }
    function inType(...candidateTypes) {
      let path3 = this;
      while (path3) {
        for (const type of candidateTypes) {
          if (path3.node.type === type) return true;
        }
        path3 = path3.parentPath;
      }
      return false;
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/util.js
var require_util = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createUnionType = createUnionType;
    var _t = require_lib4();
    var {
      createFlowUnionType,
      createTSUnionType,
      createUnionTypeAnnotation,
      isFlowType,
      isTSType
    } = _t;
    function createUnionType(types) {
      {
        if (types.every((v) => isFlowType(v))) {
          if (createFlowUnionType) {
            return createFlowUnionType(types);
          }
          return createUnionTypeAnnotation(types);
        } else if (types.every((v) => isTSType(v))) {
          if (createTSUnionType) {
            return createTSUnionType(types);
          }
        }
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    var _t = require_lib4();
    var _util = require_util();
    var {
      BOOLEAN_NUMBER_BINARY_OPERATORS,
      createTypeAnnotationBasedOnTypeof,
      numberTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function _default(node) {
      if (!this.isReferenced()) return;
      const binding = this.scope.getBinding(node.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
        }
      }
      if (node.name === "undefined") {
        return voidTypeAnnotation();
      } else if (node.name === "NaN" || node.name === "Infinity") {
        return numberTypeAnnotation();
      } else if (node.name === "arguments") {
      }
    }
    function getTypeAnnotationBindingConstantViolations(binding, path3, name) {
      const types = [];
      const functionConstantViolations = [];
      let constantViolations = getConstantViolationsBefore(binding, path3, functionConstantViolations);
      const testType = getConditionalAnnotation(binding, path3, name);
      if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter((path4) => !testConstantViolations.includes(path4));
        types.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations.push(...functionConstantViolations);
        for (const violation of constantViolations) {
          types.push(violation.getTypeAnnotation());
        }
      }
      if (!types.length) {
        return;
      }
      return (0, _util.createUnionType)(types);
    }
    function getConstantViolationsBefore(binding, path3, functions) {
      const violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter((violation) => {
        violation = violation.resolve();
        const status = violation._guessExecutionStatusRelativeTo(path3);
        if (functions && status === "unknown") functions.push(violation);
        return status === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name, path3) {
      const operator = path3.node.operator;
      const right = path3.get("right").resolve();
      const left = path3.get("left").resolve();
      let target;
      if (left.isIdentifier({
        name
      })) {
        target = right;
      } else if (right.isIdentifier({
        name
      })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        }
        if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
          return numberTypeAnnotation();
        }
        return;
      }
      if (operator !== "===" && operator !== "==") return;
      let typeofPath;
      let typePath;
      if (left.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typeofPath) return;
      if (!typeofPath.get("argument").isIdentifier({
        name
      })) return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral()) return;
      const typeValue = typePath.node.value;
      if (typeof typeValue !== "string") return;
      return createTypeAnnotationBasedOnTypeof(typeValue);
    }
    function getParentConditionalPath(binding, path3, name) {
      let parentPath;
      while (parentPath = path3.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path3.key === "test") {
            return;
          }
          return parentPath;
        }
        if (parentPath.isFunction()) {
          if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
        }
        path3 = parentPath;
      }
    }
    function getConditionalAnnotation(binding, path3, name) {
      const ifStatement = getParentConditionalPath(binding, path3, name);
      if (!ifStatement) return;
      const test = ifStatement.get("test");
      const paths = [test];
      const types = [];
      for (let i = 0; i < paths.length; i++) {
        const path4 = paths[i];
        if (path4.isLogicalExpression()) {
          if (path4.node.operator === "&&") {
            paths.push(path4.get("left"));
            paths.push(path4.get("right"));
          }
        } else if (path4.isBinaryExpression()) {
          const type = inferAnnotationFromBinaryExpression(name, path4);
          if (type) types.push(type);
        }
      }
      if (types.length) {
        return {
          typeAnnotation: (0, _util.createUnionType)(types),
          ifStatement
        };
      }
      return getConditionalAnnotation(binding, ifStatement, name);
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArrayExpression = ArrayExpression;
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.BinaryExpression = BinaryExpression;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.CallExpression = CallExpression;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.ClassDeclaration = exports2.ClassExpression = exports2.FunctionDeclaration = exports2.ArrowFunctionExpression = exports2.FunctionExpression = Func;
    Object.defineProperty(exports2, "Identifier", {
      enumerable: true,
      get: function() {
        return _infererReference.default;
      }
    });
    exports2.LogicalExpression = LogicalExpression;
    exports2.NewExpression = NewExpression;
    exports2.NullLiteral = NullLiteral;
    exports2.NumericLiteral = NumericLiteral;
    exports2.ObjectExpression = ObjectExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.RestElement = RestElement;
    exports2.SequenceExpression = SequenceExpression;
    exports2.StringLiteral = StringLiteral;
    exports2.TSAsExpression = TSAsExpression;
    exports2.TSNonNullExpression = TSNonNullExpression;
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.UnaryExpression = UnaryExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.VariableDeclarator = VariableDeclarator;
    var _t = require_lib4();
    var _infererReference = require_inferer_reference();
    var _util = require_util();
    var {
      BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS,
      anyTypeAnnotation,
      arrayTypeAnnotation,
      booleanTypeAnnotation,
      buildMatchMemberExpression,
      genericTypeAnnotation,
      identifier,
      nullLiteralTypeAnnotation,
      numberTypeAnnotation,
      stringTypeAnnotation,
      tupleTypeAnnotation,
      unionTypeAnnotation,
      voidTypeAnnotation,
      isIdentifier
    } = _t;
    function VariableDeclarator() {
      if (!this.get("id").isIdentifier()) return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function TSAsExpression(node) {
      return node.typeAnnotation;
    }
    TSAsExpression.validParent = true;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node) {
      if (node.callee.type === "Identifier") {
        return genericTypeAnnotation(node.callee);
      }
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node) {
      const operator = node.operator;
      if (operator === "void") {
        return voidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.includes(operator)) {
        return stringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node) {
      const operator = node.operator;
      if (NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      } else if (operator === "+") {
        const right = this.get("right");
        const left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation();
        }
        return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node) {
      const operator = node.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return stringTypeAnnotation();
    }
    function NumericLiteral() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier("Object"));
    }
    function ArrayExpression() {
      return genericTypeAnnotation(identifier("Array"));
    }
    function RestElement() {
      return ArrayExpression();
    }
    RestElement.validParent = true;
    function Func() {
      return genericTypeAnnotation(identifier("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression("Array.from");
    var isObjectKeys = buildMatchMemberExpression("Object.keys");
    var isObjectValues = buildMatchMemberExpression("Object.values");
    var isObjectEntries = buildMatchMemberExpression("Object.entries");
    function CallExpression() {
      const {
        callee
      } = this.node;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation(stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation(anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        const {
          node
        } = callee;
        if (node.async) {
          if (node.generator) {
            return genericTypeAnnotation(identifier("AsyncIterator"));
          } else {
            return genericTypeAnnotation(identifier("Promise"));
          }
        } else {
          if (node.generator) {
            return genericTypeAnnotation(identifier("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else {
          }
        }
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._getTypeAnnotation = _getTypeAnnotation;
    exports2.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
    exports2.couldBeBaseType = couldBeBaseType;
    exports2.getTypeAnnotation = getTypeAnnotation;
    exports2.isBaseType = isBaseType;
    exports2.isGenericType = isGenericType;
    var inferers = require_inferers();
    var _t = require_lib4();
    var {
      anyTypeAnnotation,
      isAnyTypeAnnotation,
      isArrayTypeAnnotation,
      isBooleanTypeAnnotation,
      isEmptyTypeAnnotation,
      isFlowBaseAnnotation,
      isGenericTypeAnnotation,
      isIdentifier,
      isMixedTypeAnnotation,
      isNumberTypeAnnotation,
      isStringTypeAnnotation,
      isTSArrayType,
      isTSTypeAnnotation,
      isTSTypeReference,
      isTupleTypeAnnotation,
      isTypeAnnotation,
      isUnionTypeAnnotation,
      isVoidTypeAnnotation,
      stringTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function getTypeAnnotation() {
      let type = this.getData("typeAnnotation");
      if (type != null) {
        return type;
      }
      type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
      if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
        type = type.typeAnnotation;
      }
      this.setData("typeAnnotation", type);
      return type;
    }
    var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
    function _getTypeAnnotation() {
      const node = this.node;
      if (!node) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          const declar = this.parentPath.parentPath;
          const declarParent = declar.parentPath;
          if (declar.key === "left" && declarParent.isForInStatement()) {
            return stringTypeAnnotation();
          }
          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return anyTypeAnnotation();
          }
          return voidTypeAnnotation();
        } else {
          return;
        }
      }
      if (node.typeAnnotation) {
        return node.typeAnnotation;
      }
      if (typeAnnotationInferringNodes.has(node)) {
        return;
      }
      typeAnnotationInferringNodes.add(node);
      try {
        var _inferer;
        let inferer = inferers[node.type];
        if (inferer) {
          return inferer.call(this, node);
        }
        inferer = inferers[this.parentPath.type];
        if ((_inferer = inferer) != null && _inferer.validParent) {
          return this.parentPath.getTypeAnnotation();
        }
      } finally {
        typeAnnotationInferringNodes.delete(node);
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    function _isBaseType(baseName, type, soft) {
      if (baseName === "string") {
        return isStringTypeAnnotation(type);
      } else if (baseName === "number") {
        return isNumberTypeAnnotation(type);
      } else if (baseName === "boolean") {
        return isBooleanTypeAnnotation(type);
      } else if (baseName === "any") {
        return isAnyTypeAnnotation(type);
      } else if (baseName === "mixed") {
        return isMixedTypeAnnotation(type);
      } else if (baseName === "empty") {
        return isEmptyTypeAnnotation(type);
      } else if (baseName === "void") {
        return isVoidTypeAnnotation(type);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error(`Unknown base type ${baseName}`);
        }
      }
    }
    function couldBeBaseType(name) {
      const type = this.getTypeAnnotation();
      if (isAnyTypeAnnotation(type)) return true;
      if (isUnionTypeAnnotation(type)) {
        for (const type2 of type.types) {
          if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
            return true;
          }
        }
        return false;
      } else {
        return _isBaseType(name, type, true);
      }
    }
    function baseTypeStrictlyMatches(rightArg) {
      const left = this.getTypeAnnotation();
      const right = rightArg.getTypeAnnotation();
      if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
        return right.type === left.type;
      }
      return false;
    }
    function isGenericType(genericName) {
      const type = this.getTypeAnnotation();
      if (genericName === "Array") {
        if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
          return true;
        }
      }
      return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
        name: genericName
      }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
        name: genericName
      });
    }
  }
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/picocolors/picocolors.js"(exports2, module2) {
    var p = process || {};
    var argv = p.argv || [];
    var env = p.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5]) token.type = "comment";
      else if (match[6]) token.type = "comment", token.closed = !!match[7];
      else if (match[8]) token.type = "regex";
      else if (match[9]) token.type = "number";
      else if (match[10]) token.type = "name";
      else if (match[11]) token.type = "punctuator";
      else if (match[12]) token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var picocolors = require_picocolors();
    var jsTokens = require_js_tokens();
    var helperValidatorIdentifier = require_lib2();
    function isColorSupported() {
      return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
    }
    var compose = (f, g) => (v) => f(g(v));
    function buildDefs(colors) {
      return {
        keyword: colors.cyan,
        capitalized: colors.yellow,
        jsxIdentifier: colors.yellow,
        punctuator: colors.yellow,
        number: colors.magenta,
        string: colors.green,
        regex: colors.magenta,
        comment: colors.gray,
        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
        gutter: colors.gray,
        marker: compose(colors.red, colors.bold),
        message: compose(colors.red, colors.bold),
        reset: colors.reset
      };
    }
    var defsOn = buildDefs(picocolors.createColors(true));
    var defsOff = buildDefs(picocolors.createColors(false));
    function getDefs(enabled) {
      return enabled ? defsOn : defsOff;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = jsTokens.default.exec(text)) {
          const token = jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlight(text) {
      if (text === "") return "";
      const defs = getDefs(true);
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        if (type in defs) {
          highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    var deprecationWarningShown = false;
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
      const defs = getDefs(shouldHighlight);
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index2) => {
        const number = start + 1 + index2;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + defs.message(opts.message);
            }
          }
          return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (shouldHighlight) {
        return defs.reset(frame);
      } else {
        return frame;
      }
    }
    function index(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
    exports2.codeFrameColumns = codeFrameColumns;
    exports2.default = index;
    exports2.highlight = highlight;
  }
});

// node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hooks = void 0;
    var hooks = exports2.hooks = [function(self2, parent) {
      const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
      if (removeParent) {
        parent.remove();
        return true;
      }
    }, function(self2, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
        parent.replaceWith(parent.node.expressions[0]);
        return true;
      }
    }, function(self2, parent) {
      if (parent.isBinary()) {
        if (self2.key === "left") {
          parent.replaceWith(parent.node.right);
        } else {
          parent.replaceWith(parent.node.left);
        }
        return true;
      }
    }, function(self2, parent) {
      if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
        self2.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
      }
    }];
  }
});

// node_modules/@babel/traverse/lib/path/removal.js
var require_removal = __commonJS({
  "node_modules/@babel/traverse/lib/path/removal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._assertUnremoved = _assertUnremoved;
    exports2._callRemovalHooks = _callRemovalHooks;
    exports2._markRemoved = _markRemoved;
    exports2._remove = _remove;
    exports2._removeFromScope = _removeFromScope;
    exports2.remove = remove;
    var _removalHooks = require_removal_hooks();
    var _cache = require_cache();
    var _replacement = require_replacement();
    var _index = require_path();
    var _t = require_lib4();
    var _modification = require_modification();
    var _context = require_context2();
    var {
      getBindingIdentifiers
    } = _t;
    function remove() {
      var _this$opts;
      _assertUnremoved.call(this);
      _context.resync.call(this);
      if (_callRemovalHooks.call(this)) {
        _markRemoved.call(this);
        return;
      }
      if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
        _removeFromScope.call(this);
      }
      this.shareCommentsWithSiblings();
      _remove.call(this);
      _markRemoved.call(this);
    }
    function _removeFromScope() {
      const bindings = getBindingIdentifiers(this.node, false, false, true);
      Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
    }
    function _callRemovalHooks() {
      if (this.parentPath) {
        for (const fn of _removalHooks.hooks) {
          if (fn(this, this.parentPath)) return true;
        }
      }
    }
    function _remove() {
      if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        _modification.updateSiblingKeys.call(this, this.key, -1);
      } else {
        _replacement._replaceWith.call(this, null);
      }
    }
    function _markRemoved() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
      if (this.parent) {
        (0, _cache.getCachedPaths)(this.hub, this.parent).delete(this.node);
      }
      this.node = null;
    }
    function _assertUnremoved() {
      if (this.removed) {
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/lib/hoister.js
var require_hoister = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/hoister.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _t = require_lib4();
    var _t2 = _t;
    var {
      react
    } = _t;
    var {
      cloneNode,
      jsxExpressionContainer,
      variableDeclaration,
      variableDeclarator
    } = _t2;
    var referenceVisitor = {
      ReferencedIdentifier(path3, state) {
        if (path3.isJSXIdentifier() && react.isCompatTag(path3.node.name) && !path3.parentPath.isJSXMemberExpression()) {
          return;
        }
        if (path3.node.name === "this") {
          let scope = path3.scope;
          do {
            if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
              break;
            }
          } while (scope = scope.parent);
          if (scope) state.breakOnScopePaths.push(scope.path);
        }
        const binding = path3.scope.getBinding(path3.node.name);
        if (!binding) return;
        for (const violation of binding.constantViolations) {
          if (violation.scope !== binding.path.scope) {
            state.mutableBinding = true;
            path3.stop();
            return;
          }
        }
        if (binding !== state.scope.getBinding(path3.node.name)) return;
        state.bindings[path3.node.name] = binding;
      }
    };
    var PathHoister = class {
      constructor(path3, scope) {
        this.breakOnScopePaths = void 0;
        this.bindings = void 0;
        this.mutableBinding = void 0;
        this.scopes = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.attachAfter = void 0;
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.mutableBinding = false;
        this.scopes = [];
        this.scope = scope;
        this.path = path3;
        this.attachAfter = false;
      }
      isCompatibleScope(scope) {
        for (const key of Object.keys(this.bindings)) {
          const binding = this.bindings[key];
          if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
            return false;
          }
        }
        return true;
      }
      getCompatibleScopes() {
        let scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }
          if (this.breakOnScopePaths.includes(scope.path)) {
            break;
          }
        } while (scope = scope.parent);
      }
      getAttachmentPath() {
        let path3 = this._getAttachmentPath();
        if (!path3) return;
        let targetScope = path3.scope;
        if (targetScope.path === path3) {
          targetScope = path3.scope.parent;
        }
        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (const name of Object.keys(this.bindings)) {
            if (!targetScope.hasOwnBinding(name)) continue;
            const binding = this.bindings[name];
            if (binding.kind === "param" || binding.path.parentKey === "params") {
              continue;
            }
            const bindingParentPath = this.getAttachmentParentForPath(binding.path);
            if (bindingParentPath.key >= path3.key) {
              this.attachAfter = true;
              path3 = binding.path;
              for (const violationPath of binding.constantViolations) {
                if (this.getAttachmentParentForPath(violationPath).key > path3.key) {
                  path3 = violationPath;
                }
              }
            }
          }
        }
        return path3;
      }
      _getAttachmentPath() {
        const scopes = this.scopes;
        const scope = scopes.pop();
        if (!scope) return;
        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope) return;
            const bodies = scope.path.get("body").get("body");
            for (let i = 0; i < bodies.length; i++) {
              if (bodies[i].node._blockHoist) continue;
              return bodies[i];
            }
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      }
      getNextScopeAttachmentParent() {
        const scope = this.scopes.pop();
        if (scope) return this.getAttachmentParentForPath(scope.path);
      }
      getAttachmentParentForPath(path3) {
        do {
          if (!path3.parentPath || Array.isArray(path3.container) && path3.isStatement()) {
            return path3;
          }
        } while (path3 = path3.parentPath);
      }
      hasOwnParamBindings(scope) {
        for (const name of Object.keys(this.bindings)) {
          if (!scope.hasOwnBinding(name)) continue;
          const binding = this.bindings[name];
          if (binding.kind === "param" && binding.constant) return true;
        }
        return false;
      }
      run() {
        this.path.traverse(referenceVisitor, this);
        if (this.mutableBinding) return;
        this.getCompatibleScopes();
        const attachTo = this.getAttachmentPath();
        if (!attachTo) return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
        let uid = attachTo.scope.generateUidIdentifier("ref");
        const declarator = variableDeclarator(uid, this.path.node);
        const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
        const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);
        const parent = this.path.parentPath;
        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = jsxExpressionContainer(uid);
        }
        this.path.replaceWith(cloneNode(uid));
        return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
      }
    };
    exports2.default = PathHoister;
  }
});

// node_modules/@babel/traverse/lib/path/modification.js
var require_modification = __commonJS({
  "node_modules/@babel/traverse/lib/path/modification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._containerInsert = _containerInsert;
    exports2._containerInsertAfter = _containerInsertAfter;
    exports2._containerInsertBefore = _containerInsertBefore;
    exports2._verifyNodeList = _verifyNodeList;
    exports2.insertAfter = insertAfter;
    exports2.insertBefore = insertBefore;
    exports2.pushContainer = pushContainer;
    exports2.unshiftContainer = unshiftContainer;
    exports2.updateSiblingKeys = updateSiblingKeys;
    var _cache = require_cache();
    var _index = require_path();
    var _context = require_context2();
    var _removal = require_removal();
    var _t = require_lib4();
    var _hoister = require_hoister();
    var {
      arrowFunctionExpression,
      assertExpression,
      assignmentExpression,
      blockStatement,
      callExpression,
      cloneNode,
      expressionStatement,
      isAssignmentExpression,
      isCallExpression,
      isExportNamedDeclaration,
      isExpression,
      isIdentifier,
      isSequenceExpression,
      isSuper,
      thisExpression
    } = _t;
    function insertBefore(nodes_) {
      _removal._assertUnremoved.call(this);
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes);
      } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node) nodes.push(this.node);
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertBefore.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
        return this.unshiftContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function _containerInsert(from, nodes) {
      updateSiblingKeys.call(this, from, nodes.length);
      const paths = [];
      this.container.splice(from, 0, ...nodes);
      for (let i = 0; i < nodes.length; i++) {
        var _this$context;
        const to = from + i;
        const path3 = this.getSibling(to);
        paths.push(path3);
        if ((_this$context = this.context) != null && _this$context.queue) {
          _context.pushContext.call(path3, this.context);
        }
      }
      const contexts = _context._getQueueContexts.call(this);
      for (const path3 of paths) {
        _context.setScope.call(path3);
        path3.debug("Inserted.");
        for (const context of contexts) {
          context.maybeQueue(path3, true);
        }
      }
      return paths;
    }
    function _containerInsertBefore(nodes) {
      return _containerInsert.call(this, this.key, nodes);
    }
    function _containerInsertAfter(nodes) {
      return _containerInsert.call(this, this.key + 1, nodes);
    }
    var last = (arr) => arr[arr.length - 1];
    function isHiddenInSequenceExpression(path3) {
      return isSequenceExpression(path3.parent) && (last(path3.parent.expressions) !== path3.node || isHiddenInSequenceExpression(path3.parentPath));
    }
    function isAlmostConstantAssignment(node, scope) {
      if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {
        return false;
      }
      const blockScope = scope.getBlockParent();
      return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
    }
    function insertAfter(nodes_) {
      _removal._assertUnremoved.call(this);
      if (this.isSequenceExpression()) {
        return last(this.get("expressions")).insertAfter(nodes_);
      }
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes.map((node) => {
          return isExpression(node) ? expressionStatement(node) : node;
        }));
      } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        const self2 = this;
        if (self2.node) {
          const node = self2.node;
          let {
            scope
          } = this;
          if (scope.path.isPattern()) {
            assertExpression(node);
            self2.replaceWith(callExpression(arrowFunctionExpression([], node), []));
            self2.get("callee.body").insertAfter(nodes);
            return [self2];
          }
          if (isHiddenInSequenceExpression(self2)) {
            nodes.unshift(node);
          } else if (isCallExpression(node) && isSuper(node.callee)) {
            nodes.unshift(node);
            nodes.push(thisExpression());
          } else if (isAlmostConstantAssignment(node, scope)) {
            nodes.unshift(node);
            nodes.push(cloneNode(node.left));
          } else if (scope.isPure(node, true)) {
            nodes.push(node);
          } else {
            if (parentPath.isMethod({
              computed: true,
              key: node
            })) {
              scope = scope.parent;
            }
            const temp = scope.generateDeclaredUidIdentifier();
            nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node)));
            nodes.push(expressionStatement(cloneNode(temp)));
          }
        }
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertAfter.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
        return this.pushContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent) return;
      const paths = (0, _cache.getCachedPaths)(this.hub, this.parent) || [];
      for (const [, path3] of paths) {
        if (typeof path3.key === "number" && path3.container === this.container && path3.key >= fromIndex) {
          path3.key += incrementBy;
        }
      }
    }
    function _verifyNodeList(nodes) {
      if (!nodes) {
        return [];
      }
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        let msg;
        if (!node) {
          msg = "has falsy node";
        } else if (typeof node !== "object") {
          msg = "contains a non-object node";
        } else if (!node.type) {
          msg = "without a type";
        } else if (node instanceof _index.default) {
          msg = "has a NodePath when it expected a raw object";
        }
        if (msg) {
          const type = Array.isArray(node) ? "array" : typeof node;
          throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
        }
      }
      return nodes;
    }
    function unshiftContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      nodes = _verifyNodeList.call(this, nodes);
      const path3 = _index.default.get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey,
        key: 0
      }).setContext(this.context);
      return _containerInsertBefore.call(path3, nodes);
    }
    function pushContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      const verifiedNodes = _verifyNodeList.call(this, nodes);
      const container = this.node[listKey];
      const path3 = _index.default.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: container.length
      }).setContext(this.context);
      return path3.replaceWithMultiple(verifiedNodes);
    }
    {
      exports2.hoist = function hoist(scope = this.scope) {
        const hoister = new _hoister.default(this, scope);
        return hoister.run();
      };
    }
  }
});

// node_modules/@babel/traverse/lib/path/replacement.js
var require_replacement = __commonJS({
  "node_modules/@babel/traverse/lib/path/replacement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._replaceWith = _replaceWith;
    exports2.replaceExpressionWithStatements = replaceExpressionWithStatements;
    exports2.replaceInline = replaceInline;
    exports2.replaceWith = replaceWith;
    exports2.replaceWithMultiple = replaceWithMultiple;
    exports2.replaceWithSourceString = replaceWithSourceString;
    var _codeFrame = require_lib6();
    var _index = require_lib8();
    var _index2 = require_path();
    var _cache = require_cache();
    var _modification = require_modification();
    var _parser = require_lib();
    var _t = require_lib4();
    var _context = require_context2();
    var {
      FUNCTION_TYPES,
      arrowFunctionExpression,
      assignmentExpression,
      awaitExpression,
      blockStatement,
      buildUndefinedNode,
      callExpression,
      cloneNode,
      conditionalExpression,
      expressionStatement,
      getBindingIdentifiers,
      identifier,
      inheritLeadingComments,
      inheritTrailingComments,
      inheritsComments,
      isBlockStatement,
      isEmptyStatement,
      isExpression,
      isExpressionStatement,
      isIfStatement,
      isProgram,
      isStatement,
      isVariableDeclaration,
      removeComments,
      returnStatement,
      sequenceExpression,
      validate,
      yieldExpression
    } = _t;
    function replaceWithMultiple(nodes) {
      var _getCachedPaths;
      _context.resync.call(this);
      nodes = _modification._verifyNodeList.call(this, nodes);
      inheritLeadingComments(nodes[0], this.node);
      inheritTrailingComments(nodes[nodes.length - 1], this.node);
      (_getCachedPaths = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths.delete(this.node);
      this.node = this.container[this.key] = null;
      const paths = this.insertAfter(nodes);
      if (this.node) {
        this.requeue();
      } else {
        this.remove();
      }
      return paths;
    }
    function replaceWithSourceString(replacement) {
      _context.resync.call(this);
      let ast;
      try {
        replacement = `(${replacement})`;
        ast = (0, _parser.parse)(replacement);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          });
          err.code = "BABEL_REPLACE_SOURCE_ERROR";
        }
        throw err;
      }
      const expressionAST = ast.program.body[0].expression;
      _index.default.removeProperties(expressionAST);
      return this.replaceWith(expressionAST);
    }
    function replaceWith(replacementPath) {
      _context.resync.call(this);
      if (this.removed) {
        throw new Error("You can't replace this node, we've already removed it");
      }
      let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
      if (!replacement) {
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      }
      if (this.node === replacement) {
        return [this];
      }
      if (this.isProgram() && !isProgram(replacement)) {
        throw new Error("You can only replace a Program root node with another Program node");
      }
      if (Array.isArray(replacement)) {
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      }
      if (typeof replacement === "string") {
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      }
      let nodePath = "";
      if (this.isNodeType("Statement") && isExpression(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
          replacement = expressionStatement(replacement);
          nodePath = "expression";
        }
      }
      if (this.isNodeType("Expression") && isStatement(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
          return this.replaceExpressionWithStatements([replacement]);
        }
      }
      const oldNode = this.node;
      if (oldNode) {
        inheritsComments(replacement, oldNode);
        removeComments(oldNode);
      }
      _replaceWith.call(this, replacement);
      this.type = replacement.type;
      _context.setScope.call(this);
      this.requeue();
      return [nodePath ? this.get(nodePath) : this];
    }
    function _replaceWith(node) {
      var _getCachedPaths2;
      if (!this.container) {
        throw new ReferenceError("Container is falsy");
      }
      if (this.inList) {
        validate(this.parent, this.key, [node]);
      } else {
        validate(this.parent, this.key, node);
      }
      this.debug(`Replace with ${node == null ? void 0 : node.type}`);
      (_getCachedPaths2 = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths2.set(node, this).delete(this.node);
      this.node = this.container[this.key] = node;
    }
    function replaceExpressionWithStatements(nodes) {
      _context.resync.call(this);
      const declars = [];
      const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);
      if (nodesAsSingleExpression) {
        for (const id of declars) this.scope.push({
          id
        });
        return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
      }
      const functionParent = this.getFunctionParent();
      const isParentAsync = functionParent == null ? void 0 : functionParent.node.async;
      const isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;
      const container = arrowFunctionExpression([], blockStatement(nodes));
      this.replaceWith(callExpression(container, []));
      const callee = this.get("callee");
      callee.get("body").scope.hoistVariables((id) => this.scope.push({
        id
      }));
      const completionRecords = callee.getCompletionRecords();
      for (const path3 of completionRecords) {
        if (!path3.isExpressionStatement()) continue;
        const loop = path3.findParent((path4) => path4.isLoop());
        if (loop) {
          let uid = loop.getData("expressionReplacementReturnUid");
          if (!uid) {
            uid = callee.scope.generateDeclaredUidIdentifier("ret");
            callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
            loop.setData("expressionReplacementReturnUid", uid);
          } else {
            uid = identifier(uid.name);
          }
          path3.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path3.node.expression));
        } else {
          path3.replaceWith(returnStatement(path3.node.expression));
        }
      }
      callee.arrowFunctionToExpression();
      const newCallee = callee;
      const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
      const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
      if (needToAwaitFunction) {
        newCallee.set("async", true);
        if (!needToYieldFunction) {
          this.replaceWith(awaitExpression(this.node));
        }
      }
      if (needToYieldFunction) {
        newCallee.set("generator", true);
        this.replaceWith(yieldExpression(this.node, true));
      }
      return newCallee.get("body.body");
    }
    function gatherSequenceExpressions(nodes, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!isEmptyStatement(node)) {
          ensureLastUndefined = false;
        }
        if (isExpression(node)) {
          exprs.push(node);
        } else if (isExpressionStatement(node)) {
          exprs.push(node.expression);
        } else if (isVariableDeclaration(node)) {
          if (node.kind !== "var") return;
          for (const declar of node.declarations) {
            const bindings = getBindingIdentifiers(declar);
            for (const key of Object.keys(bindings)) {
              declars.push(cloneNode(bindings[key]));
            }
            if (declar.init) {
              exprs.push(assignmentExpression("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if (isIfStatement(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode();
          if (!consequent || !alternate) return;
          exprs.push(conditionalExpression(node.test, consequent, alternate));
        } else if (isBlockStatement(node)) {
          const body = gatherSequenceExpressions(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if (isEmptyStatement(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) exprs.push(buildUndefinedNode());
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return sequenceExpression(exprs);
      }
    }
    function replaceInline(nodes) {
      _context.resync.call(this);
      if (Array.isArray(nodes)) {
        if (Array.isArray(this.container)) {
          nodes = _modification._verifyNodeList.call(this, nodes);
          const paths = _modification._containerInsertAfter.call(this, nodes);
          this.remove();
          return paths;
        } else {
          return this.replaceWithMultiple(nodes);
        }
      } else {
        return this.replaceWith(nodes);
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/evaluation.js
var require_evaluation = __commonJS({
  "node_modules/@babel/traverse/lib/path/evaluation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.evaluate = evaluate;
    exports2.evaluateTruthy = evaluateTruthy;
    var VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
    var VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
    var INVALID_METHODS = ["random"];
    function isValidObjectCallee(val) {
      return VALID_OBJECT_CALLEES.includes(val);
    }
    function isValidIdentifierCallee(val) {
      return VALID_IDENTIFIER_CALLEES.includes(val);
    }
    function isInvalidMethod(val) {
      return INVALID_METHODS.includes(val);
    }
    function evaluateTruthy() {
      const res = this.evaluate();
      if (res.confident) return !!res.value;
    }
    function deopt(path3, state) {
      if (!state.confident) return;
      state.deoptPath = path3;
      state.confident = false;
    }
    var Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", Infinity], ["NaN", NaN]]);
    function evaluateCached(path3, state) {
      const {
        node
      } = path3;
      const {
        seen
      } = state;
      if (seen.has(node)) {
        const existing = seen.get(node);
        if (existing.resolved) {
          return existing.value;
        } else {
          deopt(path3, state);
          return;
        }
      } else {
        const item = {
          resolved: false
        };
        seen.set(node, item);
        const val = _evaluate(path3, state);
        if (state.confident) {
          item.resolved = true;
          item.value = val;
        }
        return val;
      }
    }
    function _evaluate(path3, state) {
      if (!state.confident) return;
      if (path3.isSequenceExpression()) {
        const exprs = path3.get("expressions");
        return evaluateCached(exprs[exprs.length - 1], state);
      }
      if (path3.isStringLiteral() || path3.isNumericLiteral() || path3.isBooleanLiteral()) {
        return path3.node.value;
      }
      if (path3.isNullLiteral()) {
        return null;
      }
      if (path3.isTemplateLiteral()) {
        return evaluateQuasis(path3, path3.node.quasis, state);
      }
      if (path3.isTaggedTemplateExpression() && path3.get("tag").isMemberExpression()) {
        const object = path3.get("tag.object");
        const {
          node: {
            name
          }
        } = object;
        const property = path3.get("tag.property");
        if (object.isIdentifier() && name === "String" && !path3.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
          return evaluateQuasis(path3, path3.node.quasi.quasis, state, true);
        }
      }
      if (path3.isConditionalExpression()) {
        const testResult = evaluateCached(path3.get("test"), state);
        if (!state.confident) return;
        if (testResult) {
          return evaluateCached(path3.get("consequent"), state);
        } else {
          return evaluateCached(path3.get("alternate"), state);
        }
      }
      if (path3.isExpressionWrapper()) {
        return evaluateCached(path3.get("expression"), state);
      }
      if (path3.isMemberExpression() && !path3.parentPath.isCallExpression({
        callee: path3.node
      })) {
        const property = path3.get("property");
        const object = path3.get("object");
        if (object.isLiteral()) {
          const value = object.node.value;
          const type = typeof value;
          let key = null;
          if (path3.node.computed) {
            key = evaluateCached(property, state);
            if (!state.confident) return;
          } else if (property.isIdentifier()) {
            key = property.node.name;
          }
          if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
            return value[key];
          }
        }
      }
      if (path3.isReferencedIdentifier()) {
        const binding = path3.scope.getBinding(path3.node.name);
        if (binding) {
          if (binding.constantViolations.length > 0 || path3.node.start < binding.path.node.end) {
            deopt(binding.path, state);
            return;
          }
          if (binding.hasValue) {
            return binding.value;
          }
        }
        const name = path3.node.name;
        if (Globals.has(name)) {
          if (!binding) {
            return Globals.get(name);
          }
          deopt(binding.path, state);
          return;
        }
        const resolved = path3.resolve();
        if (resolved === path3) {
          deopt(path3, state);
          return;
        } else {
          return evaluateCached(resolved, state);
        }
      }
      if (path3.isUnaryExpression({
        prefix: true
      })) {
        if (path3.node.operator === "void") {
          return void 0;
        }
        const argument = path3.get("argument");
        if (path3.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
          return "function";
        }
        const arg = evaluateCached(argument, state);
        if (!state.confident) return;
        switch (path3.node.operator) {
          case "!":
            return !arg;
          case "+":
            return +arg;
          case "-":
            return -arg;
          case "~":
            return ~arg;
          case "typeof":
            return typeof arg;
        }
      }
      if (path3.isArrayExpression()) {
        const arr = [];
        const elems = path3.get("elements");
        for (const elem of elems) {
          const elemValue = elem.evaluate();
          if (elemValue.confident) {
            arr.push(elemValue.value);
          } else {
            deopt(elemValue.deopt, state);
            return;
          }
        }
        return arr;
      }
      if (path3.isObjectExpression()) {
        const obj = {};
        const props = path3.get("properties");
        for (const prop of props) {
          if (prop.isObjectMethod() || prop.isSpreadElement()) {
            deopt(prop, state);
            return;
          }
          const keyPath = prop.get("key");
          let key;
          if (prop.node.computed) {
            key = keyPath.evaluate();
            if (!key.confident) {
              deopt(key.deopt, state);
              return;
            }
            key = key.value;
          } else if (keyPath.isIdentifier()) {
            key = keyPath.node.name;
          } else {
            key = keyPath.node.value;
          }
          const valuePath = prop.get("value");
          let value = valuePath.evaluate();
          if (!value.confident) {
            deopt(value.deopt, state);
            return;
          }
          value = value.value;
          obj[key] = value;
        }
        return obj;
      }
      if (path3.isLogicalExpression()) {
        const wasConfident = state.confident;
        const left = evaluateCached(path3.get("left"), state);
        const leftConfident = state.confident;
        state.confident = wasConfident;
        const right = evaluateCached(path3.get("right"), state);
        const rightConfident = state.confident;
        switch (path3.node.operator) {
          case "||":
            state.confident = leftConfident && (!!left || rightConfident);
            if (!state.confident) return;
            return left || right;
          case "&&":
            state.confident = leftConfident && (!left || rightConfident);
            if (!state.confident) return;
            return left && right;
          case "??":
            state.confident = leftConfident && (left != null || rightConfident);
            if (!state.confident) return;
            return left != null ? left : right;
        }
      }
      if (path3.isBinaryExpression()) {
        const left = evaluateCached(path3.get("left"), state);
        if (!state.confident) return;
        const right = evaluateCached(path3.get("right"), state);
        if (!state.confident) return;
        switch (path3.node.operator) {
          case "-":
            return left - right;
          case "+":
            return left + right;
          case "/":
            return left / right;
          case "*":
            return left * right;
          case "%":
            return left % right;
          case "**":
            return Math.pow(left, right);
          case "<":
            return left < right;
          case ">":
            return left > right;
          case "<=":
            return left <= right;
          case ">=":
            return left >= right;
          case "==":
            return left == right;
          case "!=":
            return left != right;
          case "===":
            return left === right;
          case "!==":
            return left !== right;
          case "|":
            return left | right;
          case "&":
            return left & right;
          case "^":
            return left ^ right;
          case "<<":
            return left << right;
          case ">>":
            return left >> right;
          case ">>>":
            return left >>> right;
        }
      }
      if (path3.isCallExpression()) {
        const callee = path3.get("callee");
        let context;
        let func;
        if (callee.isIdentifier() && !path3.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
          func = global[callee.node.name];
        }
        if (callee.isMemberExpression()) {
          const object = callee.get("object");
          const property = callee.get("property");
          if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
            context = global[object.node.name];
            const key = property.node.name;
            if (hasOwnProperty.call(context, key)) {
              func = context[key];
            }
          }
          if (object.isLiteral() && property.isIdentifier()) {
            const type = typeof object.node.value;
            if (type === "string" || type === "number") {
              context = object.node.value;
              func = context[property.node.name];
            }
          }
        }
        if (func) {
          const args = path3.get("arguments").map((arg) => evaluateCached(arg, state));
          if (!state.confident) return;
          return func.apply(context, args);
        }
      }
      deopt(path3, state);
    }
    function evaluateQuasis(path3, quasis, state, raw = false) {
      let str = "";
      let i = 0;
      const exprs = path3.isTemplateLiteral() ? path3.get("expressions") : path3.get("quasi.expressions");
      for (const elem of quasis) {
        if (!state.confident) break;
        str += raw ? elem.value.raw : elem.value.cooked;
        const expr = exprs[i++];
        if (expr) str += String(evaluateCached(expr, state));
      }
      if (!state.confident) return;
      return str;
    }
    function evaluate() {
      const state = {
        confident: true,
        deoptPath: null,
        seen: /* @__PURE__ */ new Map()
      };
      let value = evaluateCached(this, state);
      if (!state.confident) value = void 0;
      return {
        confident: state.confident,
        deopt: state.deoptPath,
        value
      };
    }
  }
});

// node_modules/@babel/template/lib/formatters.js
var require_formatters = __commonJS({
  "node_modules/@babel/template/lib/formatters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.statements = exports2.statement = exports2.smart = exports2.program = exports2.expression = void 0;
    var _t = require_lib4();
    var {
      assertExpressionStatement
    } = _t;
    function makeStatementFormatter(fn) {
      return {
        code: (str) => `/* @babel/template */;
${str}`,
        validate: () => {
        },
        unwrap: (ast) => {
          return fn(ast.program.body.slice(1));
        }
      };
    }
    var smart = exports2.smart = makeStatementFormatter((body) => {
      if (body.length > 1) {
        return body;
      } else {
        return body[0];
      }
    });
    var statements = exports2.statements = makeStatementFormatter((body) => body);
    var statement = exports2.statement = makeStatementFormatter((body) => {
      if (body.length === 0) {
        throw new Error("Found nothing to return.");
      }
      if (body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      return body[0];
    });
    var expression = exports2.expression = {
      code: (str) => `(
${str}
)`,
      validate: (ast) => {
        if (ast.program.body.length > 1) {
          throw new Error("Found multiple statements but wanted one");
        }
        if (expression.unwrap(ast).start === 0) {
          throw new Error("Parse result included parens.");
        }
      },
      unwrap: ({
        program: program4
      }) => {
        const [stmt] = program4.body;
        assertExpressionStatement(stmt);
        return stmt.expression;
      }
    };
    var program3 = exports2.program = {
      code: (str) => str,
      validate: () => {
      },
      unwrap: (ast) => ast.program
    };
  }
});

// node_modules/@babel/template/lib/options.js
var require_options = __commonJS({
  "node_modules/@babel/template/lib/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.merge = merge;
    exports2.normalizeReplacements = normalizeReplacements;
    exports2.validate = validate;
    var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t3 = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t3[n] = r[n];
      }
      return t3;
    }
    function merge(a, b) {
      const {
        placeholderWhitelist = a.placeholderWhitelist,
        placeholderPattern = a.placeholderPattern,
        preserveComments = a.preserveComments,
        syntacticPlaceholders = a.syntacticPlaceholders
      } = b;
      return {
        parser: Object.assign({}, a.parser, b.parser),
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      };
    }
    function validate(opts) {
      if (opts != null && typeof opts !== "object") {
        throw new Error("Unknown template options.");
      }
      const _ref = opts || {}, {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = _ref, parser = _objectWithoutPropertiesLoose(_ref, _excluded);
      if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
        throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
      }
      if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
        throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
      }
      if (preserveComments != null && typeof preserveComments !== "boolean") {
        throw new Error("'.preserveComments' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
        throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      return {
        parser,
        placeholderWhitelist: placeholderWhitelist || void 0,
        placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
        preserveComments: preserveComments == null ? void 0 : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
      };
    }
    function normalizeReplacements(replacements) {
      if (Array.isArray(replacements)) {
        return replacements.reduce((acc, replacement, i) => {
          acc["$" + i] = replacement;
          return acc;
        }, {});
      } else if (typeof replacements === "object" || replacements == null) {
        return replacements || void 0;
      }
      throw new Error("Template replacements must be an array, object, null, or undefined");
    }
  }
});

// node_modules/@babel/template/lib/parse.js
var require_parse = __commonJS({
  "node_modules/@babel/template/lib/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = parseAndBuildMetadata;
    var _t = require_lib4();
    var _parser = require_lib();
    var _codeFrame = require_lib6();
    var {
      isCallExpression,
      isExpressionStatement,
      isFunction,
      isIdentifier,
      isJSXIdentifier: isJSXIdentifier2,
      isNewExpression,
      isPlaceholder,
      isStatement,
      isStringLiteral: isStringLiteral3,
      removePropertiesDeep,
      traverse: traverse3
    } = _t;
    var PATTERN = /^[_$A-Z0-9]+$/;
    function parseAndBuildMetadata(formatter, code, opts) {
      const {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = opts;
      const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
      removePropertiesDeep(ast, {
        preserveComments
      });
      formatter.validate(ast);
      const state = {
        syntactic: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        legacy: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders
      };
      traverse3(ast, placeholderVisitorHandler, state);
      return Object.assign({
        ast
      }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
    }
    function placeholderVisitorHandler(node, ancestors, state) {
      var _state$placeholderWhi;
      let name;
      let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
      if (isPlaceholder(node)) {
        if (state.syntacticPlaceholders === false) {
          throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
        }
        name = node.name.name;
        hasSyntacticPlaceholders = true;
      } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
        return;
      } else if (isIdentifier(node) || isJSXIdentifier2(node)) {
        name = node.name;
      } else if (isStringLiteral3(node)) {
        name = node.value;
      } else {
        return;
      }
      if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
        return;
      }
      ancestors = ancestors.slice();
      const {
        node: parent,
        key
      } = ancestors[ancestors.length - 1];
      let type;
      if (isStringLiteral3(node) || isPlaceholder(node, {
        expectedNode: "StringLiteral"
      })) {
        type = "string";
      } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
        type = "param";
      } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
        type = "statement";
        ancestors = ancestors.slice(0, -1);
      } else if (isStatement(node) && isPlaceholder(node)) {
        type = "statement";
      } else {
        type = "other";
      }
      const {
        placeholders,
        placeholderNames
      } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
      placeholders.push({
        name,
        type,
        resolve: (ast) => resolveAncestors(ast, ancestors),
        isDuplicate: placeholderNames.has(name)
      });
      placeholderNames.add(name);
    }
    function resolveAncestors(ast, ancestors) {
      let parent = ast;
      for (let i = 0; i < ancestors.length - 1; i++) {
        const {
          key: key2,
          index: index2
        } = ancestors[i];
        if (index2 === void 0) {
          parent = parent[key2];
        } else {
          parent = parent[key2][index2];
        }
      }
      const {
        key,
        index
      } = ancestors[ancestors.length - 1];
      return {
        parent,
        key,
        index
      };
    }
    function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
      const plugins = (parserOpts.plugins || []).slice();
      if (syntacticPlaceholders !== false) {
        plugins.push("placeholders");
      }
      parserOpts = Object.assign({
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        sourceType: "module"
      }, parserOpts, {
        plugins
      });
      try {
        return (0, _parser.parse)(code, parserOpts);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
            start: loc
          });
          err.code = "BABEL_TEMPLATE_PARSE_ERROR";
        }
        throw err;
      }
    }
  }
});

// node_modules/@babel/template/lib/populate.js
var require_populate = __commonJS({
  "node_modules/@babel/template/lib/populate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = populatePlaceholders;
    var _t = require_lib4();
    var {
      blockStatement,
      cloneNode,
      emptyStatement,
      expressionStatement,
      identifier,
      isStatement,
      isStringLiteral: isStringLiteral3,
      stringLiteral,
      validate
    } = _t;
    function populatePlaceholders(metadata, replacements) {
      const ast = cloneNode(metadata.ast);
      if (replacements) {
        metadata.placeholders.forEach((placeholder) => {
          if (!hasOwnProperty.call(replacements, placeholder.name)) {
            const placeholderName = placeholder.name;
            throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
          }
        });
        Object.keys(replacements).forEach((key) => {
          if (!metadata.placeholderNames.has(key)) {
            throw new Error(`Unknown substitution "${key}" given`);
          }
        });
      }
      metadata.placeholders.slice().reverse().forEach((placeholder) => {
        try {
          applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
        } catch (e) {
          e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
          throw e;
        }
      });
      return ast;
    }
    function applyReplacement(placeholder, ast, replacement) {
      if (placeholder.isDuplicate) {
        if (Array.isArray(replacement)) {
          replacement = replacement.map((node) => cloneNode(node));
        } else if (typeof replacement === "object") {
          replacement = cloneNode(replacement);
        }
      }
      const {
        parent,
        key,
        index
      } = placeholder.resolve(ast);
      if (placeholder.type === "string") {
        if (typeof replacement === "string") {
          replacement = stringLiteral(replacement);
        }
        if (!replacement || !isStringLiteral3(replacement)) {
          throw new Error("Expected string substitution");
        }
      } else if (placeholder.type === "statement") {
        if (index === void 0) {
          if (!replacement) {
            replacement = emptyStatement();
          } else if (Array.isArray(replacement)) {
            replacement = blockStatement(replacement);
          } else if (typeof replacement === "string") {
            replacement = expressionStatement(identifier(replacement));
          } else if (!isStatement(replacement)) {
            replacement = expressionStatement(replacement);
          }
        } else {
          if (replacement && !Array.isArray(replacement)) {
            if (typeof replacement === "string") {
              replacement = identifier(replacement);
            }
            if (!isStatement(replacement)) {
              replacement = expressionStatement(replacement);
            }
          }
        }
      } else if (placeholder.type === "param") {
        if (typeof replacement === "string") {
          replacement = identifier(replacement);
        }
        if (index === void 0) throw new Error("Assertion failure.");
      } else {
        if (typeof replacement === "string") {
          replacement = identifier(replacement);
        }
        if (Array.isArray(replacement)) {
          throw new Error("Cannot replace single expression with an array.");
        }
      }
      function set(parent2, key2, value) {
        const node = parent2[key2];
        parent2[key2] = value;
        if (node.type === "Identifier" || node.type === "Placeholder") {
          if (node.typeAnnotation) {
            value.typeAnnotation = node.typeAnnotation;
          }
          if (node.optional) {
            value.optional = node.optional;
          }
          if (node.decorators) {
            value.decorators = node.decorators;
          }
        }
      }
      if (index === void 0) {
        validate(parent, key, replacement);
        set(parent, key, replacement);
      } else {
        const items = parent[key].slice();
        if (placeholder.type === "statement" || placeholder.type === "param") {
          if (replacement == null) {
            items.splice(index, 1);
          } else if (Array.isArray(replacement)) {
            items.splice(index, 1, ...replacement);
          } else {
            set(items, index, replacement);
          }
        } else {
          set(items, index, replacement);
        }
        validate(parent, key, items);
        parent[key] = items;
      }
    }
  }
});

// node_modules/@babel/template/lib/string.js
var require_string = __commonJS({
  "node_modules/@babel/template/lib/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = stringTemplate;
    var _options = require_options();
    var _parse = require_parse();
    var _populate = require_populate();
    function stringTemplate(formatter, code, opts) {
      code = formatter.code(code);
      let metadata;
      return (arg) => {
        const replacements = (0, _options.normalizeReplacements)(arg);
        if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);
        return formatter.unwrap((0, _populate.default)(metadata, replacements));
      };
    }
  }
});

// node_modules/@babel/template/lib/literal.js
var require_literal = __commonJS({
  "node_modules/@babel/template/lib/literal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = literalTemplate;
    var _options = require_options();
    var _parse = require_parse();
    var _populate = require_populate();
    function literalTemplate(formatter, tpl, opts) {
      const {
        metadata,
        names
      } = buildLiteralData(formatter, tpl, opts);
      return (arg) => {
        const defaultReplacements = {};
        arg.forEach((replacement, i) => {
          defaultReplacements[names[i]] = replacement;
        });
        return (arg2) => {
          const replacements = (0, _options.normalizeReplacements)(arg2);
          if (replacements) {
            Object.keys(replacements).forEach((key) => {
              if (hasOwnProperty.call(defaultReplacements, key)) {
                throw new Error("Unexpected replacement overlap.");
              }
            });
          }
          return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
      };
    }
    function buildLiteralData(formatter, tpl, opts) {
      let prefix = "BABEL_TPL$";
      const raw = tpl.join("");
      do {
        prefix = "$$" + prefix;
      } while (raw.includes(prefix));
      const {
        names,
        code
      } = buildTemplateCode(tpl, prefix);
      const metadata = (0, _parse.default)(formatter, formatter.code(code), {
        parser: opts.parser,
        placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
      });
      return {
        metadata,
        names
      };
    }
    function buildTemplateCode(tpl, prefix) {
      const names = [];
      let code = tpl[0];
      for (let i = 1; i < tpl.length; i++) {
        const value = `${prefix}${i - 1}`;
        names.push(value);
        code += value + tpl[i];
      }
      return {
        names,
        code
      };
    }
  }
});

// node_modules/@babel/template/lib/builder.js
var require_builder = __commonJS({
  "node_modules/@babel/template/lib/builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createTemplateBuilder;
    var _options = require_options();
    var _string = require_string();
    var _literal = require_literal();
    var NO_PLACEHOLDER = (0, _options.validate)({
      placeholderPattern: false
    });
    function createTemplateBuilder(formatter, defaultOpts) {
      const templateFnCache = /* @__PURE__ */ new WeakMap();
      const templateAstCache = /* @__PURE__ */ new WeakMap();
      const cachedOpts = defaultOpts || (0, _options.validate)(null);
      return Object.assign((tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
        } else if (Array.isArray(tpl)) {
          let builder = templateFnCache.get(tpl);
          if (!builder) {
            builder = (0, _literal.default)(formatter, tpl, cachedOpts);
            templateFnCache.set(tpl, builder);
          }
          return extendedTrace(builder(args));
        } else if (typeof tpl === "object" && tpl) {
          if (args.length > 0) throw new Error("Unexpected extra params.");
          return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }, {
        ast: (tpl, ...args) => {
          if (typeof tpl === "string") {
            if (args.length > 1) throw new Error("Unexpected extra params.");
            return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
          } else if (Array.isArray(tpl)) {
            let builder = templateAstCache.get(tpl);
            if (!builder) {
              builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
              templateAstCache.set(tpl, builder);
            }
            return builder(args)();
          }
          throw new Error(`Unexpected template param ${typeof tpl}`);
        }
      });
    }
    function extendedTrace(fn) {
      let rootStack = "";
      try {
        throw new Error();
      } catch (error) {
        if (error.stack) {
          rootStack = error.stack.split("\n").slice(3).join("\n");
        }
      }
      return (arg) => {
        try {
          return fn(arg);
        } catch (err) {
          err.stack += `
    =============
${rootStack}`;
          throw err;
        }
      };
    }
  }
});

// node_modules/@babel/template/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@babel/template/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.statements = exports2.statement = exports2.smart = exports2.program = exports2.expression = exports2.default = void 0;
    var formatters = require_formatters();
    var _builder = require_builder();
    var smart = exports2.smart = (0, _builder.default)(formatters.smart);
    var statement = exports2.statement = (0, _builder.default)(formatters.statement);
    var statements = exports2.statements = (0, _builder.default)(formatters.statements);
    var expression = exports2.expression = (0, _builder.default)(formatters.expression);
    var program3 = exports2.program = (0, _builder.default)(formatters.program);
    var _default = exports2.default = Object.assign(smart.bind(void 0), {
      smart,
      statement,
      statements,
      expression,
      program: program3,
      ast: smart.ast
    });
  }
});

// node_modules/@babel/traverse/lib/path/conversion.js
var require_conversion = __commonJS({
  "node_modules/@babel/traverse/lib/path/conversion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.arrowFunctionToExpression = arrowFunctionToExpression;
    exports2.ensureBlock = ensureBlock;
    exports2.ensureFunctionName = ensureFunctionName;
    exports2.splitExportDeclaration = splitExportDeclaration;
    exports2.toComputedKey = toComputedKey;
    exports2.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
    var _t = require_lib4();
    var _template = require_lib7();
    var _visitors = require_visitors();
    var _context = require_context2();
    var {
      arrowFunctionExpression,
      assignmentExpression,
      binaryExpression,
      blockStatement,
      callExpression,
      conditionalExpression,
      expressionStatement,
      identifier,
      isIdentifier,
      jsxIdentifier,
      logicalExpression,
      LOGICAL_OPERATORS,
      memberExpression,
      metaProperty,
      numericLiteral,
      objectExpression,
      restElement,
      returnStatement,
      sequenceExpression,
      spreadElement,
      stringLiteral,
      super: _super,
      thisExpression,
      toExpression,
      unaryExpression,
      toBindingIdentifierName,
      isFunction,
      isAssignmentPattern,
      isRestElement,
      getFunctionName,
      cloneNode,
      variableDeclaration,
      variableDeclarator,
      exportNamedDeclaration,
      exportSpecifier,
      inherits
    } = _t;
    function toComputedKey() {
      let key;
      if (this.isMemberExpression()) {
        key = this.node.property;
      } else if (this.isProperty() || this.isMethod()) {
        key = this.node.key;
      } else {
        throw new ReferenceError("todo");
      }
      if (!this.node.computed) {
        if (isIdentifier(key)) key = stringLiteral(key.name);
      }
      return key;
    }
    function ensureBlock() {
      const body = this.get("body");
      const bodyNode = body.node;
      if (Array.isArray(body)) {
        throw new Error("Can't convert array path to a block statement");
      }
      if (!bodyNode) {
        throw new Error("Can't convert node without a body");
      }
      if (body.isBlockStatement()) {
        return bodyNode;
      }
      const statements = [];
      let stringPath = "body";
      let key;
      let listKey;
      if (body.isStatement()) {
        listKey = "body";
        key = 0;
        statements.push(body.node);
      } else {
        stringPath += ".body.0";
        if (this.isFunction()) {
          key = "argument";
          statements.push(returnStatement(body.node));
        } else {
          key = "expression";
          statements.push(expressionStatement(body.node));
        }
      }
      this.node.body = blockStatement(statements);
      const parentPath = this.get(stringPath);
      _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
      return this.node;
    }
    {
      exports2.arrowFunctionToShadowed = function() {
        if (!this.isArrowFunctionExpression()) return;
        this.arrowFunctionToExpression();
      };
    }
    function unwrapFunctionEnvironment() {
      if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
      }
      hoistFunctionEnvironment(this);
    }
    function setType(path3, type) {
      path3.node.type = type;
    }
    function arrowFunctionToExpression({
      allowInsertArrow = true,
      allowInsertArrowWithRest = allowInsertArrow,
      noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()
    } = {}) {
      if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
      }
      let self2 = this;
      if (!noNewArrows) {
        var _self$ensureFunctionN;
        self2 = (_self$ensureFunctionN = self2.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self2;
      }
      const {
        thisBinding,
        fnPath: fn
      } = hoistFunctionEnvironment(self2, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
      fn.ensureBlock();
      setType(fn, "FunctionExpression");
      if (!noNewArrows) {
        const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
        if (checkBinding) {
          fn.parentPath.scope.push({
            id: checkBinding,
            init: objectExpression([])
          });
        }
        fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
        fn.replaceWith(callExpression(memberExpression(fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
        return fn.get("callee.object");
      }
      return fn;
    }
    var getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        allSuperCalls
      }) {
        if (!child.get("callee").isSuper()) return;
        allSuperCalls.push(child);
      }
    });
    function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
      let arrowParent;
      let thisEnvFn = fnPath.findParent((p) => {
        if (p.isArrowFunctionExpression()) {
          var _arrowParent;
          (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
          return false;
        }
        return p.isFunction() || p.isProgram() || p.isClassProperty({
          static: false
        }) || p.isClassPrivateProperty({
          static: false
        });
      });
      const inConstructor = thisEnvFn.isClassMethod({
        kind: "constructor"
      });
      if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
        if (arrowParent) {
          thisEnvFn = arrowParent;
        } else if (allowInsertArrow) {
          fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
          thisEnvFn = fnPath.get("callee");
          fnPath = thisEnvFn.get("body");
        } else {
          throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
        }
      }
      const {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      } = getScopeInformation(fnPath);
      if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        if (!allowInsertArrowWithRest) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const allSuperCalls = [];
        thisEnvFn.traverse(getSuperCallsVisitor, {
          allSuperCalls
        });
        const superBinding = getSuperBinding(thisEnvFn);
        allSuperCalls.forEach((superCall) => {
          const callee = identifier(superBinding);
          callee.loc = superCall.node.callee.loc;
          superCall.get("callee").replaceWith(callee);
        });
      }
      if (argumentsPaths.length > 0) {
        const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
          const args = () => identifier("arguments");
          if (thisEnvFn.scope.path.isProgram()) {
            return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
          } else {
            return args();
          }
        });
        argumentsPaths.forEach((argumentsChild) => {
          const argsRef = identifier(argumentsBinding);
          argsRef.loc = argumentsChild.node.loc;
          argumentsChild.replaceWith(argsRef);
        });
      }
      if (newTargetPaths.length > 0) {
        const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
        newTargetPaths.forEach((targetChild) => {
          const targetRef = identifier(newTargetBinding);
          targetRef.loc = targetChild.node.loc;
          targetChild.replaceWith(targetRef);
        });
      }
      if (superProps.length > 0) {
        if (!allowInsertArrow) {
          throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
        flatSuperProps.forEach((superProp) => {
          const key = superProp.node.computed ? "" : superProp.get("property").node.name;
          const superParentPath = superProp.parentPath;
          const isAssignment = superParentPath.isAssignmentExpression({
            left: superProp.node
          });
          const isCall = superParentPath.isCallExpression({
            callee: superProp.node
          });
          const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
            tag: superProp.node
          });
          const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
          const args = [];
          if (superProp.node.computed) {
            args.push(superProp.get("property").node);
          }
          if (isAssignment) {
            const value = superParentPath.node.right;
            args.push(value);
          }
          const call = callExpression(identifier(superBinding), args);
          if (isCall) {
            superParentPath.unshiftContainer("arguments", thisExpression());
            superProp.replaceWith(memberExpression(call, identifier("call")));
            thisPaths.push(superParentPath.get("arguments.0"));
          } else if (isAssignment) {
            superParentPath.replaceWith(call);
          } else if (isTaggedTemplate) {
            superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), false), [thisExpression()]));
            thisPaths.push(superProp.get("arguments.0"));
          } else {
            superProp.replaceWith(call);
          }
        });
      }
      let thisBinding;
      if (thisPaths.length > 0 || !noNewArrows) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);
        if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
          thisPaths.forEach((thisChild) => {
            const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
            thisRef.loc = thisChild.node.loc;
            thisChild.replaceWith(thisRef);
          });
          if (!noNewArrows) thisBinding = null;
        }
      }
      return {
        thisBinding,
        fnPath
      };
    }
    function isLogicalOp(op) {
      return LOGICAL_OPERATORS.includes(op);
    }
    function standardizeSuperProperty(superProp) {
      if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
        const assignmentPath = superProp.parentPath;
        const op = assignmentPath.node.operator.slice(0, -1);
        const value = assignmentPath.node.right;
        const isLogicalAssignment = isLogicalOp(op);
        if (superProp.node.computed) {
          const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          const object = superProp.node.object;
          const property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));
        } else {
          const object = superProp.node.object;
          const property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression(object, property));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value));
        }
        if (isLogicalAssignment) {
          assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
        } else {
          assignmentPath.node.operator = "=";
        }
        return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
      } else if (superProp.parentPath.isUpdateExpression()) {
        const updateExpr = superProp.parentPath;
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
        const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
        if (!superProp.parentPath.node.prefix) {
          parts.push(identifier(tmp.name));
        }
        updateExpr.replaceWith(sequenceExpression(parts));
        const left = updateExpr.get("expressions.0.right");
        const right = updateExpr.get("expressions.1.left");
        return [left, right];
      }
      return [superProp];
      function rightExpression(op, left, right) {
        if (op === "=") {
          return assignmentExpression("=", left, right);
        } else {
          return binaryExpression(op, left, right);
        }
      }
    }
    function hasSuperClass(thisEnvFn) {
      return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
    }
    var assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        supers,
        thisBinding
      }) {
        if (!child.get("callee").isSuper()) return;
        if (supers.has(child.node)) return;
        supers.add(child.node);
        child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
      }
    });
    function getThisBinding(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", (thisBinding) => {
        if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
        thisEnvFn.traverse(assignSuperThisVisitor, {
          supers: /* @__PURE__ */ new WeakSet(),
          thisBinding
        });
      });
    }
    function getSuperBinding(thisEnvFn) {
      return getBinding(thisEnvFn, "supercall", () => {
        const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
        return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
      });
    }
    function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
      const op = isAssignment ? "set" : "get";
      return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
        const argsList = [];
        let fnBody;
        if (propName) {
          fnBody = memberExpression(_super(), identifier(propName));
        } else {
          const method = thisEnvFn.scope.generateUidIdentifier("prop");
          argsList.unshift(method);
          fnBody = memberExpression(_super(), identifier(method.name), true);
        }
        if (isAssignment) {
          const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
          argsList.push(valueIdent);
          fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
        }
        return arrowFunctionExpression(argsList, fnBody);
      });
    }
    function getBinding(thisEnvFn, key, init) {
      const cacheKey = "binding:" + key;
      let data = thisEnvFn.getData(cacheKey);
      if (!data) {
        const id = thisEnvFn.scope.generateUidIdentifier(key);
        data = id.name;
        thisEnvFn.setData(cacheKey, data);
        thisEnvFn.scope.push({
          id,
          init: init(data)
        });
      }
      return data;
    }
    var getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
      ThisExpression(child, {
        thisPaths
      }) {
        thisPaths.push(child);
      },
      JSXIdentifier(child, {
        thisPaths
      }) {
        if (child.node.name !== "this") return;
        if (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        })) {
          return;
        }
        thisPaths.push(child);
      },
      CallExpression(child, {
        superCalls
      }) {
        if (child.get("callee").isSuper()) superCalls.push(child);
      },
      MemberExpression(child, {
        superProps
      }) {
        if (child.get("object").isSuper()) superProps.push(child);
      },
      Identifier(child, {
        argumentsPaths
      }) {
        if (!child.isReferencedIdentifier({
          name: "arguments"
        })) return;
        let curr = child.scope;
        do {
          if (curr.hasOwnBinding("arguments")) {
            curr.rename("arguments");
            return;
          }
          if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
            break;
          }
        } while (curr = curr.parent);
        argumentsPaths.push(child);
      },
      MetaProperty(child, {
        newTargetPaths
      }) {
        if (!child.get("meta").isIdentifier({
          name: "new"
        })) return;
        if (!child.get("property").isIdentifier({
          name: "target"
        })) return;
        newTargetPaths.push(child);
      }
    });
    function getScopeInformation(fnPath) {
      const thisPaths = [];
      const argumentsPaths = [];
      const newTargetPaths = [];
      const superProps = [];
      const superCalls = [];
      fnPath.traverse(getScopeInformationVisitor, {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      });
      return {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      };
    }
    function splitExportDeclaration() {
      if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
        throw new Error("Only default and named export declarations can be split.");
      }
      if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const declaration = this.get("declaration");
      if (this.isExportDefaultDeclaration()) {
        const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
        const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
        const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
        let id = declaration.node.id;
        let needBindingRegistration = false;
        if (!id) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier("default");
          if (standaloneDeclaration || exportExpr) {
            declaration.node.id = cloneNode(id);
          }
        } else if (exportExpr && scope.hasBinding(id.name)) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier(id.name);
        }
        const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]);
        const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
        this.insertAfter(updatedExportDeclaration);
        this.replaceWith(updatedDeclaration);
        if (needBindingRegistration) {
          scope.registerDeclaration(this);
        }
        return this;
      } else if (this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
      const specifiers = Object.keys(bindingIdentifiers).map((name) => {
        return exportSpecifier(identifier(name), identifier(name));
      });
      const aliasDeclar = exportNamedDeclaration(null, specifiers);
      this.insertAfter(aliasDeclar);
      this.replaceWith(declaration.node);
      return this;
    }
    var refersOuterBindingVisitor = {
      "ReferencedIdentifier|BindingIdentifier"(path3, state) {
        if (path3.node.name !== state.name) return;
        state.needsRename = true;
        path3.stop();
      },
      Scope(path3, state) {
        if (path3.scope.hasOwnBinding(state.name)) {
          path3.skip();
        }
      }
    };
    function ensureFunctionName(supportUnicodeId) {
      if (this.node.id) return this;
      const res = getFunctionName(this.node, this.parent);
      if (res == null) return this;
      let {
        name
      } = res;
      if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
        return null;
      }
      if (name.startsWith("get ") || name.startsWith("set ")) {
        return null;
      }
      name = toBindingIdentifierName(name.replace(/[/ ]/g, "_"));
      const id = identifier(name);
      inherits(id, res.originalNode);
      const state = {
        needsRename: false,
        name
      };
      const {
        scope
      } = this;
      const binding = scope.getOwnBinding(name);
      if (binding) {
        if (binding.kind === "param") {
          state.needsRename = true;
        } else {
        }
      } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {
        this.traverse(refersOuterBindingVisitor, state);
      }
      if (!state.needsRename) {
        this.node.id = id;
        scope.getProgramParent().references[id.name] = true;
        return this;
      }
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
        this.node.id = id;
        scope.getProgramParent().references[id.name] = true;
        return this;
      }
      if (!isFunction(this.node)) return null;
      const key = scope.generateUidIdentifier(id.name);
      const params = [];
      for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
        params.push(scope.generateUidIdentifier("x"));
      }
      const call = _template.default.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode(key)}.apply(this, arguments);
      }

      ${cloneNode(id)}.toString = function () {
        return ${cloneNode(key)}.toString();
      }

      return ${cloneNode(id)};
    })(${toExpression(this.node)})
  `;
      return this.replaceWith(call)[0].get("arguments.0");
    }
    function getFunctionArity(node) {
      const count = node.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
      return count === -1 ? node.params.length : count;
    }
  }
});

// node_modules/@babel/traverse/lib/path/introspection.js
var require_introspection = __commonJS({
  "node_modules/@babel/traverse/lib/path/introspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports2._resolve = _resolve;
    exports2.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports2.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports2.getSource = getSource;
    exports2.isCompletionRecord = isCompletionRecord;
    exports2.isConstantExpression = isConstantExpression;
    exports2.isInStrictMode = isInStrictMode;
    exports2.isNodeType = isNodeType;
    exports2.isStatementOrBlock = isStatementOrBlock;
    exports2.isStatic = isStatic;
    exports2.matchesPattern = matchesPattern;
    exports2.referencesImport = referencesImport;
    exports2.resolve = resolve;
    exports2.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    var _t = require_lib4();
    var {
      STATEMENT_OR_BLOCK_KEYS,
      VISITOR_KEYS,
      isBlockStatement,
      isExpression,
      isIdentifier,
      isLiteral,
      isStringLiteral: isStringLiteral3,
      isType,
      matchesPattern: _matchesPattern
    } = _t;
    function matchesPattern(pattern, allowPartial) {
      return _matchesPattern(this.node, pattern, allowPartial);
    }
    {
      exports2.has = function has(key) {
        var _this$node;
        const val = (_this$node = this.node) == null ? void 0 : _this$node[key];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      };
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    {
      exports2.is = exports2.has;
      exports2.isnt = function isnt(key) {
        return !this.has(key);
      };
      exports2.equals = function equals(key, value) {
        return this.node[key] === value;
      };
    }
    function isNodeType(type) {
      return isType(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return isExpression(replacement);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      let path3 = this;
      let first = true;
      do {
        const {
          type,
          container
        } = path3;
        if (!first && (path3.isFunction() || type === "StaticBlock")) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container) && path3.key !== container.length - 1) {
          return false;
        }
      } while ((path3 = path3.parentPath) && !path3.isProgram() && !path3.isDoExpression());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
        return false;
      } else {
        return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral3(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          const object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return false;
      }
      const binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module") return false;
      const path3 = binding.path;
      const parent = path3.parentPath;
      if (!parent.isImportDeclaration()) return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }
      if (path3.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path3.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path3.isImportSpecifier() && isIdentifier(path3.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      const node = this.node;
      if (node.end) {
        const code = this.hub.getCode();
        if (code) return code.slice(node.start, node.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path3) {
      return path3.isProgram() ? path3 : (path3.parentPath.scope.getFunctionParent() || path3.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key) {
      switch (type) {
        case "LogicalExpression":
          return key === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";
        case "ForStatement":
          return key === "body" || key === "update";
        case "SwitchStatement":
          return key === "cases";
        case "TryStatement":
          return key === "handler";
        case "AssignmentPattern":
          return key === "right";
        case "OptionalMemberExpression":
          return key === "property";
        case "OptionalCallExpression":
          return key === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        const path3 = paths[i];
        if (isExecutionUncertain(path3.parent.type, path3.parentKey)) {
          return true;
        }
      }
      return false;
    }
    var SYMBOL_CHECKING = Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
    }
    function _guessExecutionStatusRelativeToCached(base, target, cache) {
      const funcParent = {
        this: getOuterFunction(base),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
      }
      const paths = {
        target: target.getAncestry(),
        this: base.getAncestry()
      };
      if (paths.target.includes(base)) return "after";
      if (paths.this.includes(target)) return "before";
      let commonPath;
      const commonIndex = {
        target: 0,
        this: 0
      };
      while (!commonPath && commonIndex.this < paths.this.length) {
        const path3 = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path3);
        if (commonIndex.target >= 0) {
          commonPath = path3;
        } else {
          commonIndex.this++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? "before" : "after";
      }
      const keys = VISITOR_KEYS[commonPath.type];
      const keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {
      if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") {
          return "before";
        }
        return "unknown";
      } else if (target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      const binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references) return "before";
      const referencePaths = binding.referencePaths;
      let allStatus;
      for (const path3 of referencePaths) {
        const childOfFunction = !!path3.find((path4) => path4.node === target.node);
        if (childOfFunction) continue;
        if (path3.key !== "callee" || !path3.parentPath.isCallExpression()) {
          return "unknown";
        }
        const status = _guessExecutionStatusRelativeToCached(base, path3, cache);
        if (allStatus && allStatus !== status) {
          return "unknown";
        } else {
          allStatus = status;
        }
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {
      let nodeMap = cache.get(base.node);
      let cached;
      if (!nodeMap) {
        cache.set(base.node, nodeMap = /* @__PURE__ */ new Map());
      } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
          return "unknown";
        }
        return cached;
      }
      nodeMap.set(target.node, SYMBOL_CHECKING);
      const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
      nodeMap.set(target.node, result);
      return result;
    }
    function resolve(dangerous, resolved) {
      return _resolve.call(this, dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      var _resolved;
      if ((_resolved = resolved) != null && _resolved.includes(this)) return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        } else {
        }
      } else if (this.isReferencedIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return;
        if (!binding.constant) return;
        if (binding.kind === "module") return;
        if (binding.path !== this) {
          const ret = binding.path.resolve(dangerous, resolved);
          if (this.find((parent) => parent.node === ret.node)) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!isLiteral(targetKey)) return;
        const targetName = targetKey.value;
        const target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          const props = target.get("properties");
          for (const prop of props) {
            if (!prop.isProperty()) continue;
            const key = prop.get("key");
            let match = prop.isnt("computed") && key.isIdentifier({
              name: targetName
            });
            match = match || key.isLiteral({
              value: targetName
            });
            if (match) return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elems = target.get("elements");
          const elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return false;
        return binding.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every((expression) => expression.isConstantExpression());
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        const {
          operator
        } = this.node;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      if (this.isMemberExpression()) {
        return !this.node.computed && this.get("object").isIdentifier({
          name: "Symbol"
        }) && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        });
      }
      if (this.isCallExpression()) {
        return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        }) && this.get("arguments")[0].isStringLiteral();
      }
      return false;
    }
    function isInStrictMode() {
      const start = this.isProgram() ? this : this.parentPath;
      const strictParent = start.find((path3) => {
        if (path3.isProgram({
          sourceType: "module"
        })) return true;
        if (path3.isClass()) return true;
        if (path3.isArrowFunctionExpression() && !path3.get("body").isBlockStatement()) {
          return false;
        }
        let body;
        if (path3.isFunction()) {
          body = path3.node.body;
        } else if (path3.isProgram()) {
          body = path3.node;
        } else {
          return false;
        }
        for (const directive of body.directives) {
          if (directive.value.value === "use strict") {
            return true;
          }
        }
      });
      return !!strictParent;
    }
  }
});

// node_modules/@babel/traverse/lib/path/family.js
var require_family = __commonJS({
  "node_modules/@babel/traverse/lib/path/family.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._getKey = _getKey;
    exports2._getPattern = _getPattern;
    exports2.get = get;
    exports2.getAllNextSiblings = getAllNextSiblings;
    exports2.getAllPrevSiblings = getAllPrevSiblings;
    exports2.getAssignmentIdentifiers = getAssignmentIdentifiers;
    exports2.getBindingIdentifierPaths = getBindingIdentifierPaths;
    exports2.getBindingIdentifiers = getBindingIdentifiers;
    exports2.getCompletionRecords = getCompletionRecords;
    exports2.getNextSibling = getNextSibling;
    exports2.getOpposite = getOpposite;
    exports2.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
    exports2.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
    exports2.getPrevSibling = getPrevSibling;
    exports2.getSibling = getSibling;
    var _index = require_path();
    var _t = require_lib4();
    var {
      getAssignmentIdentifiers: _getAssignmentIdentifiers,
      getBindingIdentifiers: _getBindingIdentifiers,
      getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
      numericLiteral,
      unaryExpression
    } = _t;
    var NORMAL_COMPLETION = 0;
    var BREAK_COMPLETION = 1;
    function NormalCompletion(path3) {
      return {
        type: NORMAL_COMPLETION,
        path: path3
      };
    }
    function BreakCompletion(path3) {
      return {
        type: BREAK_COMPLETION,
        path: path3
      };
    }
    function getOpposite() {
      if (this.key === "left") {
        return this.getSibling("right");
      } else if (this.key === "right") {
        return this.getSibling("left");
      }
      return null;
    }
    function addCompletionRecords(path3, records, context) {
      if (path3) {
        records.push(..._getCompletionRecords(path3, context));
      }
      return records;
    }
    function completionRecordForSwitch(cases, records, context) {
      let lastNormalCompletions = [];
      for (let i = 0; i < cases.length; i++) {
        const casePath = cases[i];
        const caseCompletions = _getCompletionRecords(casePath, context);
        const normalCompletions = [];
        const breakCompletions = [];
        for (const c of caseCompletions) {
          if (c.type === NORMAL_COMPLETION) {
            normalCompletions.push(c);
          }
          if (c.type === BREAK_COMPLETION) {
            breakCompletions.push(c);
          }
        }
        if (normalCompletions.length) {
          lastNormalCompletions = normalCompletions;
        }
        records.push(...breakCompletions);
      }
      records.push(...lastNormalCompletions);
      return records;
    }
    function normalCompletionToBreak(completions) {
      completions.forEach((c) => {
        c.type = BREAK_COMPLETION;
      });
    }
    function replaceBreakStatementInBreakCompletion(completions, reachable) {
      completions.forEach((c) => {
        if (c.path.isBreakStatement({
          label: null
        })) {
          if (reachable) {
            c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
          } else {
            c.path.remove();
          }
        }
      });
    }
    function getStatementListCompletion(paths, context) {
      const completions = [];
      if (context.canHaveBreak) {
        let lastNormalCompletions = [];
        for (let i = 0; i < paths.length; i++) {
          const path3 = paths[i];
          const newContext = Object.assign({}, context, {
            inCaseClause: false
          });
          if (path3.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
            newContext.shouldPopulateBreak = true;
          } else {
            newContext.shouldPopulateBreak = false;
          }
          const statementCompletions = _getCompletionRecords(path3, newContext);
          if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
            if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
              label: null
            }))) {
              normalCompletionToBreak(lastNormalCompletions);
              completions.push(...lastNormalCompletions);
              if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
                completions.push(...statementCompletions);
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
              replaceBreakStatementInBreakCompletion(statementCompletions, false);
            } else {
              completions.push(...statementCompletions);
              if (!context.shouldPopulateBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            break;
          }
          if (i === paths.length - 1) {
            completions.push(...statementCompletions);
          } else {
            lastNormalCompletions = [];
            for (let i2 = 0; i2 < statementCompletions.length; i2++) {
              const c = statementCompletions[i2];
              if (c.type === BREAK_COMPLETION) {
                completions.push(c);
              }
              if (c.type === NORMAL_COMPLETION) {
                lastNormalCompletions.push(c);
              }
            }
          }
        }
      } else if (paths.length) {
        for (let i = paths.length - 1; i >= 0; i--) {
          const pathCompletions = _getCompletionRecords(paths[i], context);
          if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
            completions.push(...pathCompletions);
            break;
          }
        }
      }
      return completions;
    }
    function _getCompletionRecords(path3, context) {
      let records = [];
      if (path3.isIfStatement()) {
        records = addCompletionRecords(path3.get("consequent"), records, context);
        records = addCompletionRecords(path3.get("alternate"), records, context);
      } else if (path3.isDoExpression() || path3.isFor() || path3.isWhile() || path3.isLabeledStatement()) {
        return addCompletionRecords(path3.get("body"), records, context);
      } else if (path3.isProgram() || path3.isBlockStatement()) {
        return getStatementListCompletion(path3.get("body"), context);
      } else if (path3.isFunction()) {
        return _getCompletionRecords(path3.get("body"), context);
      } else if (path3.isTryStatement()) {
        records = addCompletionRecords(path3.get("block"), records, context);
        records = addCompletionRecords(path3.get("handler"), records, context);
      } else if (path3.isCatchClause()) {
        return addCompletionRecords(path3.get("body"), records, context);
      } else if (path3.isSwitchStatement()) {
        return completionRecordForSwitch(path3.get("cases"), records, context);
      } else if (path3.isSwitchCase()) {
        return getStatementListCompletion(path3.get("consequent"), {
          canHaveBreak: true,
          shouldPopulateBreak: false,
          inCaseClause: true
        });
      } else if (path3.isBreakStatement()) {
        records.push(BreakCompletion(path3));
      } else {
        records.push(NormalCompletion(path3));
      }
      return records;
    }
    function getCompletionRecords() {
      const records = _getCompletionRecords(this, {
        canHaveBreak: false,
        shouldPopulateBreak: false,
        inCaseClause: false
      });
      return records.map((r) => r.path);
    }
    function getSibling(key) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key
      }).setContext(this.context);
    }
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    function getAllNextSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(++_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
      }
      return siblings;
    }
    function getAllPrevSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(--_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
      }
      return siblings;
    }
    function get(key, context = true) {
      if (context === true) context = this.context;
      const parts = key.split(".");
      if (parts.length === 1) {
        return _getKey.call(this, key, context);
      } else {
        return _getPattern.call(this, parts, context);
      }
    }
    function _getKey(key, context) {
      const node = this.node;
      const container = node[key];
      if (Array.isArray(container)) {
        return container.map((_, i) => {
          return _index.default.get({
            listKey: key,
            parentPath: this,
            parent: node,
            container,
            key: i
          }).setContext(context);
        });
      } else {
        return _index.default.get({
          parentPath: this,
          parent: node,
          container: node,
          key
        }).setContext(context);
      }
    }
    function _getPattern(parts, context) {
      let path3 = this;
      for (const part of parts) {
        if (part === ".") {
          path3 = path3.parentPath;
        } else {
          if (Array.isArray(path3)) {
            path3 = path3[part];
          } else {
            path3 = path3.get(part, context);
          }
        }
      }
      return path3;
    }
    function getAssignmentIdentifiers() {
      return _getAssignmentIdentifiers(this.node);
    }
    function getBindingIdentifiers(duplicates) {
      return _getBindingIdentifiers(this.node, duplicates);
    }
    function getOuterBindingIdentifiers(duplicates) {
      return _getOuterBindingIdentifiers(this.node, duplicates);
    }
    function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
      const path3 = this;
      const search = [path3];
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id) continue;
        if (!id.node) continue;
        const keys = _getBindingIdentifiers.keys[id.node.type];
        if (id.isIdentifier()) {
          if (duplicates) {
            const _ids = ids[id.node.name] = ids[id.node.name] || [];
            _ids.push(id);
          } else {
            ids[id.node.name] = id;
          }
          continue;
        }
        if (id.isExportDeclaration()) {
          const declaration = id.get("declaration");
          if (declaration.isDeclaration()) {
            search.push(declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search.push(id.get("id"));
            continue;
          }
          if (id.isFunctionExpression()) {
            continue;
          }
        }
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const child = id.get(key);
            if (Array.isArray(child)) {
              search.push(...child);
            } else if (child.node) {
              search.push(child);
            }
          }
        }
      }
      return ids;
    }
    function getOuterBindingIdentifierPaths(duplicates = false) {
      return this.getBindingIdentifierPaths(duplicates, true);
    }
  }
});

// node_modules/@babel/traverse/lib/path/comments.js
var require_comments = __commonJS({
  "node_modules/@babel/traverse/lib/path/comments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addComment = addComment;
    exports2.addComments = addComments;
    exports2.shareCommentsWithSiblings = shareCommentsWithSiblings;
    var _t = require_lib4();
    var {
      addComment: _addComment,
      addComments: _addComments
    } = _t;
    function shareCommentsWithSiblings() {
      if (typeof this.key === "string") return;
      const node = this.node;
      if (!node) return;
      const trailing = node.trailingComments;
      const leading = node.leadingComments;
      if (!trailing && !leading) return;
      const prev = this.getSibling(this.key - 1);
      const next = this.getSibling(this.key + 1);
      const hasPrev = Boolean(prev.node);
      const hasNext = Boolean(next.node);
      if (hasPrev) {
        if (leading) {
          prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
        }
        if (trailing && !hasNext) prev.addComments("trailing", trailing);
      }
      if (hasNext) {
        if (trailing) {
          next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
        }
        if (leading && !hasPrev) next.addComments("leading", leading);
      }
    }
    function removeIfExisting(list, toRemove) {
      if (!(toRemove != null && toRemove.length)) return list;
      const set = new Set(toRemove);
      return list.filter((el) => {
        return !set.has(el);
      });
    }
    function addComment(type, content, line) {
      _addComment(this.node, type, content, line);
    }
    function addComments(type, comments) {
      _addComments(this.node, type, comments);
    }
  }
});

// node_modules/@babel/traverse/lib/path/index.js
var require_path = __commonJS({
  "node_modules/@babel/traverse/lib/path/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.SHOULD_STOP = exports2.SHOULD_SKIP = exports2.REMOVED = void 0;
    var virtualTypes = require_virtual_types();
    var _debug = require_src();
    var _index = require_lib8();
    var _index2 = require_scope();
    var _t = require_lib4();
    var t3 = _t;
    var cache = require_cache();
    var _generator = require_lib5();
    var NodePath_ancestry = require_ancestry();
    var NodePath_inference = require_inference();
    var NodePath_replacement = require_replacement();
    var NodePath_evaluation = require_evaluation();
    var NodePath_conversion = require_conversion();
    var NodePath_introspection = require_introspection();
    var _context = require_context2();
    var NodePath_context = _context;
    var NodePath_removal = require_removal();
    var NodePath_modification = require_modification();
    var NodePath_family = require_family();
    var NodePath_comments = require_comments();
    var NodePath_virtual_types_validator = require_virtual_types_validator();
    var {
      validate
    } = _t;
    var debug = _debug("babel");
    var REMOVED = exports2.REMOVED = 1 << 0;
    var SHOULD_STOP = exports2.SHOULD_STOP = 1 << 1;
    var SHOULD_SKIP = exports2.SHOULD_SKIP = 1 << 2;
    var NodePath_Final = exports2.default = class NodePath3 {
      constructor(hub, parent) {
        this.contexts = [];
        this.state = null;
        this.opts = null;
        this._traverseFlags = 0;
        this.skipKeys = null;
        this.parentPath = null;
        this.container = null;
        this.listKey = null;
        this.key = null;
        this.node = null;
        this.type = null;
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
      }
      get removed() {
        return (this._traverseFlags & 1) > 0;
      }
      set removed(v) {
        if (v) this._traverseFlags |= 1;
        else this._traverseFlags &= -2;
      }
      get shouldStop() {
        return (this._traverseFlags & 2) > 0;
      }
      set shouldStop(v) {
        if (v) this._traverseFlags |= 2;
        else this._traverseFlags &= -3;
      }
      get shouldSkip() {
        return (this._traverseFlags & 4) > 0;
      }
      set shouldSkip(v) {
        if (v) this._traverseFlags |= 4;
        else this._traverseFlags &= -5;
      }
      static get({
        hub,
        parentPath,
        parent,
        container,
        listKey,
        key
      }) {
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }
        if (!parent) {
          throw new Error("To get a node path the parent needs to exist");
        }
        const targetNode = container[key];
        const paths = cache.getOrCreateCachedPaths(hub, parent);
        let path3 = paths.get(targetNode);
        if (!path3) {
          path3 = new NodePath3(hub, parent);
          if (targetNode) paths.set(targetNode, path3);
        }
        _context.setup.call(path3, parentPath, container, listKey, key);
        return path3;
      }
      getScope(scope) {
        return this.isScope() ? new _index2.default(this) : scope;
      }
      setData(key, val) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        return this.data[key] = val;
      }
      getData(key, def) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        let val = this.data[key];
        if (val === void 0 && def !== void 0) val = this.data[key] = def;
        return val;
      }
      hasNode() {
        return this.node != null;
      }
      buildCodeFrameError(msg, Error2 = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error2);
      }
      traverse(visitor, state) {
        (0, _index.default)(this.node, visitor, this.scope, state, this);
      }
      set(key, node) {
        validate(this.node, key, node);
        this.node[key] = node;
      }
      getPathLocation() {
        const parts = [];
        let path3 = this;
        do {
          let key = path3.key;
          if (path3.inList) key = `${path3.listKey}[${key}]`;
          parts.unshift(key);
        } while (path3 = path3.parentPath);
        return parts.join(".");
      }
      debug(message) {
        if (!debug.enabled) return;
        debug(`${this.getPathLocation()} ${this.type}: ${message}`);
      }
      toString() {
        return (0, _generator.default)(this.node).code;
      }
      get inList() {
        return !!this.listKey;
      }
      set inList(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
      get parentKey() {
        return this.listKey || this.key;
      }
    };
    var methods = {
      findParent: NodePath_ancestry.findParent,
      find: NodePath_ancestry.find,
      getFunctionParent: NodePath_ancestry.getFunctionParent,
      getStatementParent: NodePath_ancestry.getStatementParent,
      getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
      getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
      getAncestry: NodePath_ancestry.getAncestry,
      isAncestor: NodePath_ancestry.isAncestor,
      isDescendant: NodePath_ancestry.isDescendant,
      inType: NodePath_ancestry.inType,
      getTypeAnnotation: NodePath_inference.getTypeAnnotation,
      isBaseType: NodePath_inference.isBaseType,
      couldBeBaseType: NodePath_inference.couldBeBaseType,
      baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
      isGenericType: NodePath_inference.isGenericType,
      replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
      replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
      replaceWith: NodePath_replacement.replaceWith,
      replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
      replaceInline: NodePath_replacement.replaceInline,
      evaluateTruthy: NodePath_evaluation.evaluateTruthy,
      evaluate: NodePath_evaluation.evaluate,
      toComputedKey: NodePath_conversion.toComputedKey,
      ensureBlock: NodePath_conversion.ensureBlock,
      unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
      arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
      splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
      ensureFunctionName: NodePath_conversion.ensureFunctionName,
      matchesPattern: NodePath_introspection.matchesPattern,
      isStatic: NodePath_introspection.isStatic,
      isNodeType: NodePath_introspection.isNodeType,
      canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
      canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
      isCompletionRecord: NodePath_introspection.isCompletionRecord,
      isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
      referencesImport: NodePath_introspection.referencesImport,
      getSource: NodePath_introspection.getSource,
      willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
      _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
      resolve: NodePath_introspection.resolve,
      isConstantExpression: NodePath_introspection.isConstantExpression,
      isInStrictMode: NodePath_introspection.isInStrictMode,
      isDenylisted: NodePath_context.isDenylisted,
      visit: NodePath_context.visit,
      skip: NodePath_context.skip,
      skipKey: NodePath_context.skipKey,
      stop: NodePath_context.stop,
      setContext: NodePath_context.setContext,
      requeue: NodePath_context.requeue,
      requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
      remove: NodePath_removal.remove,
      insertBefore: NodePath_modification.insertBefore,
      insertAfter: NodePath_modification.insertAfter,
      unshiftContainer: NodePath_modification.unshiftContainer,
      pushContainer: NodePath_modification.pushContainer,
      getOpposite: NodePath_family.getOpposite,
      getCompletionRecords: NodePath_family.getCompletionRecords,
      getSibling: NodePath_family.getSibling,
      getPrevSibling: NodePath_family.getPrevSibling,
      getNextSibling: NodePath_family.getNextSibling,
      getAllNextSiblings: NodePath_family.getAllNextSiblings,
      getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
      get: NodePath_family.get,
      getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
      getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
      getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
      getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
      getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
      shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
      addComment: NodePath_comments.addComment,
      addComments: NodePath_comments.addComments
    };
    Object.assign(NodePath_Final.prototype, methods);
    {
      NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];
      Object.assign(NodePath_Final.prototype, {
        has: NodePath_introspection[String("has")],
        is: NodePath_introspection[String("is")],
        isnt: NodePath_introspection[String("isnt")],
        equals: NodePath_introspection[String("equals")],
        hoist: NodePath_modification[String("hoist")],
        updateSiblingKeys: NodePath_modification.updateSiblingKeys,
        call: NodePath_context.call,
        isBlacklisted: NodePath_context[String("isBlacklisted")],
        setScope: NodePath_context.setScope,
        resync: NodePath_context.resync,
        popContext: NodePath_context.popContext,
        pushContext: NodePath_context.pushContext,
        setup: NodePath_context.setup,
        setKey: NodePath_context.setKey
      });
    }
    {
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      Object.assign(NodePath_Final.prototype, {
        _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
        _replaceWith: NodePath_replacement._replaceWith,
        _resolve: NodePath_introspection._resolve,
        _call: NodePath_context._call,
        _resyncParent: NodePath_context._resyncParent,
        _resyncKey: NodePath_context._resyncKey,
        _resyncList: NodePath_context._resyncList,
        _resyncRemoved: NodePath_context._resyncRemoved,
        _getQueueContexts: NodePath_context._getQueueContexts,
        _removeFromScope: NodePath_removal._removeFromScope,
        _callRemovalHooks: NodePath_removal._callRemovalHooks,
        _remove: NodePath_removal._remove,
        _markRemoved: NodePath_removal._markRemoved,
        _assertUnremoved: NodePath_removal._assertUnremoved,
        _containerInsert: NodePath_modification._containerInsert,
        _containerInsertBefore: NodePath_modification._containerInsertBefore,
        _containerInsertAfter: NodePath_modification._containerInsertAfter,
        _verifyNodeList: NodePath_modification._verifyNodeList,
        _getKey: NodePath_family._getKey,
        _getPattern: NodePath_family._getPattern
      });
    }
    for (const type of t3.TYPES) {
      const typeKey = `is${type}`;
      const fn = t3[typeKey];
      NodePath_Final.prototype[typeKey] = function(opts) {
        return fn(this.node, opts);
      };
      NodePath_Final.prototype[`assert${type}`] = function(opts) {
        if (!fn(this.node, opts)) {
          throw new TypeError(`Expected node path of type ${type}`);
        }
      };
    }
    Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
    for (const type of Object.keys(virtualTypes)) {
      if (type[0] === "_") continue;
      if (!t3.TYPES.includes(type)) t3.TYPES.push(type);
    }
  }
});

// node_modules/@babel/traverse/lib/context.js
var require_context = __commonJS({
  "node_modules/@babel/traverse/lib/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_path();
    var _t = require_lib4();
    var _context = require_context2();
    var {
      VISITOR_KEYS
    } = _t;
    var TraversalContext = class {
      constructor(scope, opts, state, parentPath) {
        this.queue = null;
        this.priorityQueue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }
      shouldVisit(node) {
        const opts = this.opts;
        if (opts.enter || opts.exit) return true;
        if (opts[node.type]) return true;
        const keys = VISITOR_KEYS[node.type];
        if (!(keys != null && keys.length)) return false;
        for (const key of keys) {
          if (node[key]) {
            return true;
          }
        }
        return false;
      }
      create(node, container, key, listKey) {
        return _index.default.get({
          parentPath: this.parentPath,
          parent: node,
          container,
          key,
          listKey
        });
      }
      maybeQueue(path3, notPriority) {
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path3);
          } else {
            this.priorityQueue.push(path3);
          }
        }
      }
      visitMultiple(container, parent, listKey) {
        if (container.length === 0) return false;
        const queue = [];
        for (let key = 0; key < container.length; key++) {
          const node = container[key];
          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, key, listKey));
          }
        }
        return this.visitQueue(queue);
      }
      visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
          return this.visitQueue([this.create(node, node, key)]);
        } else {
          return false;
        }
      }
      visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        const visited = /* @__PURE__ */ new WeakSet();
        let stop = false;
        let visitIndex = 0;
        for (; visitIndex < queue.length; ) {
          const path3 = queue[visitIndex];
          visitIndex++;
          _context.resync.call(path3);
          if (path3.contexts.length === 0 || path3.contexts[path3.contexts.length - 1] !== this) {
            _context.pushContext.call(path3, this);
          }
          if (path3.key === null) continue;
          const {
            node
          } = path3;
          if (visited.has(node)) continue;
          if (node) visited.add(node);
          if (path3.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop) break;
          }
        }
        for (let i = 0; i < visitIndex; i++) {
          _context.popContext.call(queue[i]);
        }
        this.queue = null;
        return stop;
      }
      visit(node, key) {
        const nodes = node[key];
        if (!nodes) return false;
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key);
        } else {
          return this.visitSingle(node, key);
        }
      }
    };
    exports2.default = TraversalContext;
  }
});

// node_modules/@babel/traverse/lib/traverse-node.js
var require_traverse_node = __commonJS({
  "node_modules/@babel/traverse/lib/traverse-node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.traverseNode = traverseNode;
    var _context = require_context();
    var _t = require_lib4();
    var {
      VISITOR_KEYS
    } = _t;
    function traverseNode(node, opts, scope, state, path3, skipKeys, visitSelf) {
      const keys = VISITOR_KEYS[node.type];
      if (!keys) return false;
      const context = new _context.default(scope, opts, state, path3);
      if (visitSelf) {
        if (skipKeys != null && skipKeys[path3.parentKey]) return false;
        return context.visitQueue([path3]);
      }
      for (const key of keys) {
        if (skipKeys != null && skipKeys[key]) continue;
        if (context.visit(node, key)) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/traverse/lib/path/context.js
var require_context2 = __commonJS({
  "node_modules/@babel/traverse/lib/path/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._call = _call;
    exports2._getQueueContexts = _getQueueContexts;
    exports2._resyncKey = _resyncKey;
    exports2._resyncList = _resyncList;
    exports2._resyncParent = _resyncParent;
    exports2._resyncRemoved = _resyncRemoved;
    exports2.call = call;
    exports2.isDenylisted = isDenylisted;
    exports2.popContext = popContext;
    exports2.pushContext = pushContext;
    exports2.requeue = requeue;
    exports2.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
    exports2.resync = resync;
    exports2.setContext = setContext;
    exports2.setKey = setKey;
    exports2.setScope = setScope;
    exports2.setup = setup;
    exports2.skip = skip;
    exports2.skipKey = skipKey;
    exports2.stop = stop;
    exports2.visit = visit;
    var _traverseNode = require_traverse_node();
    var _index = require_path();
    var _removal = require_removal();
    var t3 = require_lib4();
    function call(key) {
      const opts = this.opts;
      this.debug(key);
      if (this.node) {
        if (_call.call(this, opts[key])) return true;
      }
      if (this.node) {
        var _opts$this$node$type;
        return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key]);
      }
      return false;
    }
    function _call(fns) {
      if (!fns) return false;
      for (const fn of fns) {
        if (!fn) continue;
        const node = this.node;
        if (!node) return true;
        const ret = fn.call(this.state, this, this.state);
        if (ret && typeof ret === "object" && typeof ret.then === "function") {
          throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
        if (ret) {
          throw new Error(`Unexpected return value from visitor method ${fn}`);
        }
        if (this.node !== node) return true;
        if (this._traverseFlags > 0) return true;
      }
      return false;
    }
    function isDenylisted() {
      var _this$opts$denylist;
      const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
      return denylist == null ? void 0 : denylist.includes(this.node.type);
    }
    {
      exports2.isBlacklisted = isDenylisted;
    }
    function restoreContext(path3, context) {
      if (path3.context !== context) {
        path3.context = context;
        path3.state = context.state;
        path3.opts = context.opts;
      }
    }
    function visit() {
      var _this$opts$shouldSkip, _this$opts;
      if (!this.node) {
        return false;
      }
      if (this.isDenylisted()) {
        return false;
      }
      if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
        return false;
      }
      const currentContext = this.context;
      if (this.shouldSkip || call.call(this, "enter")) {
        this.debug("Skip...");
        return this.shouldStop;
      }
      restoreContext(this, currentContext);
      this.debug("Recursing into...");
      this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
      restoreContext(this, currentContext);
      call.call(this, "exit");
      return this.shouldStop;
    }
    function skip() {
      this.shouldSkip = true;
    }
    function skipKey(key) {
      if (this.skipKeys == null) {
        this.skipKeys = {};
      }
      this.skipKeys[key] = true;
    }
    function stop() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
    }
    function setScope() {
      var _this$opts2, _this$scope;
      if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;
      let path3 = this.parentPath;
      if ((this.key === "key" || this.listKey === "decorators") && path3.isMethod() || this.key === "discriminant" && path3.isSwitchStatement()) {
        path3 = path3.parentPath;
      }
      let target;
      while (path3 && !target) {
        var _path$opts;
        if ((_path$opts = path3.opts) != null && _path$opts.noScope) return;
        target = path3.scope;
        path3 = path3.parentPath;
      }
      this.scope = this.getScope(target);
      (_this$scope = this.scope) == null || _this$scope.init();
    }
    function setContext(context) {
      if (this.skipKeys != null) {
        this.skipKeys = {};
      }
      this._traverseFlags = 0;
      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }
      setScope.call(this);
      return this;
    }
    function resync() {
      if (this.removed) return;
      _resyncParent.call(this);
      _resyncList.call(this);
      _resyncKey.call(this);
    }
    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }
    function _resyncKey() {
      if (!this.container) return;
      if (this.node === this.container[this.key]) {
        return;
      }
      if (Array.isArray(this.container)) {
        for (let i = 0; i < this.container.length; i++) {
          if (this.container[i] === this.node) {
            setKey.call(this, i);
            return;
          }
        }
      } else {
        for (const key of Object.keys(this.container)) {
          if (this.container[key] === this.node) {
            setKey.call(this, key);
            return;
          }
        }
      }
      this.key = null;
    }
    function _resyncList() {
      if (!this.parent || !this.inList) return;
      const newContainer = this.parent[this.listKey];
      if (this.container === newContainer) return;
      this.container = newContainer || null;
    }
    function _resyncRemoved() {
      if (this.key == null || !this.container || this.container[this.key] !== this.node) {
        _removal._markRemoved.call(this);
      }
    }
    function popContext() {
      this.contexts.pop();
      if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
      } else {
        this.setContext(void 0);
      }
    }
    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }
    function setup(parentPath, container, listKey, key) {
      this.listKey = listKey;
      this.container = container;
      this.parentPath = parentPath || this.parentPath;
      setKey.call(this, key);
    }
    function setKey(key) {
      var _this$node;
      this.key = key;
      this.node = this.container[this.key];
      this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
    }
    function requeue(pathToQueue = this) {
      if (pathToQueue.removed) return;
      ;
      const contexts = this.contexts;
      for (const context of contexts) {
        context.maybeQueue(pathToQueue);
      }
    }
    function requeueComputedKeyAndDecorators() {
      const {
        context,
        node
      } = this;
      if (!t3.isPrivate(node) && node.computed) {
        context.maybeQueue(this.get("key"));
      }
      if (node.decorators) {
        for (const decorator of this.get("decorators")) {
          context.maybeQueue(decorator);
        }
      }
    }
    function _getQueueContexts() {
      let path3 = this;
      let contexts = this.contexts;
      while (!contexts.length) {
        path3 = path3.parentPath;
        if (!path3) break;
        contexts = path3.contexts;
      }
      return contexts;
    }
  }
});

// node_modules/@babel/traverse/lib/hub.js
var require_hub = __commonJS({
  "node_modules/@babel/traverse/lib/hub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Hub = class {
      getCode() {
      }
      getScope() {
      }
      addHelper() {
        throw new Error("Helpers are not supported by the default hub.");
      }
      buildError(node, msg, Error2 = TypeError) {
        return new Error2(msg);
      }
    };
    exports2.default = Hub;
  }
});

// node_modules/@babel/traverse/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@babel/traverse/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "Hub", {
      enumerable: true,
      get: function() {
        return _hub.default;
      }
    });
    Object.defineProperty(exports2, "NodePath", {
      enumerable: true,
      get: function() {
        return _index.default;
      }
    });
    Object.defineProperty(exports2, "Scope", {
      enumerable: true,
      get: function() {
        return _index2.default;
      }
    });
    exports2.visitors = exports2.default = void 0;
    require_context2();
    var visitors = require_visitors();
    exports2.visitors = visitors;
    var _t = require_lib4();
    var cache = require_cache();
    var _traverseNode = require_traverse_node();
    var _index = require_path();
    var _index2 = require_scope();
    var _hub = require_hub();
    var {
      VISITOR_KEYS,
      removeProperties,
      traverseFast
    } = _t;
    function traverse3(parent, opts = {}, scope, state, parentPath, visitSelf) {
      if (!parent) return;
      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
      }
      if (!parentPath && visitSelf) {
        throw new Error("visitSelf can only be used when providing a NodePath.");
      }
      if (!VISITOR_KEYS[parent.type]) {
        return;
      }
      visitors.explode(opts);
      (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);
    }
    var _default = exports2.default = traverse3;
    traverse3.visitors = visitors;
    traverse3.verify = visitors.verify;
    traverse3.explode = visitors.explode;
    traverse3.cheap = function(node, enter) {
      traverseFast(node, enter);
      return;
    };
    traverse3.node = function(node, opts, scope, state, path3, skipKeys) {
      (0, _traverseNode.traverseNode)(node, opts, scope, state, path3, skipKeys);
    };
    traverse3.clearNode = function(node, opts) {
      removeProperties(node, opts);
    };
    traverse3.removeProperties = function(tree, opts) {
      traverseFast(tree, traverse3.clearNode, opts);
      return tree;
    };
    function hasDenylistedType(path3, state) {
      if (path3.node.type === state.type) {
        state.has = true;
        path3.stop();
      }
    }
    traverse3.hasType = function(tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
      if (tree.type === type) return true;
      const state = {
        has: false,
        type
      };
      traverse3(tree, {
        noScope: true,
        denylist: denylistTypes,
        enter: hasDenylistedType
      }, null, state);
      return state.has;
    };
    traverse3.cache = cache;
  }
});

// node_modules/commander/esm.mjs
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  // deprecated old name
  Command,
  Argument,
  Option,
  Help
} = import_index.default;

// src/component-management/scanners/ComponentHierarchyScanner.ts
var import_parser = __toESM(require_lib());
var import_traverse2 = __toESM(require_lib8());
var t2 = __toESM(require_lib4());
var fs = __toESM(require("fs/promises"));
var path2 = __toESM(require("path"));

// src/component-management/validators/TestIdValidator.ts
var TestIdValidator = class {
  constructor() {
    this.rules = [
      {
        name: "prefix",
        pattern: /^(root|shared)_/,
        message: 'Test ID must start with "root_" or "shared_"',
        severity: "error",
        validate: (testId) => /^(root|shared)_/.test(testId)
      },
      {
        name: "case",
        pattern: /^[a-z]+(_[a-z]+)*$/,
        message: "Test ID must be lowercase with underscore separators",
        severity: "error",
        validate: (testId) => /^[a-z]+(_[a-z]+)*$/.test(testId)
      },
      {
        name: "hierarchy",
        pattern: /^.*$/,
        message: "Test ID must reflect component hierarchy",
        severity: "error",
        validate: (testId, component) => {
          const expectedPrefix = this.generateExpectedPrefix(component);
          return testId.startsWith(expectedPrefix);
        }
      }
    ];
  }
  validate(testId, component) {
    const errors = [];
    const warnings = [];
    this.rules.forEach((rule) => {
      if (!rule.validate(testId, component)) {
        const error = {
          rule: rule.name,
          message: rule.message,
          testId,
          component: component.name,
          suggestion: this.generateSuggestion(rule, component)
        };
        if (rule.severity === "error") {
          errors.push(error);
        } else {
          warnings.push(error);
        }
      }
    });
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  generateExpectedPrefix(component) {
    const pathSegments = component.path.split("/").filter((segment) => segment.length > 0);
    const isShared = pathSegments.includes("shared");
    const prefix = isShared ? "shared" : "root";
    return `${prefix}_${component.name.toLowerCase()}`;
  }
  generateSuggestion(rule, component) {
    switch (rule.name) {
      case "prefix":
        return this.generateExpectedPrefix(component);
      case "case":
        return component.name.toLowerCase();
      case "hierarchy":
        return this.generateExpectedPrefix(component);
      default:
        return "";
    }
  }
};

// src/component-management/validators/TestIdGenerator.ts
var t = __toESM(require_lib4());
var import_traverse = __toESM(require_lib8());

// src/core/config.ts
var path = __toESM(require("path"));
function getConfig(name, options = {}) {
  const configPaths = [
    options.configPath,
    process.env[`${name.toUpperCase()}_CONFIG_PATH`],
    path.join(process.cwd(), `config/${name}.config.js`),
    path.join(process.cwd(), `.${name}rc.js`),
    path.join(process.cwd(), `.${name}rc.json`)
  ].filter((p) => Boolean(p));
  for (const configPath of configPaths) {
    try {
      console.log("Trying config path:", configPath);
      const resolvedPath = require.resolve(configPath);
      const config = require(resolvedPath);
      console.log("Loaded config from:", resolvedPath);
      return config;
    } catch (error) {
      console.log("Failed to load config from:", configPath);
      continue;
    }
  }
  if (options.required) {
    throw new Error(`Could not find config for ${name} in: ${configPaths.join(", ")}`);
  }
  return {};
}

// src/component-management/scanners/ComponentHierarchyScanner.ts
var DEFAULT_CONFIG = {
  includes: ["**/*.tsx", "**/*.ts"],
  excludes: ["**/*.test.*", "**/*.spec.*"],
  maxDepth: 3
};
var ComponentHierarchyScanner = class {
  constructor() {
    this.componentMap = /* @__PURE__ */ new Map();
    this.validator = new TestIdValidator();
    try {
      const loadedConfig = getConfig("scanner", {
        required: false,
        configPath: process.env.SCANNER_CONFIG_PATH
      });
      this.config = {
        ...DEFAULT_CONFIG,
        ...loadedConfig
      };
    } catch (error) {
      console.warn("Failed to load scanner config, using defaults:", error);
      this.config = DEFAULT_CONFIG;
    }
    console.log("Scanner config:", this.config);
  }
  async scanDirectory(rootDir) {
    const files = await this.findComponentFiles(rootDir);
    console.log("files:", files);
    for (const file of files) {
      await this.analyzeComponent(file);
    }
    await this.buildRelationships();
    return this.componentMap;
  }
  async findComponentFiles(dir, depth = 0) {
    console.log("Scanning directory:", dir);
    if (this.config.maxDepth > 0 && depth >= this.config.maxDepth) {
      return [];
    }
    const files = [];
    const entries = await fs.readdir(dir, { withFileTypes: true });
    console.log("Found entries:", entries.map((e) => ({ name: e.name, isDir: e.isDirectory() })));
    for (const entry of entries) {
      const fullPath = path2.join(dir, entry.name);
      if (entry.isDirectory()) {
        console.log("Entering directory:", fullPath);
        files.push(...await this.findComponentFiles(fullPath, depth + 1));
      } else {
        console.log("Checking file:", fullPath);
        const isComponent = this.isComponentFile(entry.name);
        console.log("Is component file?", isComponent, entry.name);
        if (isComponent) {
          console.log("Adding component file:", fullPath);
          files.push(fullPath);
        }
      }
    }
    return files;
  }
  isComponentFile(filename) {
    const matchesInclude = this.config.includes.some((pattern) => {
      const globPattern = pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\./g, "\\.");
      const regex = new RegExp(globPattern);
      const matches = regex.test(filename);
      console.log("Testing include pattern:", pattern, "against:", filename, "Result:", matches);
      return matches;
    });
    const matchesExclude = this.config.excludes.some((pattern) => {
      const globPattern = pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\./g, "\\.");
      const regex = new RegExp(globPattern);
      const matches = regex.test(filename);
      console.log("Testing exclude pattern:", pattern, "against:", filename, "Result:", matches);
      return matches;
    });
    return matchesInclude && !matchesExclude;
  }
  async analyzeComponent(filePath) {
    const content = await fs.readFile(filePath, "utf-8");
    const ast = (0, import_parser.parse)(content, {
      sourceType: "module",
      plugins: ["typescript", "jsx"]
    });
    const componentName = path2.basename(filePath, path2.extname(filePath)).replace(/^[a-z]/, (c) => c.toUpperCase());
    const componentNode = {
      name: componentName,
      path: filePath,
      children: [],
      parents: [],
      imports: [],
      testIds: []
    };
    (0, import_traverse2.default)(ast, {
      ImportDeclaration: (path3) => {
        componentNode.imports.push(path3.node.source.value);
      },
      JSXIdentifier: (path3) => {
        if (this.isCustomComponent(path3.node.name)) {
          componentNode.children.push(path3.node.name);
        }
      },
      JSXAttribute: (path3) => {
        if (path3.node.name.name === "data-testid" && t2.isStringLiteral(path3.node.value)) {
          const testId = path3.node.value.value;
          const validationResult = this.validator.validate(testId, componentNode);
          if (!validationResult.isValid) {
            validationResult.errors.forEach((error) => {
              console.error(`Invalid test ID "${testId}": ${error.message}`);
              console.error(`Suggestion: ${error.suggestion}`);
            });
          }
          componentNode.testIds.push(testId);
        }
      }
    });
    this.componentMap.set(componentNode.name, componentNode);
  }
  async buildRelationships() {
    for (const [name, component] of this.componentMap.entries()) {
      for (const childName of component.children) {
        const childComponent = this.componentMap.get(childName);
        if (childComponent) {
          childComponent.parents.push(name);
        }
      }
    }
  }
  isCustomComponent(name) {
    return /^[A-Z]/.test(name);
  }
};

// src/shared/utils/FileHasher.ts
var crypto = __toESM(require("crypto"));
var fs2 = __toESM(require("fs/promises"));
var FileHasher = class {
  static async hashFile(filePath) {
    const content = await fs2.readFile(filePath);
    return crypto.createHash("sha256").update(content).digest("hex");
  }
  static async hashContent(content) {
    return crypto.createHash("sha256").update(content).digest("hex");
  }
};

// src/component-management/managers/HashTrackingManager.ts
var fs3 = __toESM(require("fs/promises"));
var HashTrackingManager = class {
  constructor(storePath = ".hash-store.json") {
    this.hashStore = /* @__PURE__ */ new Map();
    this.storePath = storePath;
  }
  async trackFile(filePath, relatedComponents = []) {
    const hash = await FileHasher.hashFile(filePath);
    const fileHash = {
      path: filePath,
      hash,
      lastUpdated: /* @__PURE__ */ new Date(),
      relatedComponents
    };
    this.hashStore.set(filePath, fileHash);
    await this.persistStore();
    return fileHash;
  }
  async hasFileChanged(filePath) {
    const currentHash = await FileHasher.hashFile(filePath);
    const storedHash = this.hashStore.get(filePath);
    return !storedHash || storedHash.hash !== currentHash;
  }
  async getChangedFiles() {
    const changedFiles = [];
    for (const [filePath, stored] of this.hashStore) {
      if (await this.hasFileChanged(filePath)) {
        changedFiles.push(stored);
      }
    }
    return changedFiles;
  }
  async persistStore() {
    const storeData = JSON.stringify(Array.from(this.hashStore.entries()), null, 2);
    await fs3.writeFile(this.storePath, storeData);
  }
  async loadStore() {
    try {
      const data = await fs3.readFile(this.storePath, "utf-8");
      this.hashStore = new Map(JSON.parse(data));
    } catch (error) {
      this.hashStore = /* @__PURE__ */ new Map();
    }
  }
};

// src/shared/tags/TagManager.ts
var TagManager = class {
  constructor(tagStorePath) {
    this.tagStorePath = tagStorePath;
    this.tags = /* @__PURE__ */ new Map();
  }
  async loadTags() {
    try {
      console.log("Loading tags from:", this.tagStorePath);
    } catch (error) {
      console.error("Failed to load tags:", error);
      this.tags = /* @__PURE__ */ new Map();
    }
  }
  async registerTag(tag) {
    this.tags.set(tag.name, tag);
    await this.saveTags();
  }
  async saveTags() {
    try {
      console.log("Saving tags to:", this.tagStorePath);
    } catch (error) {
      console.error("Failed to save tags:", error);
    }
  }
  getTag(name) {
    return this.tags.get(name);
  }
  getAllTags() {
    return Array.from(this.tags.values());
  }
  getTagsByComponent(componentPath) {
    return Array.from(this.tags.values()).filter((tag) => tag.components.includes(componentPath));
  }
  async updateRelationships(tagName, relationships) {
    const tag = this.tags.get(tagName);
    if (!tag) throw new Error(`Tag ${tagName} not found`);
    tag.relationships = relationships;
    tag.metadata.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    await this.saveTags();
  }
  getRelatedTags(tagName) {
    const tag = this.tags.get(tagName);
    if (!tag) return [];
    return Array.from(this.tags.values()).filter((t3) => tag.relationships.includes(t3.name));
  }
  validateTag(tag) {
    if (!tag.name.startsWith("@")) {
      throw new Error("Tag name must start with @");
    }
    if (!/^@[a-z_]+/.test(tag.name)) {
      throw new Error("Tag name must use lowercase and underscores");
    }
    if (tag.components.length === 0) {
      throw new Error("Tag must be associated with at least one component");
    }
  }
};

// src/component-management/managers/component-manager.ts
var ComponentHierarchyManager = class {
  constructor() {
    var _a, _b;
    console.log("Initializing ComponentHierarchyManager");
    const config = getConfig("manager", {
      required: false,
      configPath: process.env.MANAGER_CONFIG_PATH
    });
    const browserStackConfig = config.browserStack || { enabled: false };
    this.scanner = new ComponentHierarchyScanner();
    this.hashTracker = new HashTrackingManager(((_a = config.tracking) == null ? void 0 : _a.hashStoreFile) || ".hash-store.json");
    this.tagManager = new TagManager(((_b = config.tracking) == null ? void 0 : _b.tagStoreFile) || ".tag-store.json");
    this.config = config || {};
  }
  async scanHierarchy() {
    var _a;
    console.log("Scanning hierarchy");
    const rootDir = ((_a = this.config) == null ? void 0 : _a.rootDir) || "src/components";
    console.log("Scanning directory:", rootDir);
    const hierarchy = await this.scanner.scanDirectory(rootDir);
    await this.trackComponentFiles(hierarchy);
    await this.processHierarchy(hierarchy);
    return hierarchy;
  }
  async trackComponentFiles(hierarchy) {
    console.log("Tracking component files:", hierarchy);
    for (const [name, component] of hierarchy) {
      await this.hashTracker.trackFile(component.path, [name]);
    }
  }
  async processHierarchy(hierarchy) {
    console.log("Processing hierarchy:", hierarchy);
    await this.tagManager.loadTags();
    for (const [name, component] of hierarchy) {
      await this.tagManager.registerTag({
        name: `@root_${name.toLowerCase()}`,
        components: [component.path],
        relationships: component.children.map(
          (childName) => `@root_${childName.toLowerCase()}`
        ),
        category: "component",
        metadata: {
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    }
  }
};

// src/coverage/reporters/coverage.ts
var CoverageReportGenerator = class {
  constructor(outputPath = "./coverage-report.json") {
    this.outputPath = outputPath;
  }
  async generateReport(components) {
    const covered = components.filter(
      (c) => c.coverage.unit > 0 || c.coverage.e2e > 0 || c.coverage.visual > 0 || c.coverage.runtime > 0
    ).length;
    const report = {
      components,
      summary: {
        total: components.length,
        covered,
        percentage: covered / components.length * 100
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    console.log(`Generated coverage report with ${covered}/${components.length} components covered`);
    return report;
  }
  async saveReport(report) {
    console.log("Saved coverage report to:", this.outputPath);
  }
};

// src/cli.ts
var program2 = new Command();
program2.name("coverage-venn").description("Component coverage analysis and visualization tool").version("1.0.0");
program2.command("scan").description("Scan a directory for component coverage analysis").argument("<directory>", "Directory to scan").option("-o, --output <path>", "Output path for coverage report", "./coverage-report.json").option("-c, --config <path>", "Path to config file").action(async (directory, options) => {
  try {
    if (options.config) {
      process.env.MANAGER_CONFIG_PATH = options.config;
    }
    console.log(`Scanning directory: ${directory}`);
    const hierarchyManager = new ComponentHierarchyManager();
    const reportGenerator = new CoverageReportGenerator(options.output);
    const hierarchy = await hierarchyManager.scanHierarchy();
    const coverageData = Array.from(hierarchy.values()).map((component) => ({
      path: component.path,
      coverage: {
        unit: 0,
        // These would be populated by actual coverage data
        e2e: 0,
        visual: 0,
        runtime: 0
      },
      testIds: component.testIds,
      tags: []
      // Would be populated by tag manager
    }));
    const report = await reportGenerator.generateReport(coverageData);
    await reportGenerator.saveReport(report);
    console.log("Coverage analysis complete!");
    console.log(`Report saved to: ${options.output}`);
    console.log(`Total components: ${report.summary.total}`);
    console.log(`Coverage: ${report.summary.percentage.toFixed(2)}%`);
  } catch (error) {
    console.error("Error during scan:", error);
    process.exit(1);
  }
});
program2.parse();
