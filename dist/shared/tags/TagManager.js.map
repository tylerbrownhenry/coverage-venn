{
  "version": 3,
  "sources": ["../../../src/shared/tags/TagManager.ts"],
  "sourcesContent": ["import * as fs from 'fs/promises';\nimport * as path from 'path';\n\ninterface Tag {\n  name: string;\n  components: string[];\n  relationships: string[];\n  category: string;\n  metadata: {\n    createdAt: string;\n    updatedAt: string;\n  };\n}\n\nexport class TagManager {\n  private tagStorePath: string;\n  private tags: Map<string, Tag>;\n\n  constructor(tagStorePath: string) {\n    this.tagStorePath = tagStorePath;\n    this.tags = new Map();\n  }\n\n  async loadTags(): Promise<void> {\n    try {\n      // In a real implementation, we would load from this.tagStorePath\n      console.log('Loading tags from:', this.tagStorePath);\n    } catch (error) {\n      console.error('Failed to load tags:', error);\n      // Initialize with empty map if file doesn't exist\n      this.tags = new Map();\n    }\n  }\n\n  async registerTag(tag: Tag): Promise<void> {\n    this.tags.set(tag.name, tag);\n    await this.saveTags();\n  }\n\n  async saveTags(): Promise<void> {\n    try {\n      // In a real implementation, we would save to this.tagStorePath\n      console.log('Saving tags to:', this.tagStorePath);\n    } catch (error) {\n      console.error('Failed to save tags:', error);\n    }\n  }\n\n  getTag(name: string): Tag | undefined {\n    return this.tags.get(name);\n  }\n\n  getAllTags(): Tag[] {\n    return Array.from(this.tags.values());\n  }\n\n  getTagsByComponent(componentPath: string): Tag[] {\n    return Array.from(this.tags.values())\n      .filter(tag => tag.components.includes(componentPath));\n  }\n\n  async updateRelationships(tagName: string, relationships: string[]): Promise<void> {\n    const tag = this.tags.get(tagName);\n    if (!tag) throw new Error(`Tag ${tagName} not found`);\n\n    tag.relationships = relationships;\n    tag.metadata.updatedAt = new Date().toISOString();\n    await this.saveTags();\n  }\n\n  getRelatedTags(tagName: string): Tag[] {\n    const tag = this.tags.get(tagName);\n    if (!tag) return [];\n\n    return Array.from(this.tags.values())\n      .filter(t => tag.relationships.includes(t.name));\n  }\n\n  private validateTag(tag: Tag): void {\n    if (!tag.name.startsWith('@')) {\n      throw new Error('Tag name must start with @');\n    }\n\n    if (!/^@[a-z_]+/.test(tag.name)) {\n      throw new Error('Tag name must use lowercase and underscores');\n    }\n\n    if (tag.components.length === 0) {\n      throw new Error('Tag must be associated with at least one component');\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAcO,MAAM,WAAW;AAAA,EAItB,YAAY,cAAsB;AAChC,SAAK,eAAe;AACpB,SAAK,OAAO,oBAAI,IAAI;AAAA,EACtB;AAAA,EAEA,MAAM,WAA0B;AAC9B,QAAI;AAEF,cAAQ,IAAI,sBAAsB,KAAK,YAAY;AAAA,IACrD,SAAS,OAAO;AACd,cAAQ,MAAM,wBAAwB,KAAK;AAE3C,WAAK,OAAO,oBAAI,IAAI;AAAA,IACtB;AAAA,EACF;AAAA,EAEA,MAAM,YAAY,KAAyB;AACzC,SAAK,KAAK,IAAI,IAAI,MAAM,GAAG;AAC3B,UAAM,KAAK,SAAS;AAAA,EACtB;AAAA,EAEA,MAAM,WAA0B;AAC9B,QAAI;AAEF,cAAQ,IAAI,mBAAmB,KAAK,YAAY;AAAA,IAClD,SAAS,OAAO;AACd,cAAQ,MAAM,wBAAwB,KAAK;AAAA,IAC7C;AAAA,EACF;AAAA,EAEA,OAAO,MAA+B;AACpC,WAAO,KAAK,KAAK,IAAI,IAAI;AAAA,EAC3B;AAAA,EAEA,aAAoB;AAClB,WAAO,MAAM,KAAK,KAAK,KAAK,OAAO,CAAC;AAAA,EACtC;AAAA,EAEA,mBAAmB,eAA8B;AAC/C,WAAO,MAAM,KAAK,KAAK,KAAK,OAAO,CAAC,EACjC,OAAO,SAAO,IAAI,WAAW,SAAS,aAAa,CAAC;AAAA,EACzD;AAAA,EAEA,MAAM,oBAAoB,SAAiB,eAAwC;AACjF,UAAM,MAAM,KAAK,KAAK,IAAI,OAAO;AACjC,QAAI,CAAC,IAAK,OAAM,IAAI,MAAM,OAAO,OAAO,YAAY;AAEpD,QAAI,gBAAgB;AACpB,QAAI,SAAS,aAAY,oBAAI,KAAK,GAAE,YAAY;AAChD,UAAM,KAAK,SAAS;AAAA,EACtB;AAAA,EAEA,eAAe,SAAwB;AACrC,UAAM,MAAM,KAAK,KAAK,IAAI,OAAO;AACjC,QAAI,CAAC,IAAK,QAAO,CAAC;AAElB,WAAO,MAAM,KAAK,KAAK,KAAK,OAAO,CAAC,EACjC,OAAO,OAAK,IAAI,cAAc,SAAS,EAAE,IAAI,CAAC;AAAA,EACnD;AAAA,EAEQ,YAAY,KAAgB;AAClC,QAAI,CAAC,IAAI,KAAK,WAAW,GAAG,GAAG;AAC7B,YAAM,IAAI,MAAM,4BAA4B;AAAA,IAC9C;AAEA,QAAI,CAAC,YAAY,KAAK,IAAI,IAAI,GAAG;AAC/B,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,QAAI,IAAI,WAAW,WAAW,GAAG;AAC/B,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAAA,EACF;AACF;",
  "names": []
}
