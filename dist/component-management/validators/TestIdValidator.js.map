{
  "version": 3,
  "sources": ["../../../src/component-management/validators/TestIdValidator.ts"],
  "sourcesContent": ["import { ComponentNode } from '../scanners/ComponentHierarchyScanner';\nimport { TestIdRule, ValidationResult, ValidationError } from './types';\n\nexport class TestIdValidator {\n  private rules: TestIdRule[] = [\n    {\n      name: 'prefix',\n      pattern: /^(root|shared)_/,\n      message: 'Test ID must start with \"root_\" or \"shared_\"',\n      severity: 'error',\n      validate: (testId) => /^(root|shared)_/.test(testId)\n    },\n    {\n      name: 'case',\n      pattern: /^[a-z]+(_[a-z]+)*$/,\n      message: 'Test ID must be lowercase with underscore separators',\n      severity: 'error',\n      validate: (testId) => /^[a-z]+(_[a-z]+)*$/.test(testId)\n    },\n    {\n      name: 'hierarchy',\n      pattern: /^.*$/,\n      message: 'Test ID must reflect component hierarchy',\n      severity: 'error',\n      validate: (testId, component) => {\n        const expectedPrefix = this.generateExpectedPrefix(component);\n        return testId.startsWith(expectedPrefix);\n      }\n    }\n  ];\n\n  validate(testId: string, component: ComponentNode): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationError[] = [];\n\n    this.rules.forEach(rule => {\n      if (!rule.validate(testId, component)) {\n        const error: ValidationError = {\n          rule: rule.name,\n          message: rule.message,\n          testId,\n          component: component.name,\n          suggestion: this.generateSuggestion(rule, component)\n        };\n\n        if (rule.severity === 'error') {\n          errors.push(error);\n        } else {\n          warnings.push(error);\n        }\n      }\n    });\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  private generateExpectedPrefix(component: ComponentNode): string {\n    const pathSegments = component.path\n      .split('/')\n      .filter(segment => segment.length > 0);\n    \n    const isShared = pathSegments.includes('shared');\n    const prefix = isShared ? 'shared' : 'root';\n    \n    return `${prefix}_${component.name.toLowerCase()}`;\n  }\n\n  private generateSuggestion(rule: TestIdRule, component: ComponentNode): string {\n    switch (rule.name) {\n      case 'prefix':\n        return this.generateExpectedPrefix(component);\n      case 'case':\n        return component.name.toLowerCase();\n      case 'hierarchy':\n        return this.generateExpectedPrefix(component);\n      default:\n        return '';\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGO,MAAM,gBAAgB;AAAA,EAAtB;AACL,SAAQ,QAAsB;AAAA,MAC5B;AAAA,QACE,MAAM;AAAA,QACN,SAAS;AAAA,QACT,SAAS;AAAA,QACT,UAAU;AAAA,QACV,UAAU,CAAC,WAAW,kBAAkB,KAAK,MAAM;AAAA,MACrD;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,SAAS;AAAA,QACT,SAAS;AAAA,QACT,UAAU;AAAA,QACV,UAAU,CAAC,WAAW,qBAAqB,KAAK,MAAM;AAAA,MACxD;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,SAAS;AAAA,QACT,SAAS;AAAA,QACT,UAAU;AAAA,QACV,UAAU,CAAC,QAAQ,cAAc;AAC/B,gBAAM,iBAAiB,KAAK,uBAAuB,SAAS;AAC5D,iBAAO,OAAO,WAAW,cAAc;AAAA,QACzC;AAAA,MACF;AAAA,IACF;AAAA;AAAA,EAEA,SAAS,QAAgB,WAA4C;AACnE,UAAM,SAA4B,CAAC;AACnC,UAAM,WAA8B,CAAC;AAErC,SAAK,MAAM,QAAQ,UAAQ;AACzB,UAAI,CAAC,KAAK,SAAS,QAAQ,SAAS,GAAG;AACrC,cAAM,QAAyB;AAAA,UAC7B,MAAM,KAAK;AAAA,UACX,SAAS,KAAK;AAAA,UACd;AAAA,UACA,WAAW,UAAU;AAAA,UACrB,YAAY,KAAK,mBAAmB,MAAM,SAAS;AAAA,QACrD;AAEA,YAAI,KAAK,aAAa,SAAS;AAC7B,iBAAO,KAAK,KAAK;AAAA,QACnB,OAAO;AACL,mBAAS,KAAK,KAAK;AAAA,QACrB;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO;AAAA,MACL,SAAS,OAAO,WAAW;AAAA,MAC3B;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,uBAAuB,WAAkC;AAC/D,UAAM,eAAe,UAAU,KAC5B,MAAM,GAAG,EACT,OAAO,aAAW,QAAQ,SAAS,CAAC;AAEvC,UAAM,WAAW,aAAa,SAAS,QAAQ;AAC/C,UAAM,SAAS,WAAW,WAAW;AAErC,WAAO,GAAG,MAAM,IAAI,UAAU,KAAK,YAAY,CAAC;AAAA,EAClD;AAAA,EAEQ,mBAAmB,MAAkB,WAAkC;AAC7E,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AACH,eAAO,KAAK,uBAAuB,SAAS;AAAA,MAC9C,KAAK;AACH,eAAO,UAAU,KAAK,YAAY;AAAA,MACpC,KAAK;AACH,eAAO,KAAK,uBAAuB,SAAS;AAAA,MAC9C;AACE,eAAO;AAAA,IACX;AAAA,EACF;AACF;",
  "names": []
}
