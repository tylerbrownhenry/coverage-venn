{
  "version": 3,
  "sources": ["../../../src/component-management/validators/TestIdGenerator.ts"],
  "sourcesContent": ["import * as t from '@babel/types';\nimport traverse, { NodePath } from '@babel/traverse';\nimport { ComponentNode } from '../scanners/ComponentHierarchyScanner';\nimport { TestIdValidator } from './TestIdValidator';\n\nexport interface ElementType {\n  type: string;\n  variant?: string;\n  role?: string;\n}\n\nexport interface TestIdRecommendation {\n  elementId: string;\n  elementType: ElementType;\n  elementPath: string;\n  recommendedTestId: string;\n  confidence: number;\n  reason: string;\n}\n\nexport class TestIdGenerator {\n  private validator: TestIdValidator;\n\n  constructor() {\n    this.validator = new TestIdValidator();\n  }\n\n  /**\n   * Generate recommended testIDs for a component\n   * @param component The component to analyze\n   * @param ast The AST of the component\n   */\n  generateRecommendations(component: ComponentNode, ast: t.File): TestIdRecommendation[] {\n    const recommendations: TestIdRecommendation[] = [];\n    \n    // Find all JSX elements in the component\n    this.traverseJsxElements(ast, (path, elementInfo) => {\n      // Skip elements that already have testIDs\n      if (this.hasTestId(path)) {\n        return;\n      }\n      \n      // Generate a recommended testID for the element\n      const testId = this.generateTestIdForElement(component, elementInfo);\n      \n      recommendations.push({\n        elementId: elementInfo.type + (elementInfo.variant ? `-${elementInfo.variant}` : ''),\n        elementType: elementInfo,\n        elementPath: this.getElementPath(path),\n        recommendedTestId: testId,\n        confidence: this.calculateConfidence(elementInfo),\n        reason: this.generateReason(elementInfo)\n      });\n    });\n    \n    return recommendations;\n  }\n\n  /**\n   * Check if an element already has a testID\n   */\n  private hasTestId(path: NodePath<t.JSXElement>): boolean {\n    const attributes = path.node.openingElement.attributes;\n    return attributes.some(attr => \n      t.isJSXAttribute(attr) && \n      (\n        (t.isJSXIdentifier(attr.name) && \n         (attr.name.name === 'data-testid' || attr.name.name === 'testID'))\n      )\n    );\n  }\n\n  /**\n   * Traverse all JSX elements in an AST\n   */\n  private traverseJsxElements(\n    ast: t.File, \n    callback: (path: NodePath<t.JSXElement>, elementInfo: ElementType) => void\n  ): void {\n    const self = this;\n    traverse(ast, {\n      JSXElement(path: NodePath<t.JSXElement>) {\n        const elementName = self.getElementName(path);\n        const elementInfo = self.analyzeElement(path);\n        \n        callback(path, elementInfo);\n      }\n    });\n  }\n\n  /**\n   * Get the name of a JSX element\n   */\n  private getElementName(path: NodePath<t.JSXElement>): string {\n    const openingElement = path.node.openingElement;\n    if (t.isJSXIdentifier(openingElement.name)) {\n      return openingElement.name.name;\n    } else if (t.isJSXMemberExpression(openingElement.name)) {\n      // For expressions like Styled.Button\n      let result = '';\n      let current: t.JSXMemberExpression | t.JSXIdentifier = openingElement.name;\n      \n      while (t.isJSXMemberExpression(current)) {\n        if (t.isJSXIdentifier(current.property)) {\n          result = current.property.name + (result ? '.' + result : '');\n        }\n        current = current.object;\n      }\n      \n      if (t.isJSXIdentifier(current)) {\n        result = current.name + (result ? '.' + result : '');\n      }\n      \n      return result;\n    }\n    \n    return 'unknown';\n  }\n\n  /**\n   * Analyze a JSX element to determine its type and properties\n   */\n  private analyzeElement(path: NodePath<t.JSXElement>): ElementType {\n    const elementName = this.getElementName(path);\n    const attributes = path.node.openingElement.attributes;\n    \n    // Default element type\n    const elementType: ElementType = {\n      type: elementName.toLowerCase()\n    };\n    \n    // Check for role attribute\n    const roleAttr = attributes.find(attr => \n      t.isJSXAttribute(attr) && \n      t.isJSXIdentifier(attr.name) && \n      attr.name.name === 'role'\n    );\n    \n    if (roleAttr && t.isJSXAttribute(roleAttr) && roleAttr.value) {\n      if (t.isStringLiteral(roleAttr.value)) {\n        elementType.role = roleAttr.value.value;\n      }\n    }\n    \n    // Check for variant or type attributes\n    const variantAttr = attributes.find(attr => \n      t.isJSXAttribute(attr) && \n      t.isJSXIdentifier(attr.name) && \n      (attr.name.name === 'variant' || attr.name.name === 'type')\n    );\n    \n    if (variantAttr && t.isJSXAttribute(variantAttr) && variantAttr.value) {\n      if (t.isStringLiteral(variantAttr.value)) {\n        elementType.variant = variantAttr.value.value;\n      }\n    }\n    \n    return elementType;\n  }\n\n  /**\n   * Generate a testID for an element based on component and element type\n   */\n  private generateTestIdForElement(component: ComponentNode, elementInfo: ElementType): string {\n    const componentName = component.name.toLowerCase();\n    const elementType = elementInfo.type.toLowerCase();\n    const variant = elementInfo.variant ? elementInfo.variant.toLowerCase() : '';\n    const role = elementInfo.role ? elementInfo.role.toLowerCase() : '';\n    \n    // Determine prefix based on component path\n    const isShared = component.path.includes('shared');\n    const prefix = isShared ? 'shared' : 'root';\n    \n    // Generate testID based on naming convention\n    let testId = `${prefix}_${componentName}`;\n    \n    // Add element type if it's not the root element\n    if (elementType !== 'div' && elementType !== 'component') {\n      testId += `_${elementType}`;\n    }\n    \n    // Add variant if available\n    if (variant) {\n      testId += `_${variant}`;\n    }\n    \n    // Add role if available\n    if (role) {\n      testId += `_${role}`;\n    }\n    \n    return testId;\n  }\n\n  /**\n   * Calculate confidence score for a recommendation\n   */\n  private calculateConfidence(elementInfo: ElementType): number {\n    // Base confidence\n    let confidence = 0.7;\n    \n    // Adjust based on element type\n    if (this.isInteractiveElement(elementInfo)) {\n      confidence += 0.2; // Higher confidence for interactive elements\n    }\n    \n    // Adjust based on role\n    if (elementInfo.role) {\n      confidence += 0.1;\n    }\n    \n    return Math.min(confidence, 1.0);\n  }\n\n  /**\n   * Check if an element is interactive\n   */\n  private isInteractiveElement(elementInfo: ElementType): boolean {\n    const interactiveTypes = ['button', 'input', 'a', 'select', 'textarea', 'option'];\n    const interactiveRoles = ['button', 'link', 'checkbox', 'radio', 'tab', 'menuitem'];\n    \n    const typeMatch = interactiveTypes.includes(elementInfo.type.toLowerCase());\n    const roleMatch = elementInfo.role ? interactiveRoles.includes(elementInfo.role.toLowerCase()) : false;\n    \n    return typeMatch || roleMatch;\n  }\n\n  /**\n   * Generate a reason for the recommendation\n   */\n  private generateReason(elementInfo: ElementType): string {\n    if (this.isInteractiveElement(elementInfo)) {\n      return `Interactive ${elementInfo.type} elements should have testIDs for testing user interactions`;\n    }\n    \n    if (elementInfo.role) {\n      return `Elements with role '${elementInfo.role}' should have testIDs for accessibility testing`;\n    }\n    \n    return `Adding testID improves component testability`;\n  }\n\n  /**\n   * Get a string representation of the element's path in the component\n   */\n  private getElementPath(path: NodePath<t.JSXElement>): string {\n    const elements: string[] = [];\n    let current: NodePath | null = path;\n    \n    while (current) {\n      if (current.isJSXElement()) {\n        const element = current.node as t.JSXElement;\n        const openingElement = element.openingElement;\n        \n        if (t.isJSXIdentifier(openingElement.name)) {\n          elements.unshift(openingElement.name.name);\n        }\n      }\n      \n      current = current.parentPath;\n      \n      // Stop if we reach the function/component declaration\n      if (current && (current.isFunction() || current.isVariableDeclaration())) {\n        break;\n      }\n    }\n    \n    return elements.join(' > ') || 'component';\n  }\n\n  /**\n   * Detect interactive elements in a component\n   */\n  detectInteractiveElements(ast: t.File): ElementType[] {\n    const interactiveElements: ElementType[] = [];\n    const self = this;\n    \n    traverse(ast, {\n      JSXElement: (path: NodePath<t.JSXElement>) => {\n        const elementInfo = self.analyzeElement(path);\n        \n        if (self.isInteractiveElement(elementInfo) && !self.hasTestId(path)) {\n          interactiveElements.push(elementInfo);\n        }\n      }\n    });\n    \n    return interactiveElements;\n  }\n} "],
  "mappings": "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",
  "names": ["traverse"]
}
